<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第二章-集成spring</title>
    <url>/2019/11/05/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9B%86%E6%88%90spring/</url>
    <content><![CDATA[<p>本章主要介绍了spring REST服务以及与JMS、RabbitMQ的集成。</p>
<h2 id="构建一个REST服务"><a href="#构建一个REST服务" class="headerlink" title="构建一个REST服务"></a>构建一个REST服务</h2><p>常用的几个请求方式注解。<br><img src="/images/spring-ch2-001.png" alt="Alt text"><br>案例：<br><img src="/images/spring-ch2-002.png" alt="Alt text"></p>
<h3 id="允许XML输出"><a href="#允许XML输出" class="headerlink" title="允许XML输出"></a>允许XML输出</h3><figure class="highlight java"><figcaption><span>[允许XML输出]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path=<span class="string">"/design"</span>, produces=&#123;<span class="string">"application/json"</span>, <span class="string">"text/xml"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="url传参"><a href="#url传参" class="headerlink" title="url传参"></a>url传参</h3><figure class="highlight java"><figcaption><span>[url传参]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Taco <span class="title">tacoById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">	Optional&lt;Taco&gt; optTaco = tacoRepo.findById(id);</span><br><span class="line">	<span class="keyword">if</span> (optTaco.isPresent()) &#123;</span><br><span class="line">		<span class="keyword">return</span> optTaco.get();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url返回404"><a href="#url返回404" class="headerlink" title="url返回404"></a>url返回404</h3><figure class="highlight java"><figcaption><span>[返回404]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Taco&gt; <span class="title">tacoById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">	Optional&lt;Taco&gt; optTaco = tacoRepo.findById(id);</span><br><span class="line">	<span class="keyword">if</span> (optTaco.isPresent()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(optTaco.get(), HttpStatus.OK);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">null</span>, HttpStatus.NOT_FOUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用REST服务"><a href="#使用REST服务" class="headerlink" title="使用REST服务"></a>使用REST服务</h2><h3 id="使用RestTemplate使用REST端点"><a href="#使用RestTemplate使用REST端点" class="headerlink" title="使用RestTemplate使用REST端点"></a>使用RestTemplate使用REST端点</h3><p><img src="/images/spring-ch2-003.png" alt="Alt text"></p>
<h4 id="配置RestTemplate"><a href="#配置RestTemplate" class="headerlink" title="配置RestTemplate"></a>配置RestTemplate</h4><figure class="highlight java"><figcaption><span>[spring配置类]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获得资源（Getting-resouces）"><a href="#获得资源（Getting-resouces）" class="headerlink" title="获得资源（Getting resouces）"></a>获得资源（Getting resouces）</h4><figure class="highlight java"><figcaption><span>[查询：getForObject()]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">	Map&lt;String,String&gt; urlVariables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	urlVariables.put(<span class="string">"id"</span>, ingredientId);</span><br><span class="line">	<span class="keyword">return</span> rest.getForObject(<span class="string">"http://localhost:8080/ingredients/&#123;id&#125;"</span>,</span><br><span class="line">		Ingredient<span class="class">.<span class="keyword">class</span>, <span class="title">urlVariables</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[查询：URI+getForObject()]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">	Map&lt;String,String&gt; urlVariables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	urlVariables.put(<span class="string">"id"</span>, ingredientId);</span><br><span class="line">	URI url = UriComponentsBuilder</span><br><span class="line">		.fromHttpUrl(<span class="string">"http://localhost:8080/ingredients/&#123;id&#125;"</span>)</span><br><span class="line">		.build(urlVariables);</span><br><span class="line">	<span class="keyword">return</span> rest.getForObject(url, Ingredient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[查询：getForEntity()]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">	ResponseEntity&lt;Ingredient&gt; responseEntity =</span><br><span class="line">		rest.getForEntity(<span class="string">"http://localhost:8080/ingredients/&#123;id&#125;"</span>,</span><br><span class="line">			Ingredient<span class="class">.<span class="keyword">class</span>, <span class="title">ingredientId</span>)</span>;</span><br><span class="line">	log.info(<span class="string">"Fetched time: "</span> +</span><br><span class="line">		responseEntity.getHeaders().getDate());</span><br><span class="line">	<span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新资源（Putting-resouces）"><a href="#更新资源（Putting-resouces）" class="headerlink" title="更新资源（Putting resouces）"></a>更新资源（Putting resouces）</h4><figure class="highlight java"><figcaption><span>[新增或编辑]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">	rest.put(<span class="string">"http://localhost:8080/ingredients/&#123;id&#125;"</span>,</span><br><span class="line">		ingredient,</span><br><span class="line">		ingredient.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除资源（DELETEing-resources）"><a href="#删除资源（DELETEing-resources）" class="headerlink" title="删除资源（DELETEing resources）"></a>删除资源（DELETEing resources）</h4><figure class="highlight java"><figcaption><span>[删除]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">	rest.delete(<span class="string">"http://localhost:8080/ingredients/&#123;id&#125;"</span>,</span><br><span class="line">		ingredient.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发布资源（POSTing-resource-data）"><a href="#发布资源（POSTing-resource-data）" class="headerlink" title="发布资源（POSTing resource data）"></a>发布资源（POSTing resource data）</h4><figure class="highlight java"><figcaption><span>[发布资源]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rest.postForObject(<span class="string">"http://localhost:8080/ingredients"</span>,</span><br><span class="line">							ingredient,</span><br><span class="line">							Ingredient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rest.postForLocation(<span class="string">"http://localhost:8080/ingredients"</span>,</span><br><span class="line">		ingredient);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">createIngredient</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">	ResponseEntity&lt;Ingredient&gt; responseEntity =</span><br><span class="line">		rest.postForEntity(<span class="string">"http://localhost:8080/ingredients"</span>,</span><br><span class="line">			ingredient,</span><br><span class="line">			Ingredient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	log.info(<span class="string">"New resource created at "</span> +</span><br><span class="line">		responseEntity.getHeaders().getLocation());</span><br><span class="line">	<span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h2><h3 id="使用JMS发送消息"><a href="#使用JMS发送消息" class="headerlink" title="使用JMS发送消息"></a>使用JMS发送消息</h3><h4 id="安装JMS"><a href="#安装JMS" class="headerlink" title="安装JMS"></a>安装JMS</h4><ol>
<li><p>添加依赖</p>
<figure class="highlight html"><figcaption><span>[pom.xml]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改spring配置文件</p>
<figure class="highlight java"><figcaption><span>[spring.yml]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	activemq:</span><br><span class="line">		broker-url: tcp:<span class="comment">//activemq.tacocloud.com</span></span><br><span class="line">		user: tacoweb</span><br><span class="line">		password: l3tm31n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="使用JmsTemplate发送消息"><a href="#使用JmsTemplate发送消息" class="headerlink" title="使用JmsTemplate发送消息"></a>使用JmsTemplate发送消息</h4><p>JmsTemplate有几个用于发送消息的方法，包括以下方法：</p>
<figure class="highlight java"><figcaption><span>[JmsTemplate核心方法]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Send raw messages</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(MessageCreator messageCreator)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Destination destination, MessageCreator messageCreator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String destinationName, MessageCreator messageCreator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="comment">// Send messages converted from objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Destination destination, Object message)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String destinationName, Object message)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="comment">// Send messages converted from objects with post-processing</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Destination destination, Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String destinationName, Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">MessagePostProcessor postProcessor)</span> <span class="keyword">throws</span> JmsException</span>;</span><br></pre></td></tr></table></figure>

<h5 id="编写发送方法"><a href="#编写发送方法" class="headerlink" title="编写发送方法"></a>编写发送方法</h5><figure class="highlight java"><figcaption><span>[send()]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsOrderMessagingService</span> <span class="keyword">implements</span> <span class="title">OrderMessagingService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> JmsTemplate jms;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JmsOrderMessagingService</span><span class="params">(JmsTemplate jms)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jms = jms;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**<span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">	public void sendOrder(Order order) &#123;</span></span><br><span class="line"><span class="comment">		jms.send(new MessageCreator() &#123;</span></span><br><span class="line"><span class="comment">					 <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">					 public Message createMessage(Session session)</span></span><br><span class="line"><span class="comment">						 throws JMSException &#123;</span></span><br><span class="line"><span class="comment">						 return session.createObjectMessage(order);</span></span><br><span class="line"><span class="comment">					 &#125;</span></span><br><span class="line"><span class="comment">				 &#125;</span></span><br><span class="line"><span class="comment">		);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">// 简化版</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		jms.send(session -&gt; session.createObjectMessage(order));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指定发送目的地"><a href="#指定发送目的地" class="headerlink" title="指定发送目的地"></a>指定发送目的地</h5><figure class="highlight java"><figcaption><span>[配置目的地]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.spring.yml文件</span></span><br><span class="line">spring:</span><br><span class="line">	jms:</span><br><span class="line">		template:</span><br><span class="line">			<span class="keyword">default</span>-destination: tacocloud.order.queue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.配置类</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Destination <span class="title">orderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(<span class="string">"tacocloud.order.queue"</span>);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.注入到service类，JmsOrderMessagingService</span></span><br><span class="line"><span class="keyword">private</span> Destination orderQueue;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JmsOrderMessagingService</span><span class="params">(JmsTemplate jms,</span></span></span><br><span class="line"><span class="function"><span class="params">								Destination orderQueue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.jms = jms;</span><br><span class="line">	<span class="keyword">this</span>.orderQueue = orderQueue;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">	jms.send(</span><br><span class="line">		orderQueue,</span><br><span class="line">		session -&gt; session.createObjectMessage(order));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用类似这样的目标对象指定目标，使您有机会配置目标，而不仅仅是目标名称。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">	jms.send(</span><br><span class="line">		<span class="string">"tacocloud.order.queue"</span>,</span><br><span class="line">		session -&gt; session.createObjectMessage(order));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发送前对消息进行转换"><a href="#发送前对消息进行转换" class="headerlink" title="发送前对消息进行转换"></a>发送前对消息进行转换</h5><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">	jms.convertAndSend(<span class="string">"tacocloud.order.queue"</span>, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置消息转换器"><a href="#配置消息转换器" class="headerlink" title="配置消息转换器"></a>配置消息转换器</h5><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line">	<span class="function">Message <span class="title">toMessage</span><span class="params">(Object object, Session session)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> JMSException, MessageConversionException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">fromMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/spring-ch2-004.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[MappingJackson2MessageConverter]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappingJackson2MessageConverter <span class="title">messageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MappingJackson2MessageConverter messageConverter =</span><br><span class="line">		<span class="keyword">new</span> MappingJackson2MessageConverter();</span><br><span class="line">	messageConverter.setTypeIdPropertyName(<span class="string">"_typeId"</span>);</span><br><span class="line">	<span class="keyword">return</span> messageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="后期处理消息"><a href="#后期处理消息" class="headerlink" title="后期处理消息"></a>后期处理消息</h5><p>在消息中添加一个自定义头。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line">jms.send(<span class="string">"tacocloud.order.queue"</span>,</span><br><span class="line">	session -&gt; &#123;</span><br><span class="line">		Message message = session.createObjectMessage(order);</span><br><span class="line">		message.setStringProperty(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">jms.convertAndSend(<span class="string">"tacocloud.order.queue"</span>, order, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">		message.setStringProperty(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 案例-优化</span></span><br><span class="line">jms.convertAndSend(<span class="string">"tacocloud.order.queue"</span>, order,</span><br><span class="line">	message -&gt; &#123;</span><br><span class="line">		message.setStringProperty(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">	<span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 特殊情况</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/convertAndSend/order"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertAndSendOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Order order = buildOrder();</span><br><span class="line">	jms.convertAndSend(<span class="string">"tacocloud.order.queue"</span>, order,</span><br><span class="line">		<span class="keyword">this</span>::addOrderSource);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Convert and sent order"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Message <span class="title">addOrderSource</span><span class="params">(Message message)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">	message.setStringProperty(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">	<span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收JMS消息"><a href="#接收JMS消息" class="headerlink" title="接收JMS消息"></a>接收JMS消息</h4><h5 id="接收JMS-TEMPLATE"><a href="#接收JMS-TEMPLATE" class="headerlink" title="接收JMS TEMPLATE"></a>接收JMS TEMPLATE</h5><p>核心方法：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(Destination destination)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String destinationName)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(Destination destination)</span> <span class="keyword">throws</span> JmsException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String destinationName)</span> <span class="keyword">throws</span> JmsException</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例一</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsOrderReceiver</span> <span class="keyword">implements</span> <span class="title">OrderReceiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> JmsTemplate jms;</span><br><span class="line">	<span class="keyword">private</span> MessageConverter converter;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JmsOrderReceiver</span><span class="params">(JmsTemplate jms, MessageConverter converter)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jms = jms;</span><br><span class="line">		<span class="keyword">this</span>.converter = converter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Message message = jms.receive(<span class="string">"tacocloud.order.queue"</span>);</span><br><span class="line">		<span class="keyword">return</span> (Order) converter.fromMessage(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 案例二</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsOrderReceiver</span> <span class="keyword">implements</span> <span class="title">OrderReceiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> JmsTemplate jms;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JmsOrderReceiver</span><span class="params">(JmsTemplate jms)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jms = jms;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Order) jms.receiveAndConvert(<span class="string">"tacocloud.order.queue"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义消息监听器"><a href="#定义消息监听器" class="headerlink" title="定义消息监听器"></a>定义消息监听器</h5><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderListener</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> KitchenUI ui;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderListener</span><span class="params">(KitchenUI ui)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ui = ui;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@JmsListener</span>(destination = <span class="string">"tacocloud.order.queue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		ui.displayOrder(order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用RabbitMQ-and-AMQP"><a href="#使用RabbitMQ-and-AMQP" class="headerlink" title="使用RabbitMQ and AMQP"></a>使用RabbitMQ and AMQP</h3><p><img src="/images/spring-ch2-005.png" alt="Alt text"></p>
<h4 id="向Spring添加RabbitMQ"><a href="#向Spring添加RabbitMQ" class="headerlink" title="向Spring添加RabbitMQ"></a>向Spring添加RabbitMQ</h4><ol>
<li><p>添加RabbitMQ依赖</p>
<figure class="highlight html"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加RabbitMQ配置文件<br><img src="/images/spring-ch2-006.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	profiles: prod</span><br><span class="line">	rabbitmq:</span><br><span class="line">		host: rabbit.tacocloud.com</span><br><span class="line">		port: <span class="number">5673</span></span><br><span class="line">		username: tacoweb</span><br><span class="line">		password: l3tm31n</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="使用RabbitTemplate发送消息"><a href="#使用RabbitTemplate发送消息" class="headerlink" title="使用RabbitTemplate发送消息"></a>使用RabbitTemplate发送消息</h5><p>RabbitTemplate几个核心方法：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Send raw messages</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="comment">// Send messages converted from objects</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="comment">// Send messages converted from objects with post-processing</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message, MessagePostProcessor mPP)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">MessagePostProcessor messagePostProcessor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">Object message,</span></span></span><br><span class="line"><span class="function"><span class="params">MessagePostProcessor messagePostProcessor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><figcaption><span>[1.代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitOrderMessagingService</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">OrderMessagingService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbit;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RabbitOrderMessagingService</span><span class="params">(RabbitTemplate rabbit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rabbit = rabbit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		MessageConverter converter = rabbit.getMessageConverter();</span><br><span class="line">		MessageProperties props = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">		Message message = converter.toMessage(order, props);</span><br><span class="line">		rabbit.send(<span class="string">"tacocloud.order"</span>, message);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 消息转换</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		rabbit.convertAndSend(<span class="string">"tacocloud.order"</span>, order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[2.spring.yml文件]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	rabbitmq:</span><br><span class="line">	template:</span><br><span class="line">		exchange: tacocloud.orders</span><br><span class="line">		routing-key: kitchens.central</span><br></pre></td></tr></table></figure>

<h5 id="配置消息转换器-1"><a href="#配置消息转换器-1" class="headerlink" title="配置消息转换器"></a>配置消息转换器</h5><figure class="highlight java"><figcaption><span>[spring配置类]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置消息属性"><a href="#设置消息属性" class="headerlink" title="设置消息属性"></a>设置消息属性</h5><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">	MessageConverter converter = rabbit.getMessageConverter();</span><br><span class="line">	MessageProperties props = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">	props.setHeader(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">	Message message = converter.toMessage(order, props);</span><br><span class="line">	rabbit.send(<span class="string">"tacocloud.order"</span>, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">	rabbit.convertAndSend(<span class="string">"tacocloud.order.queue"</span>, order,</span><br><span class="line">		<span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span></span></span><br><span class="line"><span class="function">				<span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">				MessageProperties props = message.getMessageProperties();</span><br><span class="line">				props.setHeader(<span class="string">"X_ORDER_SOURCE"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">				<span class="keyword">return</span> message;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从RabbitMQ接收消息"><a href="#从RabbitMQ接收消息" class="headerlink" title="从RabbitMQ接收消息"></a>从RabbitMQ接收消息</h4><p>几个关键方法：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receive messages</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="comment">// Receive objects converted from messages</span></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">AmqpException</span>;</span><br><span class="line"><span class="comment">// Receive type-safe objects converted from messages</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, ParameterizedTypeReference&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">ParameterizedTypeReference&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><figcaption><span>[1.代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitOrderReceiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbit;</span><br><span class="line">	<span class="keyword">private</span> MessageConverter converter;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RabbitOrderReceiver</span><span class="params">(RabbitTemplate rabbit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rabbit = rabbit;</span><br><span class="line">		<span class="keyword">this</span>.converter = rabbit.getMessageConverter();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Message message = rabbit.receive(<span class="string">"tacocloud.orders"</span>);</span><br><span class="line">		<span class="keyword">return</span> message != <span class="keyword">null</span></span><br><span class="line">			? (Order) converter.fromMessage(message)</span><br><span class="line">			: <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 1.延迟30000毫秒接收</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Message message = rabbit.receive(<span class="string">"tacocloud.order.queue"</span>, <span class="number">30000</span>);</span><br><span class="line">		<span class="keyword">return</span> message != <span class="keyword">null</span></span><br><span class="line">			? (Order) converter.fromMessage(message)</span><br><span class="line">			: <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2-1消息转换器接收</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (Order) rabbit.receiveAndConvert(<span class="string">"tacocloud.order.queue"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2-2.消息转换器接收</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Order <span class="title">receiveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rabbit.receiveAndConvert(<span class="string">"tacocloud.order.queue"</span>,</span><br><span class="line">			<span class="keyword">new</span> ParameterizedTypeReference&lt;Order&gt;() &#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[2.spring.yml配置文件]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	rabbitmq:</span><br><span class="line">		template:</span><br><span class="line">			receive-timeout: <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<h4 id="使用侦听器处理RABBITMQ消息"><a href="#使用侦听器处理RABBITMQ消息" class="headerlink" title="使用侦听器处理RABBITMQ消息"></a>使用侦听器处理RABBITMQ消息</h4><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderListener</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> KitchenUI ui;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderListener</span><span class="params">(KitchenUI ui)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ui = ui;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = <span class="string">"tacocloud.order.queue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		ui.displayOrder(order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息传递与Kafka（略）<br><img src="/images/spring-ch2-007.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章-Spring基础</title>
    <url>/2019/11/04/%E7%AC%AC%E4%B8%80%E7%AB%A0-Spring%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本章主要学习了spring的一些核心组件、初始化一个Spring项目以及spring概览。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="spring是什么"><a href="#spring是什么" class="headerlink" title="spring是什么"></a>spring是什么</h3><p>Spring的核心是提供一个容器，通常称为Spring应用程序上下文，用于创建和管理应用程序组件。<br><img src="/images/spring-ch1-001.png" alt="Alt text"></p>
<h3 id="初始化Spring应用程序"><a href="#初始化Spring应用程序" class="headerlink" title="初始化Spring应用程序"></a>初始化Spring应用程序</h3><p>使用Spring Initializr的几种方法如下:</p>
<ul>
<li><a href="http://start.spring.io" target="_blank" rel="noopener">http://start.spring.io</a></li>
<li>curl 命令</li>
<li>使用Spring引导命令行界面</li>
<li>Spring Tool Suite new project</li>
<li>IntelliJ IDEA new project</li>
<li>NetBeans new project</li>
</ul>
<p>spring项目架构图：<br><img src="/images/spring-ch1-002.png" alt="Alt text"></p>
<h3 id="写一个helloword"><a href="#写一个helloword" class="headerlink" title="写一个helloword"></a>写一个helloword</h3><ol>
<li><p>定义controller层<br><img src="/images/spring-ch1-003.png" alt="Alt text"></p>
</li>
<li><p>定义view层<br><img src="/images/spring-ch1-004.png" alt="Alt text"></p>
</li>
<li><p>测试controller类<br><img src="/images/spring-ch1-005.png" alt="Alt text"></p>
</li>
<li><p>构建和运行spring应用<br><img src="/images/spring-ch1-006.png" alt="Alt text"></p>
</li>
</ol>
<h3 id="Spring概览"><a href="#Spring概览" class="headerlink" title="Spring概览"></a>Spring概览</h3><p>Spring核心框架是Spring领域中其他一切的基础。它提供了核心容器和依赖注入框架。</p>
<ol>
<li>Spring Boot<br>优点：</li>
</ol>
<ul>
<li>启动依赖项和自动配置</li>
<li>执行器提供对应用程序内部工作方式的运行时洞察</li>
<li>环境属性的灵活规范</li>
<li>额外的测试支持</li>
</ul>
<ol start="2">
<li><p>Spring Data<br>Spring Data提供了一些非常惊人的功能:将应用程序的数据存储库定义为简单的Java接口，在定义驱动如何存储和检索数据的方法时使用命名约定。</p>
</li>
<li><p>Spring Security<br>Spring Security解决了广泛的应用程序安全性需求，包括身份验证、授权和API安全性。</p>
</li>
<li><p>Spring Integration和Spring Batch<br>Spring Integration解决了实时集成，即数据在可用时进行处理。<br>Spring Batch解决了成批集成的问题，允许在一段时间内收集数据，直到某个触发器(可能是一个时间触发器)发出信号，表示该处理一批数据了。</p>
</li>
<li><p>Spring Cloud<br>Spring Cloud是一组用Spring开发云本地应用程序的项目。</p>
</li>
</ol>
<h2 id="部署web应用"><a href="#部署web应用" class="headerlink" title="部署web应用"></a>部署web应用</h2><h3 id="信息展示"><a href="#信息展示" class="headerlink" title="信息展示"></a>信息展示</h3><p><img src="/images/spring-ch1-007.png" alt="Alt text"></p>
<h4 id="定义domain类"><a href="#定义domain类" class="headerlink" title="定义domain类"></a>定义domain类</h4><p><img src="/images/spring-ch1-008.png" alt="Alt text"></p>
<h4 id="创建controller类"><a href="#创建controller类" class="headerlink" title="创建controller类"></a>创建controller类</h4><p><img src="/images/spring-ch1-009.png" alt="Alt text"></p>
<h4 id="设计页面"><a href="#设计页面" class="headerlink" title="设计页面"></a>设计页面</h4><figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">1. 添加依赖包</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. 页面显示变量</span><br><span class="line">单个变量：</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;message&#125;"</span>&gt;</span>placeholder message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">对象：</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Designate your wrap:<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">"ingredient : $&#123;wrap&#125;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"ingredients"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;ingredient.id&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;ingredient.name&#125;"</span>&gt;</span>INGREDIENT<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="form表单提交"><a href="#form表单提交" class="headerlink" title="form表单提交"></a>form表单提交</h3><ol>
<li><p>页面</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/orders&#125;"</span> <span class="attr">th:object</span>=<span class="string">"$&#123;order&#125;"</span>&gt;</span></span><br><span class="line">	Name：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;name&#125;"</span>/&gt;</span></span><br><span class="line">	Street address：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">th:field</span>=<span class="string">"*&#123;street&#125;"</span>/&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务端代码</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// controller类</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/orders"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@PostMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"Order submitted: "</span> + order);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// domain类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String street;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="form表单验证"><a href="#form表单验证" class="headerlink" title="form表单验证"></a>form表单验证</h3><h4 id="定义验证规则"><a href="#定义验证规则" class="headerlink" title="定义验证规则"></a>定义验证规则</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">	<span class="meta">@NotBlank</span>(message=<span class="string">"名字是必需的"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="meta">@CreditCardNumber</span>(message=<span class="string">"不是有效的信用卡号码"</span>)</span><br><span class="line">	<span class="keyword">private</span> String ccNumber;</span><br><span class="line">	<span class="meta">@Pattern</span>(regexp=<span class="string">"^(0[1-9]|1[0-2])([\\/])([1-9][0-9])$"</span>,	message=<span class="string">"必须是格式 MM/YY"</span>)</span><br><span class="line">	<span class="keyword">private</span> String ccExpiration;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在表单绑定时执行验证-Valid"><a href="#在表单绑定时执行验证-Valid" class="headerlink" title="在表单绑定时执行验证(@Valid)"></a>在表单绑定时执行验证(@Valid)</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processOrder</span><span class="params">(@Valid Order order, Errors errors)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"orderForm"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	log.info(<span class="string">"Order submitted: "</span> + order);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显示验证错误信息"><a href="#显示验证错误信息" class="headerlink" title="显示验证错误信息"></a>显示验证错误信息</h4><p><img src="/images/spring-ch1-010.png" alt="Alt text"></p>
<h3 id="使用视图控制器"><a href="#使用视图控制器" class="headerlink" title="使用视图控制器"></a>使用视图控制器</h3><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">		registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="选择视图模板库"><a href="#选择视图模板库" class="headerlink" title="选择视图模板库"></a>选择视图模板库</h3><p><img src="/images/spring-ch1-011.png" alt="Alt text"></p>
<h2 id="使用data"><a href="#使用data" class="headerlink" title="使用data"></a>使用data</h2><h3 id="使用JDBC读写数据"><a href="#使用JDBC读写数据" class="headerlink" title="使用JDBC读写数据"></a>使用JDBC读写数据</h3><ol>
<li><p>添加依赖</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义JDBC存储库</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">	<span class="function">Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Ingredient <span class="title">findOne</span><span class="params">(String id)</span></span>;</span><br><span class="line">	<span class="function">Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcIngredientRepository</span> <span class="keyword">implements</span> <span class="title">IngredientRepository</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JdbcIngredientRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用JdbcTemplate查询数据库</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterable&lt;Ingredient&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jdbc.query(<span class="string">"select id, name, type from Ingredient"</span>, <span class="keyword">this</span>::mapRowToIngredient);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Ingredient <span class="title">mapRowToIngredient</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">			rs.getString(<span class="string">"id"</span>),</span><br><span class="line">			rs.getString(<span class="string">"name"</span>),</span><br><span class="line">			Ingredient.Type.valueOf(rs.getString(<span class="string">"type"</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查询单条记录</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Ingredient <span class="title">findOne</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jdbc.queryForObject(</span><br><span class="line">			<span class="string">"select id, name, type from Ingredient where id=?"</span>,</span><br><span class="line">			<span class="keyword">new</span> RowMapper&lt;Ingredient&gt;() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> Ingredient <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span></span></span><br><span class="line"><span class="function">					<span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> Ingredient(</span><br><span class="line">						rs.getString(<span class="string">"id"</span>),</span><br><span class="line">						rs.getString(<span class="string">"name"</span>),</span><br><span class="line">						Ingredient.Type.valueOf(rs.getString(<span class="string">"type"</span>)));</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;, id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 保存</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Ingredient <span class="title">save</span><span class="params">(Ingredient ingredient)</span> </span>&#123;</span><br><span class="line">		jdbc.update(</span><br><span class="line">			<span class="string">"insert into Ingredient (id, name, type) values (?, ?, ?)"</span>,</span><br><span class="line">			ingredient.getId(),</span><br><span class="line">			ingredient.getName(),</span><br><span class="line">			ingredient.getType().toString());</span><br><span class="line">		<span class="keyword">return</span> ingredient;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义controller类</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/design"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignTacoController</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> IngredientRepository ingredientRepo;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DesignTacoController</span><span class="params">(IngredientRepository ingredientRepo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ingredientRepo = ingredientRepo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">showDesignForm</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">		List&lt;Ingredient&gt; ingredients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		ingredientRepo.findAll().forEach(i -&gt; ingredients.add(i));</span><br><span class="line">		Type[] types = Ingredient.Type.values();</span><br><span class="line">		<span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">			model.addAttribute(type.toString().toLowerCase(),</span><br><span class="line">				filterByType(ingredients, type));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"design"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="使用Spring-data-JPA持久化数据"><a href="#使用Spring-data-JPA持久化数据" class="headerlink" title="使用Spring data JPA持久化数据"></a>使用Spring data JPA持久化数据</h3><ol>
<li><p>添加依赖</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义实体bean</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="meta">@NotNull</span></span><br><span class="line">	<span class="meta">@Size</span>(min=<span class="number">5</span>, message=<span class="string">"Name must be at least 5 characters long"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Date createdAt;</span><br><span class="line">	<span class="meta">@ManyToMany</span>(targetEntity=Ingredient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">Size</span>(<span class="title">min</span></span>=<span class="number">1</span>, message=<span class="string">"You must choose at least 1 ingredient"</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;Ingredient&gt; ingredients;</span><br><span class="line">	<span class="meta">@PrePersist</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">createdAt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.createdAt = <span class="keyword">new</span> Date();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义JPA存储库</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义JPA存储库<br>一些关键语法：</p>
</li>
</ol>
<ul>
<li>IsAfter, After, IsGreaterThan, GreaterThan</li>
<li>IsNull, Null</li>
<li>IsIn, In</li>
<li>IsBetween, Between<br>…<br>OrderRepository：<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：根据deliveryZip字段查询</span></span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">findByDeliveryZip</span><span class="params">(String deliveryZip)</span></span>;</span><br><span class="line"><span class="comment">// 方式二：自定义sql</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"Order o where o.deliveryCity='Seattle'"</span>)</span><br><span class="line"><span class="function">List&lt;Order&gt; <span class="title">readOrdersDeliveredInSeattle</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="使用Security"><a href="#使用Security" class="headerlink" title="使用Security"></a>使用Security</h2><h3 id="集成spring-security"><a href="#集成spring-security" class="headerlink" title="集成spring security"></a>集成spring security</h3><p>添加依赖</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置Spring-Security"><a href="#配置Spring-Security" class="headerlink" title="配置Spring Security"></a>配置Spring Security</h3><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于内存的用户存储"><a href="#基于内存的用户存储" class="headerlink" title="基于内存的用户存储"></a>基于内存的用户存储</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	auth</span><br><span class="line">		.inMemoryAuthentication()</span><br><span class="line">		.withUser(<span class="string">"buzz"</span>)</span><br><span class="line">		.password(<span class="string">"infinity"</span>)</span><br><span class="line">		.authorities(<span class="string">"ROLE_USER"</span>)</span><br><span class="line">		.and()</span><br><span class="line">		.withUser(<span class="string">"woody"</span>)</span><br><span class="line">		.password(<span class="string">"bullseye"</span>)</span><br><span class="line">		.authorities(<span class="string">"ROLE_USER"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于jdbc的用户存储"><a href="#基于jdbc的用户存储" class="headerlink" title="基于jdbc的用户存储"></a>基于jdbc的用户存储</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	auth</span><br><span class="line">		.jdbcAuthentication()</span><br><span class="line">		.dataSource(dataSource)</span><br><span class="line">		.usersByUsernameQuery(</span><br><span class="line">			<span class="string">"select username, password, enabled from Users "</span> +</span><br><span class="line">				<span class="string">"where username=?"</span>)</span><br><span class="line">		.authoritiesByUsernameQuery(</span><br><span class="line">			<span class="string">"select username, authority from UserAuthorities "</span> +</span><br><span class="line">				<span class="string">"where username=?"</span>)</span><br><span class="line">		.passwordEncoder(<span class="keyword">new</span> StandardPasswordEncoder(<span class="string">"53cr3t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>passwordEncoder()有几种加密方式：</p>
<ul>
<li>BCryptPasswordEncoder</li>
<li>NoOpPasswordEncoder</li>
<li>Pbkdf2PasswordEncoder</li>
<li>SCryptPasswordEncoder</li>
<li>StandardPasswordEncoder</li>
</ul>
<h4 id="LDAP-backed用户存储"><a href="#LDAP-backed用户存储" class="headerlink" title="LDAP-backed用户存储"></a>LDAP-backed用户存储</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	auth.ldapAuthentication()</span><br><span class="line">		.userSearchBase(<span class="string">"ou=people"</span>)</span><br><span class="line">		.userSearchFilter(<span class="string">"(uid=&#123;0&#125;)"</span>)</span><br><span class="line">		.groupSearchBase(<span class="string">"ou=groups"</span>)</span><br><span class="line">		.groupSearchFilter(<span class="string">"member=&#123;0&#125;"</span>)</span><br><span class="line">		.passwordCompare()</span><br><span class="line">		.passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder())</span><br><span class="line">		.passwordAttribute(<span class="string">"passcode"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定制用户身份验证"><a href="#定制用户身份验证" class="headerlink" title="定制用户身份验证"></a>定制用户身份验证</h4><ol>
<li><p>定义用户域和持久性</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>(access=AccessLevel.PRIVATE, force=<span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span>(strategy=GenerationType.AUTO)</span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String fullname;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户详细信息服务</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserRepositoryUserDetailsService</span><span class="params">(UserRepository userRepo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">		User user = userRepo.findByUsername(username);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> user;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(</span><br><span class="line">			<span class="string">"User '"</span> + username + <span class="string">"' not found"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置类configure()方法</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	auth</span><br><span class="line">		.userDetailsService(userDetailsService)</span><br><span class="line">		.passwordEncoder(encoder()); <span class="comment">// 密码加密</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">encoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> StandardPasswordEncoder(<span class="string">"53cr3t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册用户</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistrationController</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line">	<span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RegistrationController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		UserRepository userRepo, PasswordEncoder passwordEncoder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">		<span class="keyword">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">registerForm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"registration"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@PostMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">processRegistration</span><span class="params">(RegistrationForm form)</span> </span>&#123;</span><br><span class="line">		userRepo.save(form.toUser(passwordEncoder));</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"redirect:/login"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="request请求安全验证"><a href="#request请求安全验证" class="headerlink" title="request请求安全验证"></a>request请求安全验证</h3><h4 id="配置request请求规则"><a href="#配置request请求规则" class="headerlink" title="配置request请求规则"></a>配置request请求规则</h4><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http</span><br><span class="line">		.authorizeRequests()</span><br><span class="line">		.antMatchers(<span class="string">"/design"</span>, <span class="string">"/orders"</span>)</span><br><span class="line">		.hasRole(<span class="string">"ROLE_USER"</span>)</span><br><span class="line">		.antMatchers(“/”, <span class="string">"/**"</span>).permitAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/spring-ch1-012.png" alt="Alt text"></p>
<h4 id="创建自定义登录页面"><a href="#创建自定义登录页面" class="headerlink" title="创建自定义登录页面"></a>创建自定义登录页面</h4><ol>
<li><p>配置configure()</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	http</span><br><span class="line">		.authorizeRequests()</span><br><span class="line">		.antMatchers(<span class="string">"/design"</span>, <span class="string">"/orders"</span>)</span><br><span class="line">		.access(<span class="string">"hasRole('ROLE_USER')"</span>)</span><br><span class="line">		.antMatchers(“/”, <span class="string">"/**"</span>).access(<span class="string">"permitAll"</span>)</span><br><span class="line">		.and()</span><br><span class="line">		.formLogin()</span><br><span class="line">		.loginPage(<span class="string">"/login"</span>)</span><br><span class="line">		.loginProcessingUrl(<span class="string">"/authenticate"</span>)</span><br><span class="line">		.usernameParameter(<span class="string">"username"</span>) <span class="comment">// 表单字段：user</span></span><br><span class="line">		.passwordParameter(<span class="string">"password"</span>); <span class="comment">// 表单字段：pwd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在WebConfig中声明它为一个视图控制器</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">	registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">	registry.addViewController(<span class="string">"/login"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录页面</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/login&#125;"</span> <span class="attr">id</span>=<span class="string">"loginForm"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>Password: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>防止跨站请求伪造<br>（1）配置configure()</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">http.and()</span><br><span class="line">	.csrf()</span><br><span class="line">	.disable()</span><br></pre></td></tr></table></figure>
<p>（2）前端页面加</p>
<figure class="highlight html"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_csrf"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;_csrf.token&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用配置属性"><a href="#使用配置属性" class="headerlink" title="使用配置属性"></a>使用配置属性</h2><h3 id="微调自动配置"><a href="#微调自动配置" class="headerlink" title="微调自动配置"></a>微调自动配置</h3><h4 id="理解Spring的环境抽象"><a href="#理解Spring的环境抽象" class="headerlink" title="理解Spring的环境抽象"></a>理解Spring的环境抽象</h4><p><img src="/images/spring-ch1-013.png" alt="Alt text"></p>
<ol>
<li><p>application.properties</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">9090</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">	port: <span class="number">9090</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">$ java -jar tacocloud-<span class="number">0.0</span><span class="number">.5</span>-SNAPSHOT.jar --server.port=<span class="number">9090</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>application.yml</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	datasource:</span><br><span class="line">		url: jdbc:mysql:<span class="comment">//localhost/tacocloud</span></span><br><span class="line">		username: tacodb</span><br><span class="line">		password: tacopassword</span><br><span class="line">		driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">		# 初始化数据脚本</span><br><span class="line">		schema:</span><br><span class="line">			- order-schema.sql</span><br><span class="line">			- ingredient-schema.sql</span><br><span class="line">			- taco-schema.sql</span><br><span class="line">			- user-schema.sql</span><br><span class="line">		data:</span><br><span class="line">			- ingredients.sql</span><br><span class="line">		# JNDI</span><br><span class="line">		jndi-name: java:/comp/env/jdbc/tacoCloudDS	</span><br></pre></td></tr></table></figure>

<h4 id="配置嵌入式服务器"><a href="#配置嵌入式服务器" class="headerlink" title="配置嵌入式服务器"></a>配置嵌入式服务器</h4><p>JDK的keytool命令行实用工具:</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">$ keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA</span><br></pre></td></tr></table></figure>

<p>启用HTTPS：application.yml</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">	port: <span class="number">8443</span></span><br><span class="line">	ssl:</span><br><span class="line">		key-store: file:<span class="comment">///path/to/mykeys.jks</span></span><br><span class="line">		key-store-password: letmein</span><br><span class="line">		key-password: letmein</span><br></pre></td></tr></table></figure>

<h4 id="配置日志记录"><a href="#配置日志记录" class="headerlink" title="配置日志记录"></a>配置日志记录</h4><figure class="highlight html"><figcaption><span>[xml配置方式]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">			%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n</span><br><span class="line">		<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[application.yml配置方式]</span></figcaption><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">	path: /<span class="keyword">var</span>/logs/</span><br><span class="line">	file: TacoCloud.log</span><br><span class="line">	level:</span><br><span class="line">		root: WARN</span><br><span class="line">		org.springframework.security: DEBUG</span><br></pre></td></tr></table></figure>

<h4 id="使用特殊的属性值"><a href="#使用特殊的属性值" class="headerlink" title="使用特殊的属性值"></a>使用特殊的属性值</h4><p>在设置属性时，您不仅可以将它们的值声明为硬编码的字符串和数值。相反，可以从其他配置属性派生它们的值。<br>welcome: You are using ${spring.application.name}.</p>
<h3 id="创建自己的配置属性"><a href="#创建自己的配置属性" class="headerlink" title="创建自己的配置属性"></a>创建自己的配置属性</h3><ol>
<li><p>定义一个属性类</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"taco.orders"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProps</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageSize = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用，以controller为例</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/orders"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(<span class="string">"order"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> OrderRepository orderRepo;</span><br><span class="line">	<span class="keyword">private</span> OrderProps props; <span class="comment">// 属性类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(OrderRepository orderRepo,</span></span></span><br><span class="line"><span class="function"><span class="params">						   OrderProps props)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.orderRepo = orderRepo;</span><br><span class="line">		<span class="keyword">this</span>.props = props;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@GetMapping</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">ordersForUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		@AuthenticationPrincipal User user, Model model)</span> </span>&#123;</span><br><span class="line">		Pageable pageable = PageRequest.of(<span class="number">0</span>, props.getPageSize());</span><br><span class="line">		model.addAttribute(<span class="string">"orders"</span>,</span><br><span class="line">			orderRepo.findByUserOrderByPlacedAtDesc(user, pageable));</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"orderList"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="配置profiles"><a href="#配置profiles" class="headerlink" title="配置profiles"></a>配置profiles</h3><p>激活profile=prod环境的配置文件。</p>
<figure class="highlight java"><figcaption><span>[application.yml]</span></figcaption><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">	profiles:</span><br><span class="line">	active:</span><br><span class="line">		- prod</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">	datasource:</span><br><span class="line">		url: jdbc:mysql:<span class="comment">//localhost/tacocloud</span></span><br><span class="line">		username: tacouser</span><br><span class="line">		password: tacopassword</span><br><span class="line">	logging:</span><br><span class="line">		level:</span><br><span class="line">			tacos: WARN</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">	profiles: prod</span><br><span class="line">	datasource:</span><br><span class="line">		url: jdbc:mysql:<span class="comment">//localhost/tacocloud</span></span><br><span class="line">		username: tacouser</span><br><span class="line">		password: tacopassword</span><br><span class="line">	logging:</span><br><span class="line">		level:</span><br><span class="line">			tacos: WARN		</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章-类加载及执行子系统的案例与实战</title>
    <url>/2019/11/04/%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>本章介绍了4个例子，类加载器（2个）和字节码（2个）。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="Tomcat：正统的类加载器架构"><a href="#Tomcat：正统的类加载器架构" class="headerlink" title="Tomcat：正统的类加载器架构"></a>Tomcat：正统的类加载器架构</h3><p>一个服务器有多个自定义的加载器（如：tomcat、jetty等）。<br>功能健全的Web服务器要解决的问题：</p>
<ol>
<li>同服务器的两个Web应用程序所使用的Java类库可以实现相互隔离</li>
<li>同服务器的两个Web应用程序所使用的Java类库可以互相共享。</li>
<li>服务器需要尽可能的保证自身的安全不受部署的Web应用程序影响。</li>
<li>支持JSP应用的Web服务器，大多数都需要支持HotSwap功能。<br><img src="/images/jvm20190109.png" alt="Alt text"><br><img src="/images/jvm20190110.png" alt="Alt text"></li>
</ol>
<h3 id="OSGi：灵活的类加载架构（网状结构）"><a href="#OSGi：灵活的类加载架构（网状结构）" class="headerlink" title="OSGi：灵活的类加载架构（网状结构）"></a>OSGi：灵活的类加载架构（网状结构）</h3><p>Java社区流传观点：学习J2EE规范，去看Jboss源码；学习类加载器，就去看OSGi源码。<br>最小模块：Bundle<br>特征：</p>
<ol>
<li>依赖关系：从传统的上层模块依赖底层模块转变为平级之间的依赖。</li>
<li>可见性：只有被Export和Package才可能被外界访问。</li>
<li>扩展性：可以实现模块级的热插拔功能。</li>
<li>无关系性：Bundle类加载器之间只有规则，没有固定的委派关系。</li>
<li>精确访问：一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。<br><img src="/images/jvm20190111.png" alt="Alt text"></li>
</ol>
<p>缺点：</p>
<ul>
<li>额外的复杂度</li>
<li>带来了死锁和内存泄露的风险</li>
</ul>
<h3 id="字段码生成技术与动态代理的实现"><a href="#字段码生成技术与动态代理的实现" class="headerlink" title="字段码生成技术与动态代理的实现"></a>字段码生成技术与动态代理的实现</h3><p>应用场景：</p>
<ul>
<li>Web服务器的JSP编译器</li>
<li>编译时植入的AOP框架</li>
<li>常用的动态代理技术</li>
<li>使用反射的时候虚拟机都有可能会在运行时生成字符码</li>
</ul>
<p>过程：<img src="/images/jvm20190112.png" alt="Alt text"></p>
<h3 id="Retrotranslator"><a href="#Retrotranslator" class="headerlink" title="Retrotranslator"></a>Retrotranslator</h3><p>跨越JDK版本（Java逆向移植）。<br>用途：<br><img src="/images/jvm20190113.png" alt="Alt text"></p>
<p>实现原理（略）.<br>JDK升级4类改动：</p>
<ul>
<li>在编译层面做的改进</li>
<li>对Java API的代码增强</li>
<li>需要在字节码中进行支持的改动</li>
<li>虚拟机内部的改进</li>
</ul>
<h2 id="实战：自己动手实现远程执行功能"><a href="#实战：自己动手实现远程执行功能" class="headerlink" title="实战：自己动手实现远程执行功能"></a>实战：自己动手实现远程执行功能</h2><p>JDK1.6之前：写一个JSP文件上传到服务器，然后通过服务器运行它，或者在服务端程序中加入BeanShell Script等的执行引擎去执行动态脚本。<br>JDK1.6之后：Compliler API。</p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在服务端执行临时代码。<br><img src="/images/jvm20190114.png" alt="Alt text"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>如何编译提交到服务器的Java代码？</li>
</ol>
<ul>
<li>使用tools.jar包（引入了额外的JAR包，JDK移植要把tools.jar带上）</li>
<li>直接在客户端编译好，把字节码而不是Java代码传到服务端</li>
</ul>
<ol start="2">
<li>如何执行编译之后的Java代码？</li>
</ol>
<ul>
<li>让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法就可以了。（能卸载和回收）</li>
</ul>
<ol start="3">
<li>如何收集Java代码的执行结果？</li>
</ol>
<ul>
<li>标准输出System.out（会存在问题）</li>
<li>解决：直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>实现同一类被多次加载（指定HotSwapClassLoader作为父类加载器）<br><img src="/images/jvm20190115.png" alt="Alt text"></li>
<li>实现将java.lang.System替换为我们自己定义的HackSystem类的过程<br><img src="/images/jvm20190116.png" alt="Alt text"><br><img src="/images/jvm20190117.png" alt="Alt text"></li>
</ol>
<p>验证（略）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章-虚拟机字节码执行引擎</title>
    <url>/2019/11/04/%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>本章中，分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。</p>
<p>执行引擎是Java虚拟机最核心的组成部分之一。两种执行方式：解释执行和编译执行。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<br>组成部分：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接</li>
<li>方法返回地址</li>
<li>一些额外的附加信息</li>
</ul>
<p>当前栈帧：位于栈顶的栈帧<br>当前方法：与这个当前栈帧相关联的方法<br>概念结构图：<br><img src="/images/jvm20190087.png" alt="Alt text"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>是一组变量存储空间，用于存放方法参数和方法内部定义的局部变量。<br>最小单位：变量槽（Slot）</p>
<ol>
<li>GC不会回收<br><img src="/images/jvm20190088.png" alt="Alt text"></li>
<li>GC能回收<br><img src="/images/jvm20190089.png" alt="Alt text"></li>
</ol>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>称为操作栈，它是一个后入先出栈。<br>元素：任意的Java数据类型。<br>容量：</p>
<ul>
<li>32位数据类型占容量1</li>
<li>64位数据类型占容量2<br><img src="/images/jvm20190090.png" alt="Alt text"></li>
</ul>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。符号引用分为两部分，一部分是静态解析，另一部分是动态连接。<br>静态解析：符号引用一部分在类加载阶段或者第一次使用的时候就转化为直接引用。<br>动态连接：符号引用另一部分将在每一次运行期间转化为直接引用。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>在方法退出之后，都需要返回到方法的指定位置，程序才能继续执行，方法返回可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。<br>返回方式：</p>
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令</li>
<li>在方法执行过程中遇到异常</li>
</ul>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）。所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。<br>方法分类：</p>
<ul>
<li>静态方法：与类型直接关联</li>
<li>私有方法：在外部不可被访问</li>
</ul>
<p>5条方法调用字节码指令：<br><img src="/images/jvm20190091.png" alt="Alt text"><br>示例：<br><img src="/images/jvm20190092.png" alt="Alt text"></p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>Java三大特征：继承、封闭和多态。分派调用过程将会提示多态性特征的一些最基本的体现。</p>
<h4 id="静态分派：（重载）"><a href="#静态分派：（重载）" class="headerlink" title="静态分派：（重载）"></a>静态分派：（重载）</h4><p>静态类型（外观类型）：Human<br>实际类型：man = new Man()…<br>加载原则：</p>
<ol>
<li>虚拟机在重载时是通过参数的静态类型而不是实际类型作为判断依据的<br><img src="/images/jvm20190093.png" alt="Alt text"></li>
<li>重载方法匹配优先级（char-&gt;int-&gt;long-&gt;float-&gt;double）<br><img src="/images/jvm20190094.png" alt="Alt text"><br><img src="/images/jvm20190095.png" alt="Alt text"></li>
</ol>
<h4 id="动态分派（重写）"><a href="#动态分派（重写）" class="headerlink" title="动态分派（重写）"></a>动态分派（重写）</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。<br>invokervirtual指令的运行时解析过程：<br><img src="/images/jvm20190096.png" alt="Alt text"><br><img src="/images/jvm20190097.png" alt="Alt text"></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>方法的宗量：方法的接收者与方法的参数统称为方法的宗量。<br>分类：</p>
<ul>
<li>Java语言的静态分派属于多分派类型</li>
<li>Java语言的动态分派属性单分派类型<br><img src="/images/jvm20190098.png" alt="Alt text"></li>
</ul>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>虚拟机基于性能考虑，大部分使用”稳定优化“手段——建立一个虚方法表。<br>虚方法表：<br><img src="/images/jvm20190099.png" alt="Alt text"></p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>关键特征是它的类型检查的主体过程是在运行期而不是在编译期。<br><img src="/images/jvm20190100.png" alt="Alt text"></p>
<ol>
<li>JDK1.7与动态类型<br>新增了invokedynamic指令.</li>
<li>java.lang.invoke包（类似C指针）<br>作用：提供一种新的目标方法机制——MethodHandler</li>
<li>invokedynamic指令<br>与MethodHandler作用一样.</li>
<li>掌控方法分派规则<br><img src="/images/jvm20190101.png" alt="Alt text"></li>
</ol>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>探讨虚拟机是如何执行方法中的字节码指令的。</p>
<h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p><img src="/images/jvm20190102.png" alt="Alt text"></p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>两者区别：基于栈的指令集可移植。<br>缺点：基于栈的指令集执行速度相对来说慢。</p>
<h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><h4 id="一段简单的算术代码"><a href="#一段简单的算术代码" class="headerlink" title="一段简单的算术代码"></a>一段简单的算术代码</h4><p><img src="/images/jvm20190103.png" alt="Alt text"></p>
<h4 id="代码对应的字节码表示"><a href="#代码对应的字节码表示" class="headerlink" title="代码对应的字节码表示"></a>代码对应的字节码表示</h4><p><img src="/images/jvm20190104.png" alt="Alt text"></p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p><img src="/images/jvm20190105.png" alt="Alt text"><br><img src="/images/jvm20190106.png" alt="Alt text"><br><img src="/images/jvm20190107.png" alt="Alt text"><br><img src="/images/jvm20190108.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章-虚拟机类加载机制</title>
    <url>/2019/11/04/%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本章介绍了类加载过程的”加载“、”准备“、”验证“、”解析“和”初始化“5个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止。<br>生命周期：<em>加载</em>、<em>验证</em>、<em>准备</em>、解析、<em>初始化</em>、使用和<em>卸载</em>7个阶段（粗体5个顺序是确定的）。<br><img src="/images/jvm20190075.png" alt="Alt text"><br>主动引用：</p>
<ul>
<li>遇到new、getstatic、putstaic或invokestatic这4条指令</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没进行初始化，则需先触发其初始化。</li>
<li>当初始化一个类时，如果发现其父类还没有进行初始化，则需先解决父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的类（包含main()方法的那个类），虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</li>
</ul>
<p>被动引用：</p>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化</li>
<li>通过数组定义来引用类，不会触发类的初始化</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载的第一个阶段。<br>过程：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据访问入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>过程：</p>
<ol>
<li>文件格式验证（检查Class文件格式规范）</li>
<li>元数据验证（检查语义合法性、逻辑性）</li>
<li>字节码验证（最复杂的阶段）</li>
<li>符号引用验证（确保解析动作能正常执行）</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>是正式为类变量分配内存并设置类变量初始化值的阶段。<br>重点：</p>
<ol>
<li>这时进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量</li>
<li>默认变量初始化值（常量从常量池取对应的常量值）</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ol>
<li>符号引用：符号引用以一组符号来描述所有引用的目标，符号可以是任何形式的字面量。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
<li>解析对象（7类符号引用）：</li>
</ol>
<ul>
<li>类或接口</li>
<li>字段</li>
<li>类方法</li>
<li>接口方法</li>
<li>方法类型</li>
<li>方法句柄</li>
<li>调用点限定符。</li>
</ul>
<ol start="4">
<li>类或接口的解析（3个步骤）</li>
</ol>
<ul>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Inter”的形式，按上面的规则加载数组元素类型</li>
<li>如果上面解析没问题，在解析完成前不要进行符号引用验证，确认D是否具备对C的访问权限。</li>
</ul>
<ol start="5">
<li><p>字段解析<br><img src="/images/jvm20190076.png" alt="Alt text"><br><img src="/images/jvm20190077.png" alt="Alt text"></p>
</li>
<li><p>类方法解析<br><img src="/images/jvm20190078.png" alt="Alt text"></p>
</li>
<li><p>接口方法解析<br><img src="/images/jvm20190079.png" alt="Alt text"></p>
</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>真正开始执行类中定义的Java程序代码，执行类构造器<code>&lt;cinit&gt;()</code>方法的过程。<br>过程：<br><img src="/images/jvm20190080.png" alt="Alt text">    </p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>“通过一个类的全限定名来获取描述此类的二进制流”这个动作放到Java虚拟机外部去实现，实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>用于实现类的加载动作。<br>例：两个类是否相等（前提是被同一个类加载器加载的）<br><img src="/images/jvm20190081.png" alt="Alt text">    </p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>类加载器粗分2类：</p>
<ul>
<li>启动类加载器（BootstrapClassLoader）</li>
<li>所有其他类的加载器（java.class）</li>
</ul>
<p>细分3类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）</li>
<li>扩展类加载器（Extension ClassLoader）</li>
<li>启动程序类加载器（ApplicationClassLoader）<br><img src="/images/jvm20190082.png" alt="Alt text"></li>
</ul>
<p>过程：<br><img src="/images/jvm20190083.png" alt="Alt text"><br>优点：Java类随着它的类加载器一起具备了一种带有优先级的层次关系<br>代码实现：<br><img src="/images/jvm20190084.png" alt="Alt text"></p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>loadClass()失败-&gt;findClass()–JDK1.2后添加一个新的方法，为了兼容1.2之间的代码。</p>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>产生原因：基础类调回用户的代码（如：JNDI服务），Java中所有涉及SPI的加载动作基本上都采用这种方式<br><img src="/images/jvm20190085.png" alt="Alt text"></p>
<h4 id="OSGI环境"><a href="#OSGI环境" class="headerlink" title="OSGI环境"></a>OSGI环境</h4><p><img src="/images/jvm20190086.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制转换</title>
    <url>/2019/11/02/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="关于二进制说明"><a href="#关于二进制说明" class="headerlink" title="关于二进制说明"></a>关于二进制说明</h2><p>对于整数，有四种表达方式：</p>
<ul>
<li>二进制：0,1，满2进1. 以0b或0B开头</li>
<li>十进制：0-9，满10进1. </li>
<li>八进制：0-7，满8进1. 以数字0开头表示。</li>
<li>十六进制：0-9及A-F，满16进1. 以0x或者0X开头表示。（A-F不区分大小写）</li>
</ul>
<p><img src="/images/tools20191102001.png" alt="Alt text"><br><img src="/images/tools20191102002.png" alt="Alt text"></p>
<h2 id="二进制转十进制（底层存储的是补码）"><a href="#二进制转十进制（底层存储的是补码）" class="headerlink" title="二进制转十进制（底层存储的是补码）"></a>二进制转十进制（底层存储的是补码）</h2><p><img src="/images/tools20191102003.png" alt="Alt text"><br>负数的补码:<br><img src="/images/tools20191102004.png" alt="Alt text"></p>
<h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p><img src="/images/tools20191102005.png" alt="Alt text"></p>
<h2 id="二进制转十进制、十六进制"><a href="#二进制转十进制、十六进制" class="headerlink" title="二进制转十进制、十六进制"></a>二进制转十进制、十六进制</h2><p><img src="/images/tools20191102006.png" alt="Alt text"><br><img src="/images/tools20191102007.png" alt="Alt text"></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><p>右移运算符、左移运算符号，以右移为例（带符号与不带符号）.<br><img src="/images/tools20191102008.png" alt="Alt text"></p>
<h2 id="位与运算、位或运算"><a href="#位与运算、位或运算" class="headerlink" title="位与运算、位或运算"></a>位与运算、位或运算</h2><p><img src="/images/tools20191102009.png" alt="Alt text"></p>
<h2 id="异或运算、取反"><a href="#异或运算、取反" class="headerlink" title="异或运算、取反"></a>异或运算、取反</h2><p><img src="/images/tools20191102010.png" alt="Alt text"><br><img src="/images/tools20191102011.png" alt="Alt text"></p>
<p>案例：<br><img src="/images/tools20191102012.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章-类文件结构</title>
    <url>/2019/11/02/%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>本章详细讲解了Class文件中的各个组成部分，以及每个部分的定义、数据结构和使用方法。以实战的方式演示了Class的数据是如何电存储和访问的。</p>
<h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><ul>
<li>一次编译，到处运行（跨平台）</li>
<li>虚拟机和字节码存储格式</li>
<li>不关心Class的来源何种语言。</li>
</ul>
<p><img src="/images/jvm20190053.png" alt="Alt text"></p>
<h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里。Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有任何分隔符。</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>魔数（0xCAFEBABE）：每个Class文件的头4个字节。<br>作用（基于安全考虑）：确定这个文件是否为一个能被虚拟机接受的Class文件。<br><img src="/images/jvm20190054.png" alt="Alt text"></p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>可以理解为Class文件中的资源仓库。<br>位置：主次版本号之后。<br>存放内容：</p>
<ul>
<li>字面量：接近Java语言层面的常量概念，如：文本字符串、声明为final的常量值等</li>
<li>符号引用（编译原理方面的概念）：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符<br><img src="/images/jvm20190055.png" alt="Alt text"><br><img src="/images/jvm20190056.png" alt="Alt text"></li>
</ul>
</li>
</ul>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>位置：在常量池结束之后。<br><img src="/images/jvm20190057.png" alt="Alt text"><br><img src="/images/jvm20190058.png" alt="Alt text"></p>
<h3 id="类索引、父类索引与接口索引"><a href="#类索引、父类索引与接口索引" class="headerlink" title="类索引、父类索引与接口索引"></a>类索引、父类索引与接口索引</h3><p>用于描述接口或者类中声明的变量，严格顺序、长度和内容。<br>作用：通过这三项数据来确定这个类的继承关系。<br><img src="/images/jvm20190059.png" alt="Alt text"></p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>用于描述接口或者类中声明的变量，严格顺序、长度和内容。<br>包含内容：作用域、可变性、并发可见性、字段类型等。<br><img src="/images/jvm20190060.png" alt="Alt text"></p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>与字段表集合一样。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p><img src="/images/jvm20190061.png" alt="Alt text"></p>
<h4 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h4><p><img src="/images/jvm20190062.png" alt="Alt text"></p>
<h4 id="Exception属性"><a href="#Exception属性" class="headerlink" title="Exception属性"></a>Exception属性</h4><p>列举出方法中可能抛出的受检查异常。<br><img src="/images/jvm20190063.png" alt="Alt text"></p>
<h4 id="LineNumberTable属性（非必需属性）"><a href="#LineNumberTable属性（非必需属性）" class="headerlink" title="LineNumberTable属性（非必需属性）"></a>LineNumberTable属性（非必需属性）</h4><p>用于描述Java源码行号和字节行号之间的对应关系。<br><img src="/images/jvm20190064.png" alt="Alt text"></p>
<h4 id="LocalVariableTable属性（非必需属性）"><a href="#LocalVariableTable属性（非必需属性）" class="headerlink" title="LocalVariableTable属性（非必需属性）"></a>LocalVariableTable属性（非必需属性）</h4><p>描述栈中局部变量表中的变量与Java源码中定义的变量之间的关系。<br><img src="/images/jvm20190065.png" alt="Alt text"></p>
<h3 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h3><p>记录生成这个Class文件的源码文件名称。<br><img src="/images/jvm20190066.png" alt="Alt text"></p>
<h3 id="ConstantValue属性（static修饰的变量）"><a href="#ConstantValue属性（static修饰的变量）" class="headerlink" title="ConstantValue属性（static修饰的变量）"></a>ConstantValue属性（static修饰的变量）</h3><p>作用：通知虚拟机自动为静态变量赋值。<br><img src="/images/jvm20190067.png" alt="Alt text"></p>
<h3 id="InnerClass属性"><a href="#InnerClass属性" class="headerlink" title="InnerClass属性"></a>InnerClass属性</h3><p>记录内部类与宿主类之间的关联。<br><img src="/images/jvm20190068.png" alt="Alt text"></p>
<h3 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h3><p>标志类型的布尔属性，只存在有和没有的区别。<br><img src="/images/jvm20190069.png" alt="Alt text"></p>
<h3 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h3><p>代替原本基于类型推断的字节码验证器，提升字节码验证的性能。<br><img src="/images/jvm20190070.png" alt="Alt text"></p>
<h3 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h3><p>记录泛型签名信息。<br><img src="/images/jvm20190071.png" alt="Alt text"></p>
<h3 id="BootstrapMethods属性（略）"><a href="#BootstrapMethods属性（略）" class="headerlink" title="BootstrapMethods属性（略）"></a>BootstrapMethods属性（略）</h3><p><img src="/images/jvm20190072.png" alt="Alt text"></p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><p><img src="/images/jvm20190073.png" alt="Alt text"></p>
<ol>
<li>字节码与数据类型</li>
</ol>
<ul>
<li>使用：简化操作记忆，如：i-&gt;int等</li>
</ul>
<ol start="2">
<li>加载和存储指令</li>
</ol>
<ul>
<li>使用场景：用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</li>
</ul>
<ol start="3">
<li>运算指令</li>
</ol>
<ul>
<li>作用：对两个操作数栈上的值进行特定运算。</li>
<li>分类：<ul>
<li>对整型数据进行运算</li>
<li>对浮点型数据进行运算</li>
</ul>
</li>
</ul>
<ol start="4">
<li>类型转换指令</li>
</ol>
<ul>
<li>作用：将两种不同的数值类型进行相互转换</li>
</ul>
<ol start="5">
<li>对象创建与访问指令</li>
</ol>
<ul>
<li>使用场景：虚拟机对实例和数组的创建与操作使用了不同的字节码命令。</li>
</ul>
<ol start="6">
<li>操作数栈管理指令</li>
</ol>
<ul>
<li>常用直接操作数栈的指令：pop1、pop2等</li>
</ul>
<ol start="7">
<li>控制转移指令</li>
</ol>
<ul>
<li>作用：从指定位置指令继续执行程序</li>
</ul>
<ol start="8">
<li>方法调用和返回指令（略）</li>
<li>异常处理指令</li>
</ol>
<ul>
<li>虚拟机异常由athrow指令来实现</li>
</ul>
<ol start="10">
<li>同步指令</li>
</ol>
<ul>
<li>作用：支持同步和方法内部一段指令序列的同步</li>
</ul>
<h2 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h2><p><img src="/images/jvm20190074.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章-调优安全分析与实战</title>
    <url>/2019/11/02/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>本章介绍了几个虚拟机真实案例并以这些案例来分析问题、解决问题的过程和eclipse优化配置。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p><img src="/images/jvm20190039.png" alt="Alt text"><br>解决方案：</p>
<ul>
<li>建立5个32位JDK的逻辑集群</li>
<li>第个进程按2GB内存计算（其中堆固定为1.5G），占用了10G内存</li>
<li>另外建立一个Apache服务作为前端均衡代理访问门户。</li>
<li>响应速度：以为CMS收集器进行垃圾回收。</li>
</ul>
<h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><p><img src="/images/jvm20190040.png" alt="Alt text"><br>解决方案（无解）：</p>
<ul>
<li>让服务器带着参数：+HeapDumpOnOutOfMemoryError运行</li>
</ul>
<h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><p><img src="/images/jvm20190041.png" alt="Alt text"><br><img src="/images/jvm20190042.png" alt="Alt text"><br>解决方案：</p>
<ul>
<li>Direct Memory：-XX:MaxDirectMemorySize调用直接内存大小</li>
<li>线程堆栈：-Xss调整大小</li>
<li>Socket缓存区</li>
<li>JNI代码</li>
<li>虚拟机和GC</li>
</ul>
<h3 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h3><p><img src="/images/jvm20190043.png" alt="Alt text"><br>问题原因：linux产生频繁产生新进程（”fork”系统调用）<br>解决方案：</p>
<ul>
<li>Runtime().getRuntime().exec() 调用shell脚本<ul>
<li>克隆一个和当前虚拟机拥有一样环境变量的进程</li>
<li>再用这个新的进程去执行外部命令</li>
<li>最后退出这个进程。</li>
</ul>
</li>
<li>去掉这个Runtime().getRuntime().exec() Shell脚本执行的语句</li>
<li>改为用Java的API去获取这些信息</li>
</ul>
<h3 id="服务器JVM进程崩溃"><a href="#服务器JVM进程崩溃" class="headerlink" title="服务器JVM进程崩溃"></a>服务器JVM进程崩溃</h3><p><img src="/images/jvm20190044.png" alt="Alt text"><br><img src="/images/jvm20190045.png" alt="Alt text"><br>问题：MIS系统使用了异步调用Web服务通知OA系统，长期以往导致等待线程和Socket连接越来越多，直到崩溃。<br>解决方案：</p>
<ul>
<li>通知OA门户方修复无法使用的集成接口</li>
<li>并将异步调用改为生产者/消费都模式的消息队列实现</li>
</ul>
<h3 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h3><p><img src="/images/jvm20190046.png" alt="Alt text"><br>问题：使用了大对象，导致GC Parnew（复制算法）无法回收。<br>解决方案：</p>
<ul>
<li>不修改程序（治标不治本）：将Survivor去掉，加入-XX: SurvirorRatio=65536、-XX: MaxTenuringThreshold=0或-XX: AlwaysTenure</li>
<li>修改程序：？</li>
</ul>
<h3 id="由Window虚拟内存导致的长时间停顿"><a href="#由Window虚拟内存导致的长时间停顿" class="headerlink" title="由Window虚拟内存导致的长时间停顿"></a>由Window虚拟内存导致的长时间停顿</h3><p><img src="/images/jvm20190047.png" alt="Alt text"><br>解决步骤：</p>
<ol>
<li>加入参数：-XX: +PrintGCApplicationStoppedTime -XX: PringGCDateStamps - Xloggc: gclog.log<br><img src="/images/jvm20190048.png" alt="Alt text"></li>
<li>加入参数：-XX: +PrintReferenceGC参数<br><img src="/images/jvm20190049.png" alt="Alt text"></li>
</ol>
<h2 id="Eclipse运行速度调优"><a href="#Eclipse运行速度调优" class="headerlink" title="Eclipse运行速度调优"></a>Eclipse运行速度调优</h2><h3 id="升级JDK1-6的性能变化及兼容问题"><a href="#升级JDK1-6的性能变化及兼容问题" class="headerlink" title="升级JDK1.6的性能变化及兼容问题"></a>升级JDK1.6的性能变化及兼容问题</h3><p>在eclipse.ini文件配置参数：-XX: MaxPermSize=256M</p>
<h3 id="编译时间和类加载时间的优化"><a href="#编译时间和类加载时间的优化" class="headerlink" title="编译时间和类加载时间的优化"></a>编译时间和类加载时间的优化</h3><p>配置参数：-Xverify: none，禁止掉字节码验证过程。<br><img src="/images/jvm20190050.png" alt="Alt text"></p>
<h3 id="调整内存设置控制垃圾收集频率"><a href="#调整内存设置控制垃圾收集频率" class="headerlink" title="调整内存设置控制垃圾收集频率"></a>调整内存设置控制垃圾收集频率</h3><p>把-Xms和-XX:PermSize设置为-Xmx和-MaxPermSize参数值一样（避免运行自动扩容）。<br>优化方案：</p>
<ul>
<li>把新生代容量提升到128M，避免新生代频繁GC</li>
<li>把Java堆、永久代的容量分别固定为512M、96M，避免内存扩展<br><img src="/images/jvm20190051.png" alt="Alt text"></li>
</ul>
<h3 id="选择收集器降低延迟"><a href="#选择收集器降低延迟" class="headerlink" title="选择收集器降低延迟"></a>选择收集器降低延迟</h3><p>改用ParNew和CMS收集器来收集新生代、老年代。<br><img src="/images/jvm20190052.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章-虚拟机性能监控与故障处理工具</title>
    <url>/2019/11/02/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>介绍了随JDK发布的6个命令行工具及两个可视化的故障处理工具，灵活使用这些工具可以给问题处理带来很大的便利。</p>
<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>命令： jps[options][hostid]</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>虚拟机统计信息监视工具。<br>显示信息：类装载、内存、垃圾收集、JIT编译等运行数据<br>本地命令：jstat[option vmid[interval [s | ms][count]]]<br>远程命令：[protocol: ][//]lvmid[@hostname[:port]/servername]<br><img src="/images/jvm20190025.png" alt="Alt text"></p>
<p>案例：<br><img src="/images/jvm20190026.png" alt="Alt text"></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>Java配置信息工具。<br>作用：实时查看和调整虚拟机各项参数。<br>命令：jinfo[option]pid<br>案例：<br><img src="/images/jvm20190027.png" alt="Alt text"></p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>Java内存映像工具。<br>作用：</p>
<ul>
<li>用于生成堆转储快照（headump或dump文件）</li>
<li>可以查询finalize执行队列、Java堆和永久代的详细信息（空间使用率、当前用的哪种收集器等）</li>
</ul>
<p>命令：jmap[option]vmid<br><img src="/images/jvm20190028.png" alt="Alt text"><br>案例：<br><img src="/images/jvm20190029.png" alt="Alt text"></p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>虚拟机堆转存储快照分析工具，与jmap搭配使用。<br><img src="/images/jvm20190030.png" alt="Alt text"></p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>Java堆栈跟踪工具。<br>作用：用于生成虚拟机当前时刻的线程快照（threadump、javacore文件）。<br>命令：jstack[option]vmid<br><img src="/images/jvm20190031.png" alt="Alt text"><br>案例：<br><img src="/images/jvm20190032.png" alt="Alt text"></p>
<h2 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h2><p>JConsole和VisualVM。</p>
<h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h3><p>Java监视与管理控制台，是一种基于JMX的可视化监视、管理工具。</p>
<ol>
<li><p>启动JConsole<br>$ JDK/bin jconsole.exe<br><img src="/images/jvm20190033.png" alt="Alt text"></p>
</li>
<li><p>内存监控<br><img src="/images/jvm20190034.png" alt="Alt text"></p>
</li>
</ol>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>多合故障处理工具，是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。<br>优点：</p>
<ul>
<li>不需要被监视的程序基于特殊的Agen运行</li>
<li>可以做插件扩展（jps、jinfo、dump-jmap、jhat）</li>
<li>离线快照</li>
<li>有很强的向下兼容能力（JDK1.4.2）</li>
</ul>
<ol>
<li><p>插件安装<br><img src="/images/jvm20190035.png" alt="Alt text"></p>
</li>
<li><p>生成、浏览堆转储快照</p>
</li>
</ol>
<ul>
<li>应用程序-&gt;右键-&gt;堆dump</li>
<li>应用程序-&gt;双击-&gt;监视-&gt;堆dump</li>
</ul>
<ol start="3">
<li>分析程序性能</li>
<li>Btrace动态日志跟踪</li>
</ol>
<ul>
<li>Btrace是一个很有趣的VisualVM插件，可以独立运行。</li>
<li>作用：在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。</li>
</ul>
<p><img src="/images/jvm20190036.png" alt="Alt text"><br><img src="/images/jvm20190037.png" alt="Alt text"><br><img src="/images/jvm20190038.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章-垃圾收集器与内存分配策略</title>
    <url>/2019/11/02/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>本章介绍了垃圾收集的算法，几款JDK1.7中的垃圾收集器特点以及动作原理。通过代码验证实例验证了Java虚拟机中自动分配及回收的主要规则。</p>
<p>哪些内存需要回收？什么时候回收？如何回收？</p>
<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1，失效计数器就减1。<br>弊端：它很难解决对象之间相互循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的“GCRoots“的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的。<br>GCRoots对象包括：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法中JNI引用的对象</li>
</ul>
<p><img src="/images/jvm20190005.png" alt="Alt text"></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>强引用（Object obj = new Object()）</li>
<li>软引用（SoftReference类）</li>
<li>弱引用（WeakReference类）</li>
<li>虚引用（PhantomReference类）</li>
</ul>
<h3 id="标记对象死亡"><a href="#标记对象死亡" class="headerlink" title="标记对象死亡"></a>标记对象死亡</h3><p>第一次标记：进行可达性分析后发现没有GC Roots。<br>第二次标记：是否需要执行finalize()方法，需要则放F-Queue队列-&gt;Finalizer线程去执行（用try-finnaly替代finalizer()方法）。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><ul>
<li>永久代回收内容<ul>
<li>废弃容量</li>
<li>无用的类</li>
</ul>
</li>
<li>无用的类<ul>
<li>该类所有的实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用</li>
</ul>
</li>
<li>配置参数：-verbose: class -XX:+TraceClassLoading、-XX:+TraceClassUnLoading</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><img src="/images/jvm20190006.png" alt="Alt text"></p>
<h3 id="复制算法示意图"><a href="#复制算法示意图" class="headerlink" title="复制算法示意图"></a>复制算法示意图</h3><p><img src="/images/jvm20190007.png" alt="Alt text"></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p><img src="/images/jvm20190008.png" alt="Alt text"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><ul>
<li>新生代：复制算法</li>
<li>老年代：标记-清理或者标记-整理</li>
</ul>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><ol>
<li><p>枚举根节点<br>一组称为OopMap的数据结构，在类加载完成时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JTI编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
</li>
<li><p>安全点<br>HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，这些位置称为安全点。<br>选定标准：是否具有让程序长时间执行（指令序列复用）的特征<br>确保GC发生时所有线程都”跑“到最近的安全点上再停顿下来。<br>存在问题：当程序”不执行“时，无法响应JVM的中断请求？</p>
</li>
<li><p>安全区域<br>是指在一段代码片段之中，引用关系不会发生变化。<br><img src="/images/jvm20190009.png" alt="Alt text"></p>
</li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。<br><img src="/images/jvm20190010.png" alt="Alt text"></p>
<h3 id="Serial收集器（单线程收集器）"><a href="#Serial收集器（单线程收集器）" class="headerlink" title="Serial收集器（单线程收集器）"></a>Serial收集器（单线程收集器）</h3><p>最基本、发展历史最悠久的收集器。<br>优点：简单而高效。<br>缺点：停顿时间长。<br><img src="/images/jvm20190011.png" alt="Alt text"></p>
<h3 id="ParNew收集器（Serial多线程版本）"><a href="#ParNew收集器（Serial多线程版本）" class="headerlink" title="ParNew收集器（Serial多线程版本）"></a>ParNew收集器（Serial多线程版本）</h3><p>特征：</p>
<ul>
<li>Serial收集器所有参数（收集算法、Stop The World等）</li>
<li>除Serial收集器外，只有它能与CMS收集器配合工作</li>
<li>新生代收集器<br><img src="/images/jvm20190012.png" alt="Alt text"></li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>是一个新生收集器，它是使用复制算法的收集器，又是并行的多线程收集器。<br>目标：达到一个可控制的吞吐量（吞吐量=运行用户代码时间/运行时间+垃圾收集时间）<br>配置参数：-XX: MaxGCPauseMillis、-XX: GCTimeRatio</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的老年代版本，单线程和“标记-整理”算法。<br>作用：</p>
<ul>
<li>JDK1.5以及之间版本与Parallel Scavenge收集器搭配使用</li>
<li>作为CMS收集器的后备预案</li>
</ul>
<p><img src="/images/jvm20190013.png" alt="Alt text"></p>
<h3 id="Parallel-Old收集器（JDK1-6中才开始使用）"><a href="#Parallel-Old收集器（JDK1-6中才开始使用）" class="headerlink" title="Parallel Old收集器（JDK1.6中才开始使用）"></a>Parallel Old收集器（JDK1.6中才开始使用）</h3><p>Parallel Scavenge收集器的老年代版本，多线程和“标记-整理”算法。<br><img src="/images/jvm20190014.png" alt="Alt text"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>是一种以获取最短回收停顿时间为目标的收集器，标记-清除算法。<br>特征：重视服务的响应速度。<br>过程：</p>
<ul>
<li>初始标记（Stop The World）</li>
<li>并发标记（Stop The World）</li>
<li>重新标记</li>
<li>并发清除<br>优点：并发收集、低停顿<br>缺点：</li>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS收集器无法处理浮动垃圾，可能出现失败而导致另一次Full GC的产生<ul>
<li>浮动垃圾：并发清理阶段产生的新垃圾</li>
</ul>
</li>
<li>收集结束时会有大量空间碎片产生</li>
</ul>
<p><img src="/images/jvm20190015.png" alt="Alt text"></p>
<h3 id="G1收集器（JDK7u4达到商用）"><a href="#G1收集器（JDK7u4达到商用）" class="headerlink" title="G1收集器（JDK7u4达到商用）"></a>G1收集器（JDK7u4达到商用）</h3><p>是当今收集器技术发展的最前沿成果之一，被视为JDK1.7虚拟机的一个重要进化，是面向服务端应用的垃圾收集器。<br>特征：</p>
<ul>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合（标志-清理、标记-整理混用）</li>
<li>可预测的停顿</li>
</ul>
<p>区别：</p>
<ul>
<li>将整个Java堆划分为多个大小相等的独立区域</li>
<li>可以有计划避免在整个Java堆中进行全区域的垃圾收集。</li>
<li>把内存“化整为零”的思路</li>
</ul>
<p>过程：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收<br><img src="/images/jvm20190016.png" alt="Alt text"></li>
</ul>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><ul>
<li>[DefNew：Default New Generation，Serial收集器</li>
<li>[ParNew：Parallel New Generation，ParNew收集器</li>
<li>PSYoungGen：Parallel Scavenge收集器（老年代和永久代同理）</li>
</ul>
<p><img src="/images/jvm20190017.png" alt="Alt text"></p>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p><img src="/images/jvm20190018.png" alt="Alt text"><br><img src="/images/jvm20190019.png" alt="Alt text"></p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
<li>动态对象年龄判断</li>
<li>空间分配担保</li>
</ul>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><ul>
<li>Minor GC：新生代的垃圾收集动作</li>
<li>Major GC|Full GC：老年代GC（比Minor GC慢10倍以上）</li>
</ul>
<p><img src="/images/jvm20190020.png" alt="Alt text"></p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>需要大量连续内存空间的Java对象（很长的字符串及数组）。<br>配置参数：-XX:PretenureSizeThreshold<br><img src="/images/jvm20190021.png" alt="Alt text"></p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>内存回收根据对象年龄（Age）计数器来记录对象的年龄，默认15岁。<br>参数配置：-XX: MaxTenuringThreshold<br><img src="/images/jvm20190022.png" alt="Alt text"></p>
<h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>相同年龄所有对象大小的总和大于Survivor空间的一半，直接进入老年代（不用等年龄到15）。<br><img src="/images/jvm20190022.png" alt="Alt text"></p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>当老年代空间&lt;新生代晋升空间，会根据配置参数HandlePromotionFailure来担保是否继续操作。<br>配置参数：HandlePromotionFailure</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章-Java内存区域与内存溢出</title>
    <url>/2019/11/02/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>本章将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/images/jvm20190001.png" alt="Alt text"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。<br>作用：分支、循环、跳转、异常处理、线程恢复等基础功能需要依赖这个计数器来完成。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>是线程私有的，与线程生命周期相同。描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧。<br>作用：用来存储局部变量表、操作数栈、动态链接、方法出口等<br>使用场景：每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机入栈出栈的过程。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈类似，为Native方法服务。<br>常见异常：StackOverflowError、OutOfMemoryError异常</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。<br>特点：</p>
<ul>
<li>Java虚拟机所管理的内存中最大的一块</li>
<li>被所有线程共享的一块内存区域</li>
<li>在虚拟机启动时创建</li>
</ul>
<p>作用：存放对象实例</p>
<p>分类：</p>
<ul>
<li>粗分：新生代和老年代</li>
<li>细分：Eden空间、From Survivor空间、To Survivor空间<br>扩展：-Xmx和-Xms<br>常见异常：OutOfMemoryError异常</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的。<br>作用：存储类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>常见异常：OutOfMemoryError异常</p>
<h3 id="运行时常量（归属方法区）"><a href="#运行时常量（归属方法区）" class="headerlink" title="运行时常量（归属方法区）"></a>运行时常量（归属方法区）</h3><p>是方法区的一部分。<br>作用：用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>特征：具备动态性，如：String类的intern()方法<br>常见异常：OutOfMemoryError异常。</p>
<h3 id="直接内存（堆外内存）"><a href="#直接内存（堆外内存）" class="headerlink" title="直接内存（堆外内存）"></a>直接内存（堆外内存）</h3><p>不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。<br>使用场景：NIO（基于通道与缓冲区的IO方式）-&gt;分配堆外内存（通过Native函数库）-&gt;通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。<br>常见异常：OutOfMemoryError异常。</p>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>虚拟机遇到new指令-&gt;检查加载类过程-&gt;为新对象分配内存-&gt;将分配到的内存空间都初始化为零值-&gt;对对象进行必要的设置。<br>内存分配方式：</p>
<ul>
<li>指针碰撞（Java堆内存绝对规整的）</li>
<li>空闲列表（Java堆内存不规整）</li>
<li>依赖关系<ul>
<li>内存分配方式-&gt;Java堆是否规整-&gt;采用的收集器是否带有压缩整理功能。</li>
</ul>
</li>
</ul>
<p>存在问题：</p>
<ul>
<li>虚拟机对象创建是非常频繁的？</li>
<li>并发情况下无法保证线程安全？</li>
</ul>
<p>解决方案：</p>
<ul>
<li>对分配内存空间的动作进行同步处理（采用CAS配置失败重试的方式保证更新操作的原子性）</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。配置参数：-XX:+/-UserTLAB</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ol>
<li><p>对象头<br>存储对象自身的运行时数据（HashCode、GC分代年龄、锁状态标志等。<br><img src="/images/jvm20190002.png" alt="Alt text"></p>
</li>
<li><p>实例数据</p>
</li>
</ol>
<ul>
<li>存储顺序受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</li>
<li>默认分配策略：longs/doubles-&gt;ints-&gt;shorts/chars-&gt;bytes/booleans-&gt;oops</li>
</ul>
<ol start="3">
<li>对齐填充<br>由于HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ol>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。</p>
<h4 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h4><p><img src="/images/jvm20190003.png" alt="Alt text"></p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p><img src="/images/jvm20190004.png" alt="Alt text"></p>
<h2 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>配置：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8<br>解决区域异常步骤：</p>
<ul>
<li>通过内存映像分析工具（分析是内存泄漏||内存溢出）</li>
<li>内存泄漏：通过工具进一步找出泄漏对象到GCRoots的引用链</li>
<li>内存溢出：<ul>
<li>检查虚拟机堆参数（-Xmx和-Xms）</li>
<li>代码检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗</li>
</ul>
</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>配置参数：-Xss（-Xoss参数无效）</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><p>配置参数：-XX:PermSize=10M -XX:MaxPermSize=10M<br>异常场景：</p>
<ul>
<li>在经常动态生成大量Class的应用中，需要特别注意类的回收状况</li>
<li>CGLib字节码增强和动态语言</li>
<li>大量JSP或动态产生JSP文件的应用</li>
<li>基于OSGI的应用</li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>配置参数：-XX:MaxDirectMemorySize（不配置默认与Java堆最大值一样）<br>特征：在Head Dump文件中不会看见明显的异常</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深入了解JVM虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章-Java并发编程实践</title>
    <url>/2019/11/02/%E7%AC%AC11%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>本章主要介绍了生产者和消费者模式进行并发编程、线上问题排查手段和性能测试实战。</p>
<h2 id="生产者和消费者模式"><a href="#生产者和消费者模式" class="headerlink" title="生产者和消费者模式"></a>生产者和消费者模式</h2><p>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信。这个阻塞队列就是用来给生产者和消费者解耦的。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span></span></span><br><span class="line"><span class="comment"> * 阻塞队列生产消费者模式</span></span><br><span class="line"><span class="comment"> *  （1）生产：BlockingQueue.offer(val, timeout, timeout_unit)</span></span><br><span class="line"><span class="comment"> *  （2）消费：BlockingQueue.poll(timeout, timeout_unit)</span></span><br><span class="line"><span class="comment"> *  （3）开关：需要一个标识，循环等待</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProConsumer_BlockingQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        myResource.stop();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 叫停"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>; <span class="comment">// 默认开启，进行生产+消费者</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123; <span class="comment">// （1）判断</span></span><br><span class="line">            <span class="comment">// （2）干活+通知</span></span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">""</span>;</span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 插入队列"</span> + data + <span class="string">"成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 插入队列"</span> + data + <span class="string">"失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t大老板叫停，表示FLAG=false，生产动作结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String result;</span><br><span class="line">        <span class="keyword">while</span> (FLAG) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result || <span class="string">""</span>.equals(result)) &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 超过2秒没有取到蛋糕，消费退出"</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 消费队列蛋糕"</span> + result + <span class="string">"成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线上问题定位"><a href="#线上问题定位" class="headerlink" title="线上问题定位"></a>线上问题定位</h2><p>有时候，有很多问题只有在线上或者预发环境才能发现，而线上又不能调试代码，所以线上问题定位就只能看日志、系统状态和dump线程。</p>
<ol>
<li><p>先用top命令找出CPU占比最高的<br><img src="/images/javaconcurrent20191102024.png" alt="Alt text"></p>
</li>
<li><p>ps -ef或者jps进一步定位进程</p>
</li>
<li><p>定位到具体线程或代码</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"># -m 显示所有的线程</span><br><span class="line"># -p pid 进程使用cpu的时间</span><br><span class="line"># -o 该参数后是用户自定义格式</span><br><span class="line">$ ps -mp 进程 -o THREAD,tid,time、</span><br></pre></td></tr></table></figure>
</li>
<li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">dump出来的线程ID（nid）是十六进制的，而我们用TOP命令看到的线程ID是十进制的，</span><br><span class="line">所以要用printf命令转换一下进制。然后用十六进制的ID去dump里找到对应的线程。</span><br><span class="line">$ printf <span class="string">"%x\n"</span> <span class="number">31558</span></span><br><span class="line">输出：<span class="number">7</span>b46。</span><br></pre></td></tr></table></figure>
</li>
<li><p>定位异常代码块</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line">$ jstatck 进程ID | grep tid（<span class="number">16</span>进制线程ID小写英文）-A60</span><br><span class="line">输出：异常代码块</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>因为要支持某个业务，有同事向我们提出需求，希望系统的某个接口能够支持2万的QPS，因为我们的应用部署在多台机器上，要支持两万的QPS，我们必须先要知道该接口在单机上能支持多少QPS，如果单机能支持1千QPS，我们需要20台机器才能支持2万的QPS。</p>
<figure class="highlight"><figcaption><span>[常用命令]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 查询有多少台机器连接到这个端口上</span><br><span class="line">$ netstat -nat | grep <span class="number">12200</span> –c</span><br><span class="line">$ <span class="number">10</span></span><br><span class="line"><span class="number">2</span>. 查看已经使用了多少个数据库连接</span><br><span class="line">$ netstat -nat | grep <span class="number">3306</span> –c</span><br><span class="line">$ <span class="number">12</span></span><br><span class="line"><span class="number">3</span>. 通过ps命令查看下线程数是否增长了</span><br><span class="line">$ ps -eLf | grep java -c</span><br><span class="line">$ <span class="number">1520</span></span><br><span class="line"><span class="number">4</span>. 其它命令</span><br><span class="line"># 查看网络流量。</span><br><span class="line">$ cat /proc/net/dev</span><br><span class="line"># 查看系统平均负载。</span><br><span class="line">$ cat /proc/loadavg</span><br><span class="line"># 查看系统内存情况。</span><br><span class="line">$ cat /proc/meminfo</span><br><span class="line"># 查看CPU的利用率。</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章-Executor框架</title>
    <url>/2019/11/02/%E7%AC%AC10%E7%AB%A0-Executor%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>本章介绍了Executor框架的整体结构和成员组件，并以ThreadPoolExecuto、ScheduledThreadPoolExecuto、FutureTask三个核心成员类为例来剖析内部原理。</p>
<p>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开<br>来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p>
<h2 id="Executor框架简介"><a href="#Executor框架简介" class="headerlink" title="Executor框架简介"></a>Executor框架简介</h2><h3 id="Executor框架的两级调度模型"><a href="#Executor框架的两级调度模型" class="headerlink" title="Executor框架的两级调度模型"></a>Executor框架的两级调度模型</h3><p>应用程序通过Executor框架控制上层的调度；而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。<br><img src="/images/javaconcurrent20191102015.png" alt="Alt text"></p>
<h3 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h3><ol>
<li>Executor框架主要由3大部分组成如下</li>
</ol>
<ul>
<li>任务：Runnable接口或Callable接口。</li>
<li>任务的执行：Executor、ExecutorServic</li>
<li>异步计算的结果：FutureTask</li>
</ul>
<p><img src="/images/javaconcurrent20191102016.png" alt="Alt text"></p>
<ol start="2">
<li>Executor框架的成员<br>本节将介绍Executor框架的主要成员：ThreadPoolExecutor、ScheduledThreadPoolExecutor、Future接口、Runnable接口、Callable接口和Executors。</li>
</ol>
<ul>
<li>ThreadPoolExecutor<ul>
<li>FixedThreadPoo</li>
<li>SingleThreadExecuto</li>
<li>CachedThreadPoo</li>
</ul>
</li>
<li>ScheduledThreadPoolExecutor<ul>
<li>ScheduledThreadPoolExecutor</li>
<li>SingleThreadScheduledExecutor</li>
</ul>
</li>
<li>Future接口</li>
<li>Runnable接口和Callable接口    </li>
</ul>
<h2 id="ThreadPoolExecutor详解"><a href="#ThreadPoolExecutor详解" class="headerlink" title="ThreadPoolExecutor详解"></a>ThreadPoolExecutor详解</h2><p>Executor框架最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列4个组件构成。</p>
<ul>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列。</li>
<li>RejectedExecutionHandler：达到了最大线程池大小且工作队列已满，execute()方法将要调用的Handler。<br>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor。</li>
</ul>
<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>FixedThreadPool被称为可重用固定线程数的线程池。下面是FixedThreadPool的源代码实现。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">	<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>SingleThreadExecutor是使用单个worker线程的Executor。下面是SingleThreadExecutor的源代码实现。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">	(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">	<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>CachedThreadPool是一个会根据需要创建新线程的线程池。下面是创建CachedThreadPool的源代码。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">	<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">	<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPoolExecutor详解"><a href="#ScheduledThreadPoolExecutor详解" class="headerlink" title="ScheduledThreadPoolExecutor详解"></a>ScheduledThreadPoolExecutor详解</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。</p>
<h3 id="ScheduledThreadPoolExecutor的运行机制"><a href="#ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="ScheduledThreadPoolExecutor的运行机制"></a>ScheduledThreadPoolExecutor的运行机制</h3><p><img src="/images/javaconcurrent20191102017.png" alt="Alt text"></p>
<h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask）放到一个DelayQueue中。ScheduledFutureTask主要包含3个成员变量，如下。</p>
<ul>
<li>long型成员变量time，表示这个任务将要被执行的具体时间。</li>
<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。</li>
<li>long型成员变量period，表示任务执行的间隔周期。</li>
</ul>
<p>任务执行步骤：<br><img src="/images/javaconcurrent20191102018.png" alt="Alt text"></p>
<h2 id="FutureTask详解"><a href="#FutureTask详解" class="headerlink" title="FutureTask详解"></a>FutureTask详解</h2><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p>
<h3 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h3><p>FutureTask除了实现Future接口外，还实现了Runnable接口。<br>状态迁移的示意图：<br><img src="/images/javaconcurrent20191102019.png" alt="Alt text"></p>
<p>执行示意图：<br><img src="/images/javaconcurrent20191102020.png" alt="Alt text"></p>
<h3 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h3><figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache =</span><br><span class="line">	<span class="keyword">new</span> ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">executionTask</span><span class="params">(<span class="keyword">final</span> String taskName)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		Future&lt;String&gt; future = taskCache.get(taskName);<span class="comment">// 1.1,2.1</span></span><br><span class="line">		<span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">			Callable&lt;String&gt; task = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> taskName;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;; </span><br><span class="line">			FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(task);</span><br><span class="line">			future = taskCache.putIfAbsent(taskName, futureTask); <span class="comment">// 1.3</span></span><br><span class="line">			<span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">				future = futureTask;</span><br><span class="line">				futureTask.run(); <span class="comment">// 1.4执行任务</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> future.get();<span class="comment">// 1.5,2.2</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">			taskCache.remove(taskName, future);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的执行示意图：<br><img src="/images/javaconcurrent20191102021.png" alt="Alt text"></p>
<h2 id="FutureTask的实现"><a href="#FutureTask的实现" class="headerlink" title="FutureTask的实现"></a>FutureTask的实现</h2><p>FutureTask的实现基于AbstractQueuedSynchronizer（以下简称为AQS）。<br>设计示意图：<br><img src="/images/javaconcurrent20191102022.png" alt="Alt text"></p>
<p>级联唤醒示意图：<br><img src="/images/javaconcurrent20191102023.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章-Java中的线程池</title>
    <url>/2019/11/02/%E7%AC%AC9%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>本章主要介绍了为什么要使用线程池、如何使用线程池以及内部原理。</p>
<p>Java中的线程池是运用场景最多的并发框架，合理地使用线程池能够带来3个好处：</p>
<ul>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ul>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>处理流程：<br><img src="/images/javaconcurrent20191102013.png" alt="Alt text"></p>
<p>ThreadPoolExecutor执行示意图：<br><img src="/images/javaconcurrent20191102014.png" alt="Alt text"></p>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,milliseconds,runnableTaskQueue, handler);<br>几个重要参数：</p>
<ul>
<li>corePoolSize（线程池的基本大小）</li>
<li>runnableTaskQueue（任务队列）<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
<li>PriorityBlockingQueue</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大数量）</li>
<li>ThreadFactory：用于设置创建线程的工厂</li>
<li>RejectedExecutionHandler（饱和策略）</li>
</ul>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>
<figure class="highlight java"><figcaption><span>[execute()方法]</span></figcaption><table><tr><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[submit()方法]</span></figcaption><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	<span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">	<span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 关闭线程池</span></span><br><span class="line">	executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。</p>
<h3 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h3><p>要想合理地配置线程池，可以从以下几个角度来分析（建议使用有界队列）：</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute<br>和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。</p>
<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。</li>
<li>getPoolSize：线程池的线程数量。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章-Java中的并发工具类</title>
    <url>/2019/11/02/%E7%AC%AC8%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>本章主要介绍了使用JDK并发包里的CountDownLatch、CyclicBarrier和Semaphore工具类来控制并发流程以及使用Exchanger工具类在线程间交换数据。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<figure class="highlight java"><figcaption><span>[案例一]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"parser2 finish"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		parser1.start();</span><br><span class="line">		parser2.start();</span><br><span class="line">		parser1.join();</span><br><span class="line">		parser2.join();</span><br><span class="line">		System.out.println(<span class="string">"all parser finish"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[案例二]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 倒计时</span></span><br><span class="line"><span class="comment"> *  5个人都走了，才关门?</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123; <span class="comment">// 5个同学</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"离开"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"同学["</span> + i + <span class="string">"]"</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"班长关门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 计数器</span></span><br><span class="line"><span class="comment"> *  5个人都到齐了才出发</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"同学到了"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((cyclicBarrier.getNumberWaiting()+<span class="number">1</span>) != <span class="number">5</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"人数到齐准备出发！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 信号量</span></span><br><span class="line"><span class="comment"> *  停车场（5个车位，20人抢）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">// 停车场只有5个车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123; <span class="comment">// 20个人抢车位</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"》》》》抢到车位"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"离开了======="</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"同学"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。</p>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt;exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					String A = <span class="string">"银行流水A"</span>;　　　　<span class="comment">// A录入银行流水数据</span></span><br><span class="line">					exgr.exchange(A);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					String B = <span class="string">"银行流水B"</span>;　　　　<span class="comment">// B录入银行流水数据</span></span><br><span class="line">					String A = exgr.exchange(<span class="string">"B"</span>);</span><br><span class="line">					System.out.println(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span></span><br><span class="line">						+ A + <span class="string">"，B录入是："</span> + B);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		threadPool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章-Java中的13个原子操作类</title>
    <url>/2019/11/02/%E7%AC%AC7%E7%AB%A0-Java%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/</url>
    <content><![CDATA[<p>本章介绍了JDK中并发包里的AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference等13个原子操作类以及实现原理。</p>
<h2 id="原子更新基本类型类"><a href="#原子更新基本类型类" class="headerlink" title="原子更新基本类型类"></a>原子更新基本类型类</h2><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p>
<ul>
<li>AtomicBoolean：原子更新布尔类型。</li>
<li>AtomicInteger：原子更新整型。</li>
<li>AtomicLong：原子更新长整型。</li>
</ul>
<p>仅以AtomicInteger为例，核心方法：</p>
<ul>
<li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</li>
<li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</li>
<li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li>
<li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(ai.getAndIncrement());</span><br><span class="line">		System.out.println(ai.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>[Unsafe的源码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前数值是expected，则原子的将Java变量更新成x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果更新成功则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o,</span></span></span><br><span class="line"><span class="function"><span class="params">												 <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">												 Object expected,</span></span></span><br><span class="line"><span class="function"><span class="params">												 Object x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">											  <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">											  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">											   <span class="keyword">long</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">											   <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类。</p>
<ul>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素。<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>， <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">static</span> AtomicIntegerArray ai = <span class="keyword">new</span> AtomicIntegerArray(value);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ai.getAndSet(<span class="number">0</span>， <span class="number">3</span>);</span><br><span class="line">		System.out.println(ai.get(<span class="number">0</span>));</span><br><span class="line">		System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<ul>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;user&gt; atomicUserRef = <span class="keyword">new</span></span><br><span class="line">		AtomicReference&lt;user&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User user = <span class="keyword">new</span> User(<span class="string">"conan"</span>， <span class="number">15</span>);</span><br><span class="line">		atomicUserRef.set(user);</span><br><span class="line">		User updateUser = <span class="keyword">new</span> User(<span class="string">"Shinichi"</span>， <span class="number">17</span>);</span><br><span class="line">		atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">		System.out.println(atomicUserRef.get().getName());</span><br><span class="line">		System.out.println(atomicUserRef.get().getOld());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> old;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name， <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.old = old;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> old;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">		newUpdater(User.class， "old");</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">		User conan = <span class="keyword">new</span> User(<span class="string">"conan"</span>， <span class="number">10</span>);</span><br><span class="line">		<span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">		System.out.println(a.getAndIncrement(conan));</span><br><span class="line">		<span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">		System.out.println(a.get(conan));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> old;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name， <span class="keyword">int</span> old)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.old = old;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> old;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章-Java并发容器和框架</title>
    <url>/2019/11/02/%E7%AC%AC6%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>本章主要介绍了并发容器（ConcurrentHashMap、ConcurrentLinkedQueue、阻塞队列）和并发框架（Fork/Join框架），并分析了其内部原理。</p>
<h2 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a>ConcurrentHashMap的实现原理与使用</h2><p>ConcurrentHashMap是线程安全且高效的HashMap。</p>
<h3 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h3><ul>
<li>线程不安全的HashMap</li>
<li>效率低下的HashTable</li>
<li>ConcurrentHashMap的锁分段技术可有效提升并发访问率</li>
</ul>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。<br>核心操作：</p>
<ul>
<li>get操作</li>
<li>put操作<ul>
<li>是否需要扩容</li>
<li>如何扩容</li>
</ul>
</li>
<li>size操作</li>
</ul>
<p>ConcurrentHashMap的类图：<br><img src="/images/javaconcurrent20191102008.png" alt="Alt text"><br>ConcurrentHashMap的结构图：<br><img src="/images/javaconcurrent20191102009.png" alt="Alt text"></p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>非阻塞的方式来实现线程安全队列。</p>
<h3 id="ConcurrentLinkedQueue的结构"><a href="#ConcurrentLinkedQueue的结构" class="headerlink" title="ConcurrentLinkedQueue的结构"></a>ConcurrentLinkedQueue的结构</h3><p>ConcurrentLinkedQueue的类图：<br><img src="/images/javaconcurrent20191102010.png" alt="Alt text"></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><p>入队列就是将入队节点添加到队列的尾部。</p>
<figure class="highlight java"><figcaption><span>[源码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="comment">// 入队前，创建一个入队节点</span></span><br><span class="line">	Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">	retry:</span><br><span class="line">	<span class="comment">// 死循环，入队不成功反复入队。</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">// 创建一个指向tail节点的引用</span></span><br><span class="line">		Node&lt;E&gt; t = tail;</span><br><span class="line">		<span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。</span></span><br><span class="line">		Node&lt;E&gt; p = t;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;</span><br><span class="line">			<span class="comment">// 获得p节点的下一个节点。</span></span><br><span class="line">			Node&lt;E&gt; next = succ(p);</span><br><span class="line">			<span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点</span></span><br><span class="line">			<span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点</span></span><br><span class="line">				<span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)</span><br><span class="line">					<span class="keyword">continue</span> retry;</span><br><span class="line">				p = next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;</span><br><span class="line">				<span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，</span></span><br><span class="line"><span class="comment">				更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span></span><br><span class="line">				<span class="keyword">if</span> (hops &gt;= HOPS)</span><br><span class="line">					casTail(t, n); <span class="comment">// 更新tail节点，允许失败</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				p = succ(p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。</p>
<figure class="highlight java"><figcaption><span>[源码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node&lt;E&gt; h = head;</span><br><span class="line">	<span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">	Node&lt;E&gt; p = h;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>;; hops++) &#123;</span><br><span class="line">		<span class="comment">// 获取p节点的元素</span></span><br><span class="line">		E item = p.getItem();</span><br><span class="line">		<span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,</span></span><br><span class="line">		<span class="comment">// 如果成功则返回p节点的元素。</span></span><br><span class="line">		<span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hops &gt;= HOPS) &#123;</span><br><span class="line">				<span class="comment">// 将p节点下一个节点设置成head节点</span></span><br><span class="line">				Node&lt;E&gt; q = p.getNext();</span><br><span class="line">				updateHead(h, (q != <span class="keyword">null</span>) q : p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> item;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外</span></span><br><span class="line">		<span class="comment">// 一个线程修改了。那么获取p节点的下一个节点</span></span><br><span class="line">		Node&lt;E&gt; next = succ(p);</span><br><span class="line">		<span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了</span></span><br><span class="line">		<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 更新头节点。</span></span><br><span class="line">			updateHead(h, p);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">		p = next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h2><p>本节将介绍什么是阻塞队列，以及Java中阻塞队列的4种处理方式，并介绍Java 7中提供的7种阻塞队列，最后分析阻塞队列的一种实现方式。</p>
<h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>阻塞队列的4种处理方式：<br><img src="/images/javaconcurrent20191102011.png" alt="Alt text"></p>
<h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><p>JDK 7提供了7个阻塞队列，如下：</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</p>
<figure class="highlight java"><figcaption><span>[源码]</span></figcaption><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">	<span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">	lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">	notEmpty = lock.newCondition();</span><br><span class="line">	notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…..</p>
<h3 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h3><p>使用通知模式实现。底层是Condition来实现。</p>
<figure class="highlight java"><figcaption><span>[源码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略其他代码</span></span><br><span class="line">	notEmpty = lock.newCondition();</span><br><span class="line">	notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	checkNotNull(e);</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count == items.length)</span><br><span class="line">			notFull.await();</span><br><span class="line">		insert(e);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">			notEmpty.await();</span><br><span class="line">		<span class="keyword">return</span> extract();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">	items[putIndex] = x;</span><br><span class="line">	putIndex = inc(putIndex);</span><br><span class="line">	++count;</span><br><span class="line">	notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>本节将会介绍Fork/Join框架的基本原理、算法、设计方式、应用与实现等。</p>
<h3 id="什么是Fork-Join框架"><a href="#什么是Fork-Join框架" class="headerlink" title="什么是Fork/Join框架"></a>什么是Fork/Join框架</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干<br>个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>流程图：<br><img src="/images/javaconcurrent20191102012.png" alt="Alt text"></p>
<h3 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h3><p>让我们通过一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">		<span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">		<span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">				sum += i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">			<span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">			CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">			CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">			<span class="comment">// 执行子任务</span></span><br><span class="line">			leftTask.fork();</span><br><span class="line">			rightTask.fork();</span><br><span class="line">			<span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">			<span class="keyword">int</span> leftResult=leftTask.join();</span><br><span class="line">			<span class="keyword">int</span> rightResult=rightTask.join();</span><br><span class="line">			<span class="comment">// 合并子任务</span></span><br><span class="line">			sum = leftResult + rightResult;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		<span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">		CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">		<span class="comment">// 执行一个任务</span></span><br><span class="line">		Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(result.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Fork-Join框架的异常处理"><a href="#Fork-Join框架的异常处理" class="headerlink" title="Fork/Join框架的异常处理"></a>Fork/Join框架的异常处理</h3><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally())</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章-Java中的锁</title>
    <url>/2019/11/02/%E7%AC%AC5%E7%AB%A0-Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>本章主要是介绍了如何使用Lock接口、队列同步器、重入锁、读写锁、Condition接口来实现锁以及LockSupport工具。</p>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。<br>三个关键方法：</p>
<ul>
<li>getState()：获取当前同步状态。</li>
<li>setState(int newState)：设置当前同步状态。</li>
<li>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 是否处于占用状态</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">				setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span></span><br><span class="line">				IllegalMonitorStateException();</span><br><span class="line">			setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">			setState(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">		<span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。<br>实现重进入需要解决两个问题：</p>
<ul>
<li>线程再次获取锁</li>
<li>锁的最终释放</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例：ReentrantLock是通过组合自定义同步器来实现锁的获取与释放]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">			setExclusiveOwnerThread(current);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">		<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">		setState(nextc);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁（ReentrantReadWriteLock）"><a href="#读写锁（ReentrantReadWriteLock）" class="headerlink" title="读写锁（ReentrantReadWriteLock）"></a>读写锁（ReentrantReadWriteLock）</h2><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而ReentrantReadWriteLock就其实现类。<br><img src="/images/javaconcurrent20191102005.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">	<span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	<span class="keyword">static</span> Lock r = rwl.readLock();</span><br><span class="line">	<span class="keyword">static</span> Lock w = rwl.writeLock();</span><br><span class="line">	<span class="comment">// 获取一个key对应的value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		r.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> map.get(key);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			r.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置key对应的value，并返回旧的value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> map.put(key, value);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 清空所有的内容</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		w.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			map.clear();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			w.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。<br><img src="/images/javaconcurrent20191102007.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		condition.await();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		condition.signal();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h2><p>LockSupport定义了一组的公共静态方法，是构建同步组件的基础工具。<br><img src="/images/javaconcurrent20191102006.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章-Java并发编程基础</title>
    <url>/2019/11/02/%E7%AC%AC4%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本章主要介绍了什么是线程、线程的启动和终止、线程之间的通信和几个实际案例。</p>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程：操作系统调度的最小单元，也叫轻量级进程（LightWeight Process）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取Java线程管理MXBean</span></span><br><span class="line">		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.</span><br><span class="line">			getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出内容</span></span><br><span class="line">		[<span class="number">4</span>] Signal Dispatcher　 <span class="comment">// 分发处理发送给JVM信号的线程</span></span><br><span class="line">		[<span class="number">3</span>] Finalizer　　　　 <span class="comment">// 调用对象finalize方法的线程</span></span><br><span class="line">		[<span class="number">2</span>] Reference Handler <span class="comment">// 清除Reference的线程</span></span><br><span class="line">		[<span class="number">1</span>] main　 　　　　 <span class="comment">// main线程，用户程序入口</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><p>因为正确使用多线程，总是能够给开发人员带来显著的好处，而使用多线程的原因主要有以下几点。</p>
<ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10。可以通过setPriority(int)方法来修改优先级，默认优先级是5。程序正确性不能依赖线程的优先级高低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> priority = i &lt; <span class="number">5</span> Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class="line">            Job job = <span class="keyword">new</span> Job(priority);</span><br><span class="line">            jobs.add(job);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i);</span><br><span class="line">            thread.setPriority(priority);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        notStart = <span class="keyword">false</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        notEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Job job : jobs) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Job Priority : "</span> + job.priority + <span class="string">",</span></span><br><span class="line"><span class="string">                    Count : "</span> + job.jobCount);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 输出内容</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1259592</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1260717</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1264510</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1251897</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1264060</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1256938</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1267663</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1260637</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1261705</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1259967</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (notStart) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (notEnd) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                jobCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li>初始状态</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>等待状态</li>
<li>超时等待状态</li>
<li>终止状态</li>
</ul>
<p>状态图<br><img src="/images/javaconcurrent20191102001.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[代码示例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting (), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line"><span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。<br>注意：Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><p>start()、run()</p>
<h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">	<span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">	<span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.</span><br><span class="line">                inheritableThreadLocals);</span><br><span class="line">	<span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。<br>关键方法：</p>
<ul>
<li>isInterrupted()：是否被中断</li>
<li>Thread.interrupted()：复位（对当前线程的中断标识）</li>
<li>Thread.sleep(longmillis)：睡眠指定时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// sleepThread不停的尝试睡眠</span></span><br><span class="line">        Thread sleepThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"SleepThread"</span>);</span><br><span class="line">        sleepThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// busyThread不停的运行</span></span><br><span class="line">        Thread busyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"BusyThread"</span>);</span><br><span class="line">        busyThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">		<span class="comment">// 休眠5秒，让sleepThread和busyThread充分运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"SleepThread interrupted is "</span> + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"BusyThread interrupted is "</span> + busyThread.isInterrupted());</span><br><span class="line">		<span class="comment">// 防止sleepThread和busyThread立刻退出</span></span><br><span class="line">        SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="过期的suspend-、resume-和stop"><a href="#过期的suspend-、resume-和stop" class="headerlink" title="过期的suspend()、resume()和stop()"></a>过期的suspend()、resume()和stop()</h3><p>大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作。</p>
<ul>
<li>suspend()：暂停<ul>
<li>过期的API</li>
<li>占有着资源进入睡眠状态，容易引发死锁</li>
</ul>
</li>
<li>resume()：恢复</li>
<li>stop()：停止<ul>
<li>过期的API</li>
<li>不会保证线程的资源正常释放</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deprecated</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行暂停，输出内容工作停止</span></span><br><span class="line">        printThread.suspend();</span><br><span class="line">        System.out.println(<span class="string">"main suspend PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行恢复，输出内容继续</span></span><br><span class="line">        printThread.resume();</span><br><span class="line">        System.out.println(<span class="string">"main resume PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行终止，输出内容停止</span></span><br><span class="line">        printThread.stop();</span><br><span class="line">        System.out.println(<span class="string">"main stop PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出如下</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">36</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">37</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">38</span></span><br><span class="line">		main suspend PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">39</span></span><br><span class="line">		main resume PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">42</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">42</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">43</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">44</span></span><br><span class="line">		main stop PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" Run at "</span> +</span><br><span class="line">                        format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">		<span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">		<span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程开始运行，拥有自己的栈空间，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。</p>
<h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><p>关键字volatile：轻量级锁，可以用来修饰字段（成员变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 对Synchronized Class对象进行加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 静态同步方法，对Synchronized Class对象进行加锁</span></span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ javap–v Synchronized<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">// 输出以下内容：</span></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    <span class="comment">// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line">    Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">		0: ldc #1　　// class com/murdock/books/multithread/book/Synchronized</span><br><span class="line">		<span class="number">2</span>: dup</span><br><span class="line">		<span class="number">3</span>: monitorenter　　<span class="comment">// monitorenter：监视器进入，获取锁</span></span><br><span class="line">		<span class="number">4</span>: monitorexit　　 <span class="comment">// monitorexit：监视器退出，释放锁</span></span><br><span class="line">		5: invokestatic　　#16 // Method m:()V</span><br><span class="line">		<span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 方法修饰符，表示： public static synchronized</span></span><br><span class="line">	flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">		   Code:</span><br><span class="line">					stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">					<span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>                    

<p><img src="/images/javaconcurrent20191102002.png" alt="Alt text"><br>结论：</p>
<ul>
<li>同步块：使用了monitorenter和monitorexit指令。</li>
<li>同步方法：依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。                    </li>
</ul>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>相关方法：<br><img src="/images/javaconcurrent20191102003.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出如下</span></span><br><span class="line">		Thread[WaitThread,<span class="number">5</span>,main] flag is <span class="keyword">true</span>. wait @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">03</span></span><br><span class="line">		Thread[NotifyThread,<span class="number">5</span>,main] hold lock. notify @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">04</span></span><br><span class="line">		Thread[NotifyThread,<span class="number">5</span>,main] hold lock again. sleep @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">09</span></span><br><span class="line">		Thread[WaitThread,<span class="number">5</span>,main] flag is <span class="keyword">false</span>. running @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">14</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true. wait</span></span><br><span class="line"><span class="string">                        @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false. running</span></span><br><span class="line"><span class="string">                @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">				<span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">				<span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock. notify @ "</span> +</span><br><span class="line">                        <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock again. sleep</span></span><br><span class="line"><span class="string">                @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程图：<br><img src="/images/javaconcurrent20191102003.png" alt="Alt text">        </p>
<h3 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h3><p>该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。</p>
<h4 id="等待方遵循如下原则。"><a href="#等待方遵循如下原则。" class="headerlink" title="等待方遵循如下原则。"></a>等待方遵循如下原则。</h4><ul>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ul>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	<span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知方遵循如下原则。"><a href="#通知方遵循如下原则。" class="headerlink" title="通知方遵循如下原则。"></a>通知方遵循如下原则。</h4><ul>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程。</li>
</ul>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	改变条件</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h3><p>可以理解为它是用于线程之间的数据传输，传输的媒介为内存的流。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">		<span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h3><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才<br>从thread.join()返回。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK中Thread.join()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">	<span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool</span><br><span class="line">            &lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span></span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">				<span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">			<span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池技术及其示例"><a href="#线程池技术及其示例" class="headerlink" title="线程池技术及其示例"></a>线程池技术及其示例</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池接口的默认实现：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span></span><br><span class="line">            ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_</span><br><span class="line">        NUMBERS MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">			<span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count)</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.</span><br><span class="line">                    incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">					<span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">							<span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">						<span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个基于线程池技术的简单Web服务器"><a href="#一个基于线程池技术的简单Web服务器" class="headerlink" title="一个基于线程池技术的简单Web服务器"></a>一个基于线程池技术的简单Web服务器</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool</span><br><span class="line">            &lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span></span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章-Java内存模型</title>
    <url>/2019/11/01/%E7%AC%AC3%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本章主要讲了JMM内存模型原理及使用volatile、锁、concurrent并发包、final域等方式来进行多线程高并发环境下编码。</p>
<h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ul>
<li>线程之间如何通信<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</li>
<li>线程之间如何同步<br>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</li>
</ul>
<h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>JMM：Java内存模型。<br>两个步骤：</p>
<ul>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>线程B到主内存中去读取线程A之前已更新过的共享变量。<br><img src="/images/javaconcurrent005.png" alt="Alt text"></li>
</ul>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p><img src="/images/javaconcurrent006.png" alt="Alt text"></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p><img src="/images/javaconcurrent007.png" alt="Alt text"></p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p><img src="/images/javaconcurrent008.png" alt="Alt text"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><h4 id="数据依赖性-1"><a href="#数据依赖性-1" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p><img src="/images/javaconcurrent009.png" alt="Alt text"></p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>描述：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>; <span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/javaconcurrent010.png" alt="Alt text"></p>
<h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">		flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f?lag) &#123; <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">			……</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/javaconcurrent011.png" alt="Alt text"></p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><ul>
<li>数据竞争与顺序一致性</li>
<li>顺序一致性内存模型</li>
<li>同步程序的顺序一致性效果</li>
<li>未同步程序的执行特性</li>
</ul>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><ul>
<li>可见性</li>
<li>原子性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">		vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">==&gt; 等价以下代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">		vl = l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">		<span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">		temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">		set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">		<span class="keyword">return</span> vl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>锁是Java并发编程中最重要的同步机制。<br><img src="/images/javaconcurrent012.png" alt="Alt text"></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();　　　　 <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			a++;</span><br><span class="line">		&#125; f　　inally &#123;</span><br><span class="line">			lock.unlock();　　<span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();　　　　 <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> i = a;</span><br><span class="line">			……</span><br><span class="line">		&#125; f　　inally &#123;</span><br><span class="line">			lock.unlock();　 <span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h3><p><img src="/images/javaconcurrent013.png" alt="Alt text"></p>
<h2 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h2><p>inal域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		i = <span class="number">1</span>; <span class="comment">// 1写final域</span></span><br><span class="line">		obj = <span class="keyword">this</span>; <span class="comment">// 2 this引用在此"逸出"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">int</span> temp = obj.i; <span class="comment">// 4</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> DCL单例 + volatile（禁止指令重排）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>第2章-Java并发机制的底层实现原理</title>
    <url>/2019/10/31/%E7%AC%AC2%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本章我们主要学习volatile轻量级锁、synchronized关键字及原子操作的原理。</p>
<h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>概念：volatile是一种轻量级的synchronized（锁）。<br>特点：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例一]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> volatile可见性、非原子性验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证可见性</span></span><br><span class="line">        seeOkVisibility();</span><br><span class="line">        <span class="comment">// 验证非原子性</span></span><br><span class="line">        seeNonAtomic();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seeNonAtomic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span> ; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over value:"</span> + myData.number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置可见性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seeOkVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            myData.addTO60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated number value: "</span> + myData.number);</span><br><span class="line">        &#125;, <span class="string">"AAA"</span>).start();</span><br><span class="line">        <span class="keyword">while</span> (myData.number == <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTO60</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>[案例二]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> DCL单例 + volatile（禁止指令重排）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>概念：锁<br>三种表现形式：</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized用的锁是存在Java对象头里的。<br><img src="/images/javaconcurrent003.png" alt="Alt text"></p>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在<br>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状<br>态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏<br>向锁升级成轻量级锁后不能降级成偏向锁。<br><img src="/images/javaconcurrent004.png" alt="Alt text"></p>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><p>概念<br>原子：不能被进一步分割的最小粒子。<br>原子操作：不可被中断的一个或一系列操作。</p>
<h3 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h3><h4 id="使用循环CAS实现原子操作"><a href="#使用循环CAS实现原子操作" class="headerlink" title="使用循环CAS实现原子操作"></a>使用循环CAS实现原子操作</h4><ul>
<li>存在几个问题<ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作<figure class="highlight java"><figcaption><span>[代码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> CAS保证原子性</span></span><br><span class="line"><span class="comment"> *  T1 100 -&gt; 101</span></span><br><span class="line"><span class="comment"> *  T2 100 -&gt; 2019</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// T1 100 -&gt; 101</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated: "</span> + atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">101</span>) + <span class="string">",value: "</span> + atomicInteger.get());</span><br><span class="line">        &#125;, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="comment">// T2 100 -&gt; 2019</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated: "</span> + atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">",value: "</span> + atomicInteger.get());</span><br><span class="line">        &#125;, <span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。</p>
<figure class="highlight java"><figcaption><span>[代码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicReferenceABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">    &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础版</span></span><br><span class="line">    atomicReferenceABA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章-并发编程的挑战</title>
    <url>/2019/10/31/%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<p>该文章主要介绍了多线程环境的上下文切换和死锁场景以及如何避免、解决死锁。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>概念</strong>：任务从保存到再加载的过程就是一次上下文切换。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p>
<h3 id="两个案例"><a href="#两个案例" class="headerlink" title="两个案例"></a>两个案例</h3><h4 id="多线程一定快吗？"><a href="#多线程一定快吗？" class="headerlink" title="多线程一定快吗？"></a>多线程一定快吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">10000l</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		concurrency();</span><br><span class="line">		serial();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">					a += <span class="number">5</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			b--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">		thread.join();</span><br><span class="line">		System.out.println(<span class="string">"concurrency :"</span> + time+<span class="string">"ms,b="</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			a += <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			b--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">		System.out.println(<span class="string">"serial:"</span> + time+<span class="string">"ms,b="</span>+b+<span class="string">",a="</span>+a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：不一定，当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。<br>为什么并发执行慢：因为线程有创建和上下文切换的开销</p>
<h4 id="测试上下文切换次数和时长"><a href="#测试上下文切换次数和时长" class="headerlink" title="测试上下文切换次数和时长"></a>测试上下文切换次数和时长</h4><p><img src="/images/javaconcurrent001.png" alt="Alt text"></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><img src="/images/javaconcurrent002.png" alt="Alt text"></p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul>
<li>系统资源不足</li>
<li>进程间推进的顺序非法</li>
<li>资源分配不当<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">	privat <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123; Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">						System.out.println(<span class="string">"1"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">						System.out.println(<span class="string">"2"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h3 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h3><ul>
<li>jps命令定位进程号（jsp -l）</li>
<li>jstack死锁查看（jstack 进程号）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>java如何写出简洁代码</title>
    <url>/2019/10/30/java%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>该文章主要是描述如何使用重构方法来精简代码，使代码看起来更有灵性。</p>
<h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 三次法则（事不过三，三则重构）</span><br><span class="line"><span class="number">2</span>. 何时重构：</span><br><span class="line">（<span class="number">1</span>）添加功能时重构</span><br><span class="line">（<span class="number">2</span>）修补错误时重构</span><br><span class="line">（<span class="number">3</span>）复审代码时重构</span><br><span class="line"><span class="number">3</span>. 重构优点：</span><br><span class="line">（<span class="number">1</span>）允许逻辑共享</span><br><span class="line">（<span class="number">2</span>）分开解释意图和实现</span><br><span class="line">（<span class="number">3</span>）隔离变化</span><br><span class="line">（<span class="number">4</span>）封装条件逻辑</span><br><span class="line"><span class="number">4</span>. 重构难点：</span><br><span class="line">（<span class="number">1</span>）数据库</span><br><span class="line">（<span class="number">2</span>）修改接口</span><br><span class="line">	解决办法：不要过早发布接口，请修改你的代码所有权策略，</span><br><span class="line">	使重构更顺畅。</span><br><span class="line">（<span class="number">3</span>）难以通过重构手法完成的设计改动</span><br><span class="line"><span class="number">5</span>. 重构与设计：</span><br><span class="line"> 重构肩负一项特殊使命，它和设计彼此互补。</span><br></pre></td></tr></table></figure>

<h2 id="代码坏味道"><a href="#代码坏味道" class="headerlink" title="代码坏味道"></a>代码坏味道</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duplicated Code（重复代码）</span><br><span class="line">Long Method（过长函数）</span><br><span class="line">Large Class（过大的类）</span><br><span class="line">Long Parameters List（过长参数列）</span><br><span class="line">Divergent Change（发散式变化）-&gt; 一个类受多种变化的影响</span><br><span class="line">Shotgun Surgery（霰弹式修改）-&gt; 一种变化引发多个类相应修改</span><br><span class="line">Feature Envy（依恋情结）-&gt; 将数据和数据的操作行为包装在一起的技术</span><br><span class="line">Data Clumps（数据泥团）</span><br><span class="line">Primitive Obsession（基本类型偏执）</span><br><span class="line">Switch Statements（<span class="keyword">switch</span>惊悚现身）</span><br><span class="line">Parallel Inheritance Hierarchies（平行继承行为）</span><br><span class="line">Lazy Class（冗余类）</span><br><span class="line">Sepculative Generality</span><br><span class="line">Temporary Field（令人迷惑的暂时字段）</span><br><span class="line">Message Chain（过度耦合的消息链）</span><br><span class="line">Middle Many（中间人）</span><br><span class="line">Inappropriate Intimacy（狎昵关系）</span><br><span class="line">Alternative Classes with Different Interfaces（异曲同工的类）</span><br><span class="line">Incomplete Library Class（不完善的类库）</span><br><span class="line">Data Class（纯稚的数据类）</span><br><span class="line">Refused Bequest（被拒绝的遗赠）</span><br><span class="line">Comments（过多的注释）-&gt; 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释变得多余。</span><br></pre></td></tr></table></figure>
<h2 id="构筑测试体系"><a href="#构筑测试体系" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">确保所有测试都完全自动化，让它们检查自己的测试结果。</span><br><span class="line">一套测试就是一个强大的侦测器，能够大大缩短查询bug所需要的时间</span><br><span class="line">频繁的运行测试，每次编译请把测试也考虑进去————每天至少执行每个测试一次</span><br><span class="line">每当你收到bug报告，请先写一个单元测试来暴露bug.</span><br><span class="line">编写未臻完善的测试并实际运行，好过对完善测试的无尽等待。</span><br><span class="line">考虑可能出错的边界条件，把测试火力集中在那儿</span><br><span class="line">当事情被认为应该出错时，别忘了检查是否抛出了预期的异常。</span><br><span class="line">不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数的bug。</span><br></pre></td></tr></table></figure>

<h2 id="重构列表"><a href="#重构列表" class="headerlink" title="重构列表"></a>重构列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 重构记录格式：</span><br><span class="line">name、summary、motivation、mechanics、examples</span><br><span class="line">（<span class="number">1</span>）summary：</span><br><span class="line">一句话，介绍这个重构能够帮助解决的问题</span><br><span class="line">一段简述，介绍你应该做的事</span><br><span class="line">一幅速写图，简单展现重构前后示例</span><br><span class="line">（<span class="number">2</span>）mechanics：</span><br><span class="line">简短的笔记，为了让自己在一段时间不做某项重构之后还能记录怎么做。</span><br><span class="line">（<span class="number">3</span>）examples</span><br><span class="line">像是简单有趣的教科书</span><br><span class="line"><span class="number">2</span>. 寻找引用点</span><br><span class="line">（<span class="number">1</span>）如果被删除的部分在继承体系中声明不上一次</span><br><span class="line">（<span class="number">2</span>）编译器可能很慢</span><br><span class="line">（<span class="number">3</span>）编译器无法找到通过反射机制而得到的引用点</span><br></pre></td></tr></table></figure>

<h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">motivation：喜欢简短而命名良好的函数，细粒度函数，被复用的机会更大，函数的覆写也更容易些</span><br><span class="line">mechanics：</span><br><span class="line">（<span class="number">1</span>）创造一个新函数</span><br><span class="line">（<span class="number">2</span>）将提炼的代码从源函数复制到新建的目标函数中</span><br><span class="line">（<span class="number">3</span>）仔细检查提炼出的代码，看看其中是否引用了“作用域源于源函数”的变量（包括局部变量和源函数参数）</span><br><span class="line">（<span class="number">4</span>）检查是否有“仅用于被提炼代码段”的临时变量。如果有，在目标函数中将它们声明为临时变量</span><br><span class="line">（<span class="number">5</span>）检查被提炼代码段，看看是否有任何局部变量的值被它改变。</span><br><span class="line">（<span class="number">6</span>）将被提炼代码段中需要读取的局部变量，当作参数传给目标函数</span><br></pre></td></tr></table></figure>

<h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *（1）查检函数，确定它不具备多态性</span></span><br><span class="line"><span class="comment"> *（2）找出这个函数的所有被调用点</span></span><br><span class="line"><span class="comment"> *（3）将这个函数的所有被调用点都替换为函数本体</span></span><br><span class="line"><span class="comment"> *（4）编译，测试</span></span><br><span class="line"><span class="comment"> *（5）删除该函数的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveDelivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_numberOfLateDeliveries &gt; <span class="number">5</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> (basePrice &gt; <span class="number">1000</span>);</span><br><span class="line">-&gt; </span><br><span class="line"><span class="keyword">return</span> (anOrder.basePrice() &gt; <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Replace-Temp-With-Query（以查询取代临时变量）"><a href="#Replace-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp With Query（以查询取代临时变量）"></a>Replace Temp With Query（以查询取代临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) </span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) </span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Introduce-Explaing-Variable（引入解释性变量）"><a href="#Introduce-Explaing-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaing Variable（引入解释性变量）"></a>Introduce Explaing Variable（引入解释性变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp; </span><br><span class="line">    (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">    wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">final</span> boolen isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice - </span><br><span class="line">        Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span> +</span><br><span class="line">        Math.min(_quantity * _itemPrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> quantityDiscount = Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> shpping = Math.min(basePrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> basePrice - quantityDiscount + shpping;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * quantityDiscount() * shpping();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quantityDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">shpping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(basePrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_heigth + _width);</span><br><span class="line">sysout(temp);</span><br><span class="line">temp = _heigth * _width;</span><br><span class="line">sysout(temp);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_heigth + _width);</span><br><span class="line">sysout(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _heigth * _width;</span><br><span class="line">sysout(area);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistanceTravelled</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    finall <span class="keyword">double</span> primaryAcc = _primaryForce / _mass;</span><br><span class="line">    <span class="keyword">int</span> primaryTime = Math.min(time, _delay);</span><br><span class="line">    <span class="keyword">return</span> = <span class="number">0.5</span> * primaryAcc * primaryTime * primaryTime;</span><br><span class="line">    <span class="keyword">int</span> secondaryTime = time - _delay;</span><br><span class="line">    <span class="keyword">if</span> (secondaryTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> primaryVel = primaryAcc * _delay;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> secondaryAcc = (_primaryForce + _secondaryForce) / _mass;</span><br><span class="line">        result += primaryVel * secondaryTime + <span class="number">0.5</span> * secondaryAcc * secondaryTime * secondaryTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gamma</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> importantValue1 = (inputVal * quantity) + delta();</span><br><span class="line">        <span class="keyword">int</span> importantValue2 = (inputVal * quantity) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> importantValue3 = importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line">Gamma &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Account _account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> inputVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> yearToDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue3;</span><br><span class="line">        Gamma(source, inputVal, quantity, yearToDate) &#123;</span><br><span class="line">        _account = source;</span><br><span class="line">        inputVal = inputVal;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        importantValue1 = (inputVal * quantity) + _account.delta();</span><br><span class="line">        importantValue2 = (inputVal * quantity) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        importantValue3 = importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br><span class="line">    -&gt;</span><br><span class="line">    importThing() &#123;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gamma</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gamma(<span class="keyword">this</span>, inputVal, quantity, yearToDate).compute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Substitude-Algorithm（替换算法）"><a href="#Substitude-Algorithm（替换算法）" class="headerlink" title="Substitude Algorithm（替换算法）"></a>Substitude Algorithm（替换算法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"Don"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"John"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"Kent"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span> </span>&#123; </span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="string">"Don"</span>,<span class="string">"John"</span>,<span class="string">"Kent"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (candidates.contains(people[i])) </span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：搬移函数是重构理论的支柱，解耦。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *（1）检查源类中被源函数所使用的一切特性（包括字段和函数），考虑它们是否也该被搬移。</span></span><br><span class="line"><span class="comment"> *（2）检查源类的子类和超类，看看是否有该函数的其它声明。</span></span><br><span class="line"><span class="comment"> *（3）在目标类中声明这个函数。</span></span><br><span class="line"><span class="comment"> *（4）将源函数的代码复制到目标函数中，并在源函数调用后者。</span></span><br><span class="line"><span class="comment"> *（5）编译目标类</span></span><br><span class="line"><span class="comment"> *（6）决定如何从源函数正确引用目标对象</span></span><br><span class="line"><span class="comment"> *（7）修改源函数，使之成为一个纯委托函数</span></span><br><span class="line"><span class="comment"> *（8）编译，测试</span></span><br><span class="line"><span class="comment"> *（9）决定是否删除源函数，或将它当作一个委托函数保留下来。</span></span><br><span class="line"><span class="comment"> *（10）如果要移除源函数，请将源类中对源函数的所有调用，替换为目标函数的调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">overdraftCharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**f (_type.isPreminum()) &#123;</span></span><br><span class="line"><span class="comment">            double result = 10;</span></span><br><span class="line"><span class="comment">            if (_dayOverdrawn &gt; 7) result += (_dayOverdrawn - 7) * 0.85;</span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">        else return _dayOverdrawn * 1.75;*/</span></span><br><span class="line">        <span class="keyword">return</span> _type.overdraftCharge(_dayOverdrawn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">bankCharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">4.5</span>;</span><br><span class="line">        <span class="comment">// if (_dayOverdrawn &gt; 0) result += overdraftCharge();</span></span><br><span class="line">        <span class="keyword">if</span> (_dayOverdrawn &gt; <span class="number">0</span>)</span><br><span class="line">            result += _type.overdraftCharge(_dayOverdrawn);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">overdraftCharge</span><span class="params">(<span class="keyword">int</span> dayOverdrawn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPreminum()) &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (dayOverdrawn &gt; <span class="number">7</span>) result += (dayOverdrawn - <span class="number">7</span>) * <span class="number">0.85</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dayOverdrawn * <span class="number">1.75</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Move-Field-搬移字段"><a href="#Move-Field-搬移字段" class="headerlink" title="Move Field 搬移字段"></a>Move Field 搬移字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：在类之间移动状态与行为，是重构过程中必不可少的措施。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *  （1）如果字段的访问级是pulic，使用Encaspsulate Field将它封装起来</span></span><br><span class="line"><span class="comment"> *  （2）编译，测试</span></span><br><span class="line"><span class="comment"> *  （3）在目标类中建立与源字段相同的字段，并同时建立相应的设值/取值函数。</span></span><br><span class="line"><span class="comment"> *  （4）编译目标类。</span></span><br><span class="line"><span class="comment"> *  （5）决定如何在源对象中引用目标对象</span></span><br><span class="line"><span class="comment"> *  （6）删除源字段。</span></span><br><span class="line"><span class="comment"> *  （7）编译，测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountType _type;</span><br><span class="line">    <span class="comment">// private double _interestRate;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">interestForAmount_days</span><span class="params">(<span class="keyword">double</span> amount, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInterestRate() * amount * days / <span class="number">365</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInterestRate</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        _type.setInterestRate(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getInterestRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _type.getInterestRate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> _interestRate;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setInterestRate</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        _interestRate = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getInterestRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _interestRate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：单类做一件事情</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *   （1）决定如何分解类所负的责任</span></span><br><span class="line"><span class="comment"> *   （2）建立一个新类，用以表现从旧类中分离出来的责任</span></span><br><span class="line"><span class="comment"> *   （3）建立“从旧类访问新类”的连接关系</span></span><br><span class="line"><span class="comment"> *   （4）对于你想搬移的每一个字段，运用Move Field搬移</span></span><br><span class="line"><span class="comment"> *   （5）每次搬移后，重新编译</span></span><br><span class="line"><span class="comment"> *   （6）将必要函数搬移至新类，从低层函数（被其他函数调用次数&gt;调用其他函数）到高层函数</span></span><br><span class="line"><span class="comment"> *   （7）每次搬移后，重新编译</span></span><br><span class="line"><span class="comment"> *   （8）检查，精简每个类的接口。</span></span><br><span class="line"><span class="comment"> *   （9）决定是否公开新类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String _name;</span><br><span class="line">    TelephoneNumber _officeTelephone;</span><br><span class="line">    String _officeAreaCode;</span><br><span class="line">    String _officeNumber;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">    <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TelephoneNumber <span class="title">getOfficeTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">    String _areaCode;</span><br><span class="line">    String _number;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">            <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + _areaCode + <span class="string">")"</span> + _number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String _name;</span><br><span class="line">    TelephoneNumber _officeTelephone;</span><br><span class="line">    String _officeAreaCode;</span><br><span class="line">    String _officeNumber;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">    <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TelephoneNumber <span class="title">getOfficeTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">        String _areaCode;</span><br><span class="line">        String _number;</span><br><span class="line">        <span class="comment">// setter、getter</span></span><br><span class="line">                <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"("</span> + _areaCode + <span class="string">")"</span> + _number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机："封装"即使不是对象的最关键特征，也是最关键特征之一。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *    （1）对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数。</span></span><br><span class="line"><span class="comment"> *    （2）调整客户</span></span><br><span class="line"><span class="comment"> *    （3）每次调整后，编译并测试</span></span><br><span class="line"><span class="comment"> *    （4）如果将来不再有任何客户需要取用Delegate，即可移除服务类</span></span><br><span class="line"><span class="comment"> *    （5）编译、测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Department _department;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    String _chargeCode;</span><br><span class="line">    Person _manager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Person manager)</span> </span>&#123;</span><br><span class="line">        _manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">-&gt; manager = john.getDepartment().getManager();</span><br><span class="line">    -&gt; manager = john.getManager();</span><br></pre></td></tr></table></figure>
<h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Department _department;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    String _chargeCode;</span><br><span class="line">    Person _manager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Person manager)</span> </span>&#123;</span><br><span class="line">        _manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Indroduce-Foreign-Method（引入外加函数）"><a href="#Indroduce-Foreign-Method（引入外加函数）" class="headerlink" title="Indroduce Foreign Method（引入外加函数）"></a>Indroduce Foreign Method（引入外加函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previous.getYear(), </span><br><span class="line">    previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Indroduce-Local-Extension（引入本地扩展）"><a href="#Indroduce-Local-Extension（引入本地扩展）" class="headerlink" title="Indroduce Local Extension（引入本地扩展）"></a>Indroduce Local Extension（引入本地扩展）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：很遗憾，类的作者无法预知未来，他们常常没能为你预先准备一些有用的函数。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *（1）建立一个扩展类，将它作为原始类的子类或包装类。</span></span><br><span class="line"><span class="comment"> *（2）在扩展中加入转型构造函数。</span></span><br><span class="line"><span class="comment"> *（3）在扩展类中加入新特性</span></span><br><span class="line"><span class="comment"> *（4）根据需要，将原对象替换为扩展对象</span></span><br><span class="line"><span class="comment"> *（5）将针对原始类定义的所有外加函数搬移到扩展中</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>齐白石的故事</title>
    <url>/2019/10/29/%E9%BD%90%E7%99%BD%E7%9F%B3%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>齐白石年少的时候家庭并不富裕，所以他16岁开始拜师学习雕花木工，给家里面赚钱。齐白石学手艺，不仅勤动手，更善动脑。他发现，师父雕的花，以及其他木工做的，翻来覆去就几个固定的式样，什么“麒麟送子”、“状元及第”，没什么新意。于是他就搞了些创新，把国画里其他的一些元素如虫草、花鸟等迁移到木雕里。起初只是试探，没想到雕出来的这些新品，颇被大家欢迎。<br>这种经历让他对国画有了强烈的兴趣，但没有人教他画，而他能看的国画画册也是比较初级的，没有什么好的资料可看，所以他一直无法真正入门学画。<br>直到二十岁的一天，齐白石在一个主顾家里干活时，发现了一套《芥子园画谱》。<br>《芥子园画谱》是一套非常经典的国画教科书。一个想学画的人看到一套画谱就如同一个想学武的人看到了一套武功秘籍，如获至宝。可是这套书是别人的，在当时又很稀少珍贵，他没法从别处得到。于是只能向书主借来，用薄竹纸覆在书页上，描红一般把原画一笔一笔勾描在竹纸上。就这样勾画了足有半年，画成十六册，才悉数描完，然后才把原书交还。<br>接下来的五年，齐白石靠这套勾描出来的《芥子园画谱》做木雕，并且闲时也反反复复拿出来临摹，勤学苦练，他画画的底子就这么打了下来。<br>后来齐白石的画在当地出了名，引来名画家收他为徒。有了专业指导后，齐白石的画技更上一层楼，终于成了一代国画大家。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>象棋的故事</title>
    <url>/2019/10/29/%E8%B1%A1%E6%A3%8B%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>茨威格曾经讲过一个象棋的故事：<br>在纳粹的集中营里，一个知识分子被关在小房间里。墙壁是白的，床单被套是白的，他也不知道时间，不知道白天和黑夜。最受折磨的不是拷打，而是没有书看了，对于一个潜心做研究的知识分子，相当于天天让他饿肚子。<br>在一次审讯的时候，他看到一本书，于是冒着生命危险偷来回去。<br>对于他来说最好的书应该是一本可以反复看很多次的，比如数学这类的，结果掏出来一看，是一本象棋的棋谱。<br>他非常的失望，但是没有办法，但这也总比没有好啊！<br>因为书很薄，于是他强迫自己每天只能看一页，但是再怎么省着看，结果还是很快看完了。<br>那怎么办呢？<br>他尝试在大脑中还原书上每一页的棋局，结果几个月下来，这本书还是又读完一遍。<br>没得读了，那怎么办？<br>他开始在脑子里自己和自己下象棋。<br>想想看，两个自我都知道对方要出什么招，这其实很难下的，但是为保持大脑的运转让自己不疯掉，他开始每天在脑子里自己和自己下棋。<br>后来，等他被逃出生天，他并不知道自己的象棋水平怎么样。<br>直到有一次他在轮船上遇到一个象棋世界冠军，他以前也没有怎么下过象棋，于是抱着开玩笑赌两把的心态开始向世界冠军讨教切磋。<br>于是结果3局下来，世界冠军都输了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>泥瓦匠的故事</title>
    <url>/2019/10/29/%E6%B3%A5%E7%93%A6%E5%8C%A0%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>讲的是一个记者去采访三个正在修教堂的泥瓦匠，问他们在干什么。<br>一个说，没看我正在忙着吗，我在干活啊；<br>第二个说，我在工作啊，我们在修一座教堂；<br>第三个说，我在建造上帝的房子，等完成了，我就可以很自豪得每周带着我的孩子来礼拜了。<br>这三个人有什么区别？<br>第一个是谋生；<br>第二个是工作；<br>第三个也是在工作，但是他找到了做这份工作的“终极目标”。<br>三个人的价值观有高低对错吗？<br>没有。<br>但你想一下，但当出现没有很多的钱，太阳太大，失败返工的时候，你觉得哪种人会坚持下来呢？<br>当我们学习，工作，做事情都依赖于制度和奖励的时候，哪一种人更容易坚持呢？<br>显然我们还需要另一种智慧。<br>不过坏消息是，这种智慧，我们在时间稀缺和循规蹈矩中，慢慢忘掉了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>管道的故事</title>
    <url>/2019/10/29/%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>故事讲的是一个村里的两个年轻人。<br>这个村常年缺水，于是这两个年轻人有了一个赚钱的机会，就是通过给村里人去很远的地方提水来赚钱。<br>这是一个很不错的生意，两个年轻人靠这个生活一点问题都没有。<br>有一天青年A就觉得这样做不行，于是他开始想，如果建一条管道，将水源处的水引过来，以后就再也不用靠自己的体力来挣钱了。于是青年A一边用一半的时间继续提水赚钱，另一半的时间用赚到的钱来铺设管道。<br>因为两头都要忙，还要把钱投入到铺设管子的的事情上，所以青年A过的很辛苦；<br>青年B觉得这事儿不靠谱，他觉得每天靠自己的提水可以赚到足够多的钱了，于是他继续每天赶着提桶取水的活，收入不错，下班还有时间花钱消遣，生活挺不错。<br>直到有一天，青年A的水管建成了。<br>水源从管子里自动流出来的时候，青年A就不用再花时间花体力自己去提水赚钱了，从那天起他就算在睡觉，也有源源不断的收入。<br>而青年B因为常年的劳动，身体越来越差了，提水的量也开始减少了，收入就越来越少了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>遗失的智慧</title>
    <url>/2019/10/29/%E9%81%97%E5%A4%B1%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<p>A是医院的清洁工，他每天的工作就是打扫自己负责的楼层中各个病人床位的卫生。有一个床位的病人是一个年轻人，因为被袭击受伤，已经在床上昏迷6个月了，这个期间一直都是他的父亲在看护。<br>有一天他去给这个病人的房间做清洁的时候，他的父亲刚好出去抽烟了。等他打扫完出去，他的父亲在走廊遇到他，很咆哮地质问他，为什么没有打扫他儿子的房间。事实你已经知道了，A已经打扫过了房间，但是病人的父亲认为没有。<br>如果是你是A，你会怎么办？</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>github常用命令</title>
    <url>/2019/10/29/github%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="github提交一个项目"><a href="#github提交一个项目" class="headerlink" title="github提交一个项目"></a>github提交一个项目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 1.github添加新仓库jucdemo2</span><br><span class="line"># 2.添加客户端id_ras.pub秘钥（C:\Users\Czz\.ssh\id_ras.pub）</span><br><span class="line"># 3.添加远程仓库：</span><br><span class="line"># 初始化本地仓库，并提交到本地仓库</span><br><span class="line">$ cd D:\ideawk\jucdemo</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'first commit'</span></span><br><span class="line"># 关联远程仓库并推送项目</span><br><span class="line">$ git remote add origin git<span class="meta">@github</span>.com:line007/jucdemo2.git</span><br><span class="line"># 第一次推送</span><br><span class="line">$ git push -u origin master</span><br><span class="line"># 非第一次推送</span><br><span class="line">$  git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="git-checkout远程分支、标签"><a href="#git-checkout远程分支、标签" class="headerlink" title="git checkout远程分支、标签"></a>git checkout远程分支、标签</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命令：git clone --branch [tags标签] [git地址] </span><br><span class="line">	或者 git clone --b [tags标签] [git地址]</span><br><span class="line">例如：git clone -b <span class="number">1.4</span><span class="number">.1</span> https:<span class="comment">//github.com/jumpserver/coco.git</span></span><br><span class="line"></span><br><span class="line">$ git clone -b v7<span class="number">.4</span><span class="number">.2</span> https:<span class="comment">//github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/10/29/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ cd hexo网站根据目录</span><br><span class="line"></span><br><span class="line"># 1.新建文章（测试文章）</span><br><span class="line">$ hexo <span class="keyword">new</span> 测试文章</span><br><span class="line"></span><br><span class="line"># 2.新建草稿（测试草稿）</span><br><span class="line">$ hexo <span class="keyword">new</span> draft 测试草稿</span><br><span class="line">$ hexo s --draft</span><br><span class="line"></span><br><span class="line"># 3.发布草稿（测试草稿）</span><br><span class="line">$ hexo publish 测试草稿</span><br><span class="line"></span><br><span class="line"># 4.新建类目（categories）</span><br><span class="line">$ hexo <span class="keyword">new</span> page categories</span><br><span class="line"></span><br><span class="line"># 5.引入分类（上面已经新建了类目-categories）</span><br><span class="line">## 5.1 打开 hexo根目录/source/categories/index.md</span><br><span class="line">$ vi index.md # 编辑文件index.md，新增以下内容</span><br><span class="line">type: <span class="string">"categories"</span></span><br><span class="line"></span><br><span class="line">## 5.2 在需要添加的文章中加入分类属性，如xx.md</span><br><span class="line">---</span><br><span class="line">title: github如何精确搜索项目</span><br><span class="line">date: <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">17</span>:<span class="number">16</span>:<span class="number">28</span></span><br><span class="line">categories: </span><br><span class="line">- 工具</span><br><span class="line">tags:</span><br><span class="line">- github</span><br><span class="line">- 常用命令</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 6.引入标签（如果没有创建分类tags，请先按照步骤4创建分类tags）</span><br><span class="line">打开 hexo根目录/source/tags/index.md</span><br><span class="line">$ vi index.md # 编辑文件index.md，新增以下内容</span><br><span class="line">type: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>github如何精确搜索项目</title>
    <url>/2019/10/28/github%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E6%90%9C%E7%B4%A2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">watch：会持续收到项目的动态</span><br><span class="line">fork：复制某个项目到自己的仓库</span><br><span class="line">star：可以理解为点赞</span><br><span class="line">clone：将项目下载到本地</span><br><span class="line">follow：关注你感兴趣的作者，会收到他们的动态</span><br></pre></td></tr></table></figure>

<h2 id="in关键词限制搜索范围"><a href="#in关键词限制搜索范围" class="headerlink" title="in关键词限制搜索范围"></a>in关键词限制搜索范围</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    xxx in:name 项目名包含xxx的</span><br><span class="line">    xxx in:description 项目描述包含xxx的</span><br><span class="line">    xxx in:readme 项目</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    搜索项目名或者readme中包含秒杀的项目</span><br><span class="line">        seckill in:name,readme</span><br></pre></td></tr></table></figure>        

<h2 id="stars或fork数量关键词去查找"><a href="#stars或fork数量关键词去查找" class="headerlink" title="stars或fork数量关键词去查找"></a>stars或fork数量关键词去查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    :&gt; 或者 :&gt;=</span><br><span class="line">    数字<span class="number">1.</span>.数字<span class="number">2</span></span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    查找star数大于等于<span class="number">5000</span>的springboot项目</span><br><span class="line">        springboot stars:&gt;=<span class="number">5000</span></span><br><span class="line">    查找fork数大于<span class="number">500</span>的springcloud项目</span><br><span class="line">        springcloud forks:&gt;<span class="number">500</span></span><br><span class="line">    查找fork在<span class="number">100</span>到<span class="number">200</span>之间并且stars数在<span class="number">80</span>到<span class="number">100</span>之间的springboot项目</span><br><span class="line">        springboot forks:<span class="number">100.</span><span class="number">.200</span> stars:<span class="number">80.</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>        

<h2 id="awesome加强搜索"><a href="#awesome加强搜索" class="headerlink" title="awesome加强搜索"></a>awesome加强搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    awesome 关键字</span><br><span class="line">        awesome 系列一般是用来收集学习、工具、书籍类相关的项目</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    搜索优秀的redis相关的项目，包括框架、教程等</span><br><span class="line">        awesome redis</span><br></pre></td></tr></table></figure>        

<h2 id="高亮显示某一行代码"><a href="#高亮显示某一行代码" class="headerlink" title="高亮显示某一行代码"></a>高亮显示某一行代码</h2><blockquote>
<p>地址后面紧跟#L数字<br>地址后面紧跟#L数字1-数字2                        </p>
</blockquote>
<h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><blockquote>
<p>按英文t<br><a href="https://help.github.com/en/articles/keyboard-shortcuts" target="_blank" rel="noopener" title="更多操作">更多快捷操作</a> .</p>
</blockquote>
<h2 id="搜索某个地区内的牛逼人物"><a href="#搜索某个地区内的牛逼人物" class="headerlink" title="搜索某个地区内的牛逼人物"></a>搜索某个地区内的牛逼人物</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    location：地区</span><br><span class="line">    language：语言</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    location:guangzhou language:java</span><br></pre></td></tr></table></figure>    
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决windows10启动内存过高</title>
    <url>/2019/10/28/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3windows10%E5%90%AF%E5%8A%A8%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98/</url>
    <content><![CDATA[<p>1.以管理员的方式运行程序 PowerShell<br><img src="/images/20191028001.png" alt="Alt text"><br>2.执行命令：<br><img src="/images/20191028002.png" alt="Alt text"><br>3.关闭缓存服务<br><img src="/images/20191028003.png" alt="Alt text"><br>4.禁用缓存计划<br><img src="/images/20191028004.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>jdk8基本用法</title>
    <url>/2019/10/28/jdk8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>该文章主要是描述了jdk8函数式接口编程的基本用法，主要包括内置四大函数式接口、函数式接口应用案例及Stream集合流式操作。以下内容都是jdk8常用的语法demo，针对每一个点都有一个小case测试。</p>
<h2 id="内置四大函数式接口"><a href="#内置四大函数式接口" class="headerlink" title="内置四大函数式接口"></a>内置四大函数式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Java四大内置函数式接口</span></span><br><span class="line"><span class="comment"> *  Consumer&lt;T&gt;：消费型接口</span></span><br><span class="line"><span class="comment"> *      void accept(T t);</span></span><br><span class="line"><span class="comment"> *  Suppler&lt;T&gt;：供给型接口</span></span><br><span class="line"><span class="comment"> *      T get();</span></span><br><span class="line"><span class="comment"> *  Function&lt;T, R&gt;：函数型接口</span></span><br><span class="line"><span class="comment"> *      R apply(T t);</span></span><br><span class="line"><span class="comment"> *  Predicate&lt;T&gt;：断言型接口</span></span><br><span class="line"><span class="comment"> *      boolean test(T t);</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKFuncInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Consumer&lt;T&gt;：消费型接口</span></span><br><span class="line">        printConsumer(<span class="string">"abcd"</span>, (x) -&gt; System.out.println(x));</span><br><span class="line">        <span class="comment">// Suppler&lt;T&gt;：供给型接口；</span></span><br><span class="line">        <span class="comment">// 案例：产生指定个数的整数，并放入集合中</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">        getNumList(num, () -&gt; <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>)).stream().forEach(System.out::println);</span><br><span class="line">        <span class="comment">// Function&lt;T, R&gt;：函数型接口；</span></span><br><span class="line">        <span class="comment">// 案例：字符串处理（转大小写、截取等）</span></span><br><span class="line">        System.out.println(strHandler(<span class="string">"abcdefg"</span>, str -&gt; str.toUpperCase()));</span><br><span class="line">        System.out.println(strHandler(<span class="string">"abcdefg"</span>, str -&gt; str.substring(<span class="number">0</span>,<span class="number">3</span>)));</span><br><span class="line">        <span class="comment">// Predicate&lt;T&gt;：断言型接口（见MyFuncInterfaceDemo）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConsumer</span><span class="params">(String str, Consumer&lt;String&gt; func)</span> </span>&#123;</span><br><span class="line">        func.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            list.add(sup.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数式接口案例"><a href="#函数式接口案例" class="headerlink" title="函数式接口案例"></a>函数式接口案例</h2><h3 id="案例需要的初始化数据"><a href="#案例需要的初始化数据" class="headerlink" title="案例需要的初始化数据"></a>案例需要的初始化数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; list = Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="number">2500</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"lisi"</span>, <span class="number">25</span>, <span class="number">4000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"wangwu"</span>, <span class="number">35</span>, <span class="number">8000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"maliu"</span>, <span class="number">45</span>, <span class="number">9000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"tianqi"</span>, <span class="number">50</span>, <span class="number">8000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"smis"</span>, <span class="number">26</span>, <span class="number">3000</span>));</span><br></pre></td></tr></table></figure>
<h3 id="接口引用"><a href="#接口引用" class="headerlink" title="接口引用"></a>接口引用</h3><h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_normal</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmpByAge(list);</span><br><span class="line">    System.out.println(<span class="string">"----------大于25岁的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">    newList = filterEmpBySalary(newList);</span><br><span class="line">    System.out.println(<span class="string">"----------薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_strategy</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, <span class="keyword">new</span> AgePredicateStrategy());</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">    newList = filterEmployee(newList, <span class="keyword">new</span> SalaryPredicateStrategy());</span><br><span class="line">    System.out.println(<span class="string">"----------薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_inner_class</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_lambda</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*filterEmployee(list, (Employee e) -&gt; &#123;return e.getAge() &gt; 25 &amp;&amp; e.getSalary() &gt; 5000;&#125;);</span></span><br><span class="line"><span class="comment">    filterEmployee(list, (Employee e) -&gt; e.getAge() &gt; 25 &amp;&amp; e.getSalary() &gt; 5000);*/</span></span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_stream01</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>).stream()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_stream02</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>).stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="对象-实例方法"><a href="#对象-实例方法" class="headerlink" title="对象::实例方法"></a>对象::实例方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_instance_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintStream ps1 = System.out;</span><br><span class="line">    Consumer&lt;String&gt; str1 = (x) -&gt; ps1.println(x);</span><br><span class="line">    str1.accept(<span class="string">"abc1"</span>);</span><br><span class="line">    PrintStream ps2 = System.out;</span><br><span class="line">    Consumer&lt;String&gt; str2 = ps2::println;</span><br><span class="line">    str2.accept(<span class="string">"abc2"</span>);</span><br><span class="line">    Consumer&lt;String&gt; str3 = System.out::println;</span><br><span class="line">    str3.accept(<span class="string">"abc3"</span>);</span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">    Supplier&lt;String&gt; funcName = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(funcName.get());</span><br><span class="line">    Supplier&lt;Integer&gt; funcAge = emp::getAge;</span><br><span class="line">    System.out.println(funcAge.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类-静态方法名"><a href="#类-静态方法名" class="headerlink" title="类::静态方法名"></a>类::静态方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_static_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(com.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compareTo;</span><br><span class="line">    System.out.println(com2.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类-实例方法名"><a href="#类-实例方法名" class="headerlink" title="类::实例方法名"></a>类::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_normal_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器引用（实例名-new）"><a href="#构造器引用（实例名-new）" class="headerlink" title="构造器引用（实例名::new）"></a>构造器引用（实例名::new）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_constructor_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt; funcEmp = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">    System.out.println(funcEmp.get());</span><br><span class="line">    Supplier&lt;Employee&gt; funcEmp2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(funcEmp2.get());</span><br><span class="line">    <span class="comment">// 指定调用构造方法</span></span><br><span class="line">    Function&lt;Integer, Employee&gt; funcEmpAge = (x) -&gt; <span class="keyword">new</span> Employee(x);</span><br><span class="line">    System.out.println(funcEmpAge.apply(<span class="number">101</span>));</span><br><span class="line">    Function&lt;Integer, Employee&gt; funcEmpAge2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(funcEmpAge2.apply(<span class="number">102</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_array_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; funcArray = (x) -&gt; <span class="keyword">new</span> String[x];</span><br><span class="line">    String[] strs = funcArray.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(strs.length);</span><br><span class="line">    Function&lt;Integer, String[]&gt; funcArray2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] strs2 = funcArray.apply(<span class="number">20</span>);</span><br><span class="line">    System.out.println(strs2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Stream常规操作"><a href="#Stream常规操作" class="headerlink" title="Stream常规操作"></a>Stream常规操作</h2><h3 id="创建Stream的几种方式"><a href="#创建Stream的几种方式" class="headerlink" title="创建Stream的几种方式"></a>创建Stream的几种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_create_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().stream();</span><br><span class="line">    Stream&lt;String&gt; stream2 = Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line">    Stream&lt;String&gt; stream3 = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    Stream&lt;Integer&gt; stream4 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>); <span class="comment">// 无限流</span></span><br><span class="line">    stream4.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    Stream.generate(() -&gt; Math.random())</span><br><span class="line">            .limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流转集合的几种方式"><a href="#流转集合的几种方式" class="headerlink" title="流转集合的几种方式"></a>流转集合的几种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_collect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = employees.stream().map(Employee::getName).collect(Collectors.toList());</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">    Set&lt;String&gt; set = employees.stream().map(Employee::getName).collect(Collectors.toSet());</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">    HashSet&lt;String&gt; hashSet = employees.stream().map(Employee::getName).collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">    hashSet.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><h4 id="总数、平均值、最小值"><a href="#总数、平均值、最小值" class="headerlink" title="总数、平均值、最小值"></a>总数、平均值、最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_count1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"总数："</span> + employees.stream().collect(Collectors.counting()));</span><br><span class="line">    System.out.println(<span class="string">"平均值："</span> + employees.stream().collect(Collectors.averagingDouble(Employee::getSalary)));</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().collect(Collectors.minBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary()))).get()); <span class="comment">// 已过时</span></span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().min(Comparator.comparing(Employee::getSalary)).get());</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().min(Comparator.comparing(Employee::getSalary).thenComparing(Employee::getAge)).get());</span><br><span class="line">    System.out.println(<span class="string">"------------另一种方式-----------"</span>);</span><br><span class="line">    DoubleSummaryStatistics collect = employees.stream().collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(<span class="string">"总数："</span> + collect.getCount());</span><br><span class="line">    System.out.println(<span class="string">"平均值："</span> + collect.getAverage());</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + collect.getMin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_count2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 归约</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    Integer sum = list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    Integer amount1 = employees.stream().map(Employee::getSalary).reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(amount1);</span><br><span class="line">    Integer amount2 = employees.stream().map(Employee::getSalary).reduce(Integer::sum).get();</span><br><span class="line">    System.out.println(amount2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_append_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = employees.stream().map(Employee::getName).collect(Collectors.joining(<span class="string">","</span>,<span class="string">"("</span>,<span class="string">")"</span>));</span><br><span class="line">    System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组、分区"><a href="#分组、分区" class="headerlink" title="分组、分区"></a>分组、分区</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_groupby_partitioningBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按员工类型分组</span></span><br><span class="line">    Map&lt;Employee.EmployeeType, Long&gt; map1 = employees.stream().collect(Collectors.groupingBy(Employee::getEmployeeType, Collectors.counting()));</span><br><span class="line">    System.out.println(map1);</span><br><span class="line">    <span class="comment">// 按员工类型 + 薪资分组</span></span><br><span class="line">    Map&lt;Employee.EmployeeType, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map2 = employees.stream().collect(Collectors.groupingBy(Employee::getEmployeeType, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSalary() &gt;= <span class="number">8000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"高收入"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSalary() &gt;= <span class="number">4000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"中收入"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"解决温饱"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)));</span><br><span class="line">    System.out.println(map2);</span><br><span class="line">    <span class="comment">// 按薪资分区，&gt;=8000 一个区，另外一个区</span></span><br><span class="line">    Map&lt;Boolean, List&lt;Employee&gt;&gt; map3 = employees.stream().collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt;= <span class="number">8000</span>));</span><br><span class="line">    System.out.println(map3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk8语法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>该文章主要是学习数据结构（链表、栈、哈希表、树、图）和算法（排序算法、程序员常用10大算法），针对每个结构都有一个小case测试验证。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>一种数据结构，包括单向链表、双向链表、单向环形链表</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 单链表demo</span></span><br><span class="line"><span class="comment"> *  1.链表添加</span></span><br><span class="line"><span class="comment"> *      1.1 普通添加</span></span><br><span class="line"><span class="comment"> *      1.2 顺序添加</span></span><br><span class="line"><span class="comment"> *  2.遍历</span></span><br><span class="line"><span class="comment"> *  3.删除</span></span><br><span class="line"><span class="comment"> *  4.修改</span></span><br><span class="line"><span class="comment"> *  5.查找倒数第k个元素</span></span><br><span class="line"><span class="comment"> *  6.链表反转</span></span><br><span class="line"><span class="comment"> *      6.1 数组方式反转</span></span><br><span class="line"><span class="comment"> *      6.2 栈的方式反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 添加操作</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">/*// 1.1 正常添加</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero4);*/</span></span><br><span class="line">        <span class="comment">// 1.2 顺序添加</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        <span class="comment">// 2.遍历</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------------"</span>);</span><br><span class="line">        <span class="comment">// 3.修改</span></span><br><span class="line">        HeroNode editHero = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨2"</span>);</span><br><span class="line">        singleLinkedList.update(editHero);</span><br><span class="line">        System.out.println(<span class="string">"修改后-----------------------"</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">// 4.删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除后-----------------------"</span>);</span><br><span class="line">        <span class="keyword">int</span> no = <span class="number">3</span>;</span><br><span class="line">        singleLinkedList.del(no);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">// 5.查找倒数第k个元素</span></span><br><span class="line">        HeroNode head = singleLinkedList.getHead();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>; <span class="comment">// 倒数第1个</span></span><br><span class="line">        HeroNode lastIndexNode = singleLinkedList.findLastIndexNode(head, index);</span><br><span class="line">        System.out.println(<span class="string">"倒数第"</span>+index+<span class="string">"个元素是：\n"</span>+lastIndexNode);</span><br><span class="line">        <span class="comment">// 6.链表反转</span></span><br><span class="line">        System.out.println(<span class="string">"反转后--------------"</span>);</span><br><span class="line"><span class="comment">//        singleLinkedList.reverseByArray(head);</span></span><br><span class="line">        singleLinkedList.reverseByStack(head);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 双向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 添加操作</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        <span class="comment">// 1.1 正常添加</span></span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">// 3.修改</span></span><br><span class="line">        HeroNode editHero = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨2"</span>);</span><br><span class="line">        doubleLinkedList.update(editHero);</span><br><span class="line">        System.out.println(<span class="string">"修改后-----------------------"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">// 4.删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除后-----------------------"</span>);</span><br><span class="line">        <span class="keyword">int</span> no = <span class="number">3</span>;</span><br><span class="line">        doubleLinkedList.del(no);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向环形链表（约瑟夫问题）"><a href="#单向环形链表（约瑟夫问题）" class="headerlink" title="单向环形链表（约瑟夫问题）"></a>单向环形链表（约瑟夫问题）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 单向环形列表</span></span><br><span class="line"><span class="comment"> * 1.约瑟夫问题：</span></span><br><span class="line"><span class="comment"> *  设编号为1，2，...n的n个人围坐一圈，约定编号为k(1&lt;=k&lt;=n)的人</span></span><br><span class="line"><span class="comment"> *  从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，</span></span><br><span class="line"><span class="comment"> *  依次类推，直到所有人出列为止，由此产生一个环形队列</span></span><br><span class="line"><span class="comment"> * 2.假设问题：</span></span><br><span class="line"><span class="comment"> *  n = 5 有5个人</span></span><br><span class="line"><span class="comment"> *  k = 1 从第一个人开始</span></span><br><span class="line"><span class="comment"> *  m = 2 每次数2下</span></span><br><span class="line"><span class="comment"> * 3.思路分析：</span></span><br><span class="line"><span class="comment"> * （1）定义一个辅助变量helper，指向最后一个节点</span></span><br><span class="line"><span class="comment"> * （2）当小孩报数时，first、helper同时移动 m-1 次（每次是从自己开始数）</span></span><br><span class="line"><span class="comment"> * （3）这时，可以将first指向的小孩节点出圈</span></span><br><span class="line"><span class="comment"> *      first = first.next</span></span><br><span class="line"><span class="comment"> *      helper.next = first</span></span><br><span class="line"><span class="comment"> *      原来的first节点没有任何引用，就会被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 数据模拟栈</span></span><br><span class="line"><span class="comment"> * 1.使用数组模拟栈 arr = new Array[maxSize]</span></span><br><span class="line"><span class="comment"> * 2.定义一个top表示顶</span></span><br><span class="line"><span class="comment"> * 3.入栈 arr[++top] = data</span></span><br><span class="line"><span class="comment"> * 4.出栈 return arr[--top]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack arrayStack = <span class="keyword">new</span> ArrayStack(<span class="number">3</span>);</span><br><span class="line">        arrayStack.push(<span class="number">1</span>);</span><br><span class="line">        arrayStack.push(<span class="number">2</span>);</span><br><span class="line">        arrayStack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现统合计数器"><a href="#实现统合计数器" class="headerlink" title="实现统合计数器"></a>实现统合计数器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 波兰计算器</span></span><br><span class="line"><span class="comment"> *  suffixExpression=(30+4)*5-6 =&gt; 30 4 + 5 * 6 - =&gt; 164</span></span><br><span class="line"><span class="comment"> * 1.将suffixExpression放入ArrayList中 [30, 4, +, 5, *, 6, -]</span></span><br><span class="line"><span class="comment"> * 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 中缀转后缀表达式</span></span><br><span class="line"><span class="comment"> * 1.初始化两个栈：运算符栈s1和存储结果栈s2</span></span><br><span class="line"><span class="comment"> * 2.从左至右扫描中缀表达式</span></span><br><span class="line"><span class="comment"> * 3.遇到数字时，将其压入s2</span></span><br><span class="line"><span class="comment"> * 4.遇到运算符时，比较其与s1栈顶运算符的优先级；</span></span><br><span class="line"><span class="comment"> * （1）如果s1为空，或栈顶运算符为左括号“（”，则直接将些运算符入栈s1；</span></span><br><span class="line"><span class="comment"> * （2）否则，若优先级比栈顶优先级高，也将运算符压入s1</span></span><br><span class="line"><span class="comment"> * （3）否则，将s1栈顶的运算符弹出并压入s2中，再次转到（4.1）与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="comment"> * 5.遇到括号时：</span></span><br><span class="line"><span class="comment"> * （1）如果是“（”，则直接压入s1</span></span><br><span class="line"><span class="comment"> * （2）如果是“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到“（”为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="comment"> * 6.重复步骤2-5，一直到表达式的最右边</span></span><br><span class="line"><span class="comment"> * 7.将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line"><span class="comment"> * 8.依次弹出s2中的元素并输出，结果的逆序即为表达式对应的后缀表达式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中缀转后缀表达式</span></span><br><span class="line">        <span class="comment">/*String expression = "(30+4)*5-6"; // 30 4 + 5 * 6 - =&gt; 164</span></span><br><span class="line"><span class="comment">        expression = "4*5-8+60+8/2"; // 4 5 * 8 - 60 + 8 2 / + =&gt; 76</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; list = infixToSuffixExpression(expression);</span></span><br><span class="line"><span class="comment">        System.out.println("后缀表达式：" + list);</span></span><br><span class="line"><span class="comment">        int res = calculate(list);</span></span><br><span class="line"><span class="comment">        System.out.println("res=" + res);*/</span></span><br><span class="line">        <span class="comment">// 长+2x（宽+高）&gt;100cm =&gt; (%s+%s*(%s+%s))&gt;%s</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">10</span>;</span><br><span class="line">        String expression = String.format(<span class="string">"(%s+2*(%s+%s))&gt;%s"</span>, length, width, height, <span class="number">100</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>, expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">// 长&gt;100CM 或者 宽&gt;100cm</span></span><br><span class="line">        length = <span class="number">120</span>;</span><br><span class="line">        width = <span class="number">77</span>;</span><br><span class="line">        expression = String.format(<span class="string">"%s&gt;%s|%s&gt;%s"</span>, length, <span class="number">100</span>, width, <span class="number">100</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>,expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">// 重量&gt;100kg</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">100.75</span>;</span><br><span class="line">        expression = String.format(<span class="string">"%s&gt;%s"</span>, weight, <span class="number">100.75</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>, expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">/*System.out.println(1|0|0|0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(1|0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(0|0); // 0</span></span><br><span class="line"><span class="comment">        System.out.println(1&amp;1&amp;0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(1&amp;0); // 0</span></span><br><span class="line"><span class="comment">        System.out.println(0&amp;0); // 0*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="打印、阶乘问题"><a href="#打印、阶乘问题" class="headerlink" title="打印、阶乘问题"></a>打印、阶乘问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 打印问题</span></span><br><span class="line"><span class="comment"> * （1）打印</span></span><br><span class="line"><span class="comment"> * （2）阶乘</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionPrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印问题</span></span><br><span class="line">        test1(<span class="number">4</span>); <span class="comment">// 2 3 4</span></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        test2(<span class="number">4</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 阶乘 4x3x2x1</span></span><br><span class="line">        System.out.println(factorial(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test1(n -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test2(n -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 迷宫问题</span></span><br><span class="line"><span class="comment"> * 1.初始化一个8行7列的矩阵 map[8][7]</span></span><br><span class="line"><span class="comment"> * 2.假设：</span></span><br><span class="line"><span class="comment"> * （1）三种类型：0-还没有走,1-档板,2-可以走（已走）,3-走不通</span></span><br><span class="line"><span class="comment"> * （2）策略：下-》右-》下-》左</span></span><br><span class="line"><span class="comment"> * （3）初始值：周围都是1</span></span><br><span class="line"><span class="comment"> * 3.过程分析：</span></span><br><span class="line"><span class="comment"> * （1）已经找到（确定找到的条件：第7行6列即为找到 =》 [6,5]=2）</span></span><br><span class="line"><span class="comment"> * （2）还没有找到按策略去找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MingGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始化一个8行7列的矩阵arr[8][7]</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 2.初始值：周围都是1</span></span><br><span class="line">        <span class="comment">// 第1行和第8行设置档板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第1列和第7列设置档板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出矩阵</span></span><br><span class="line">        print(map);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 设置档板 [3,1]=1,[3,2]=1</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        print(map);</span><br><span class="line">        <span class="comment">// 策略：下-》右-》上-》左</span></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从[1,1]这个位置开始</span></span><br><span class="line">        System.out.println(<span class="string">"策略:下-》右-》上-》左 =&gt;"</span>);</span><br><span class="line">        print(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 8皇后问题</span></span><br><span class="line"><span class="comment"> * 1.是什么？</span></span><br><span class="line"><span class="comment"> *  8x8的矩阵，任意两个位置不能处于同一行、同一列或同一斜线，能找出多少种解法，这就是8皇后问题</span></span><br><span class="line"><span class="comment"> * 2.思路分析</span></span><br><span class="line"><span class="comment"> * （1）第一个皇后放第一行第一列[0,0]</span></span><br><span class="line"><span class="comment"> * （2）第二个皇后放第二行第一列[1,0]...直到判断ok，</span></span><br><span class="line"><span class="comment"> *      如果不ok，继续放在第二列、第三列、依次把所有列放完，找到一个合适位置</span></span><br><span class="line"><span class="comment"> * （3）继续第三个皇后，还是第一列、第二列...直到第8个皇后也放在一个不冲突的位置，</span></span><br><span class="line"><span class="comment"> *      算是找到一个正确解</span></span><br><span class="line"><span class="comment"> * （4）当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放在第一列的所有正确解，全部得到</span></span><br><span class="line"><span class="comment"> * （5）然后回头继续第一个皇后放第二列，后面继续循环执行1-4步骤</span></span><br><span class="line"><span class="comment"> * 3.说明</span></span><br><span class="line"><span class="comment"> *  理论上创建一个二维数组来表示一个棋盘，但实际上可以通过算法，</span></span><br><span class="line"><span class="comment"> *  用一个一维数组即可解决 arr[8] = &#123;0, 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line"><span class="comment"> *  // arr[0] = 0 表示第1个皇后（第一行）放在第1列，即[0,0]</span></span><br><span class="line"><span class="comment"> *  // arr[1] = 4 表示第2个皇后（第二行）放在第5列，即[1,4]</span></span><br><span class="line"><span class="comment">  * 下标表示第几行 即第几个皇后</span></span><br><span class="line"><span class="comment"> *  arr[i] = val，val表示第i+1个皇后放在第i+1行的第val+1列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen8</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            System.out.print(String.format(<span class="string">"R%s\t"</span>, i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Queen8 queen8 = <span class="keyword">new</span> Queen8(<span class="number">8</span>);</span><br><span class="line">        queen8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"共有%s种解法"</span>, queen8.count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 冒泡排序</span></span><br><span class="line"><span class="comment"> *  案例：arr[] = &#123;3, 9, -1, 10, 20&#125;</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1.两层for循环遍历待排序的数组，i的index=[0,arr.length-1],j的index=[0,arr.length-1-i]</span></span><br><span class="line"><span class="comment"> *  （1）length-1：每一轮循环是两个数比较，所以-1</span></span><br><span class="line"><span class="comment"> *  （2）length-1-i：-1跟同上；每一轮结束会有一个最小值到数组最末端，所以每次-i</span></span><br><span class="line"><span class="comment"> * 2.如果 arr[j] &gt; arr[j+1] 交换两个值的位置（arr[j] = arr[j+1]），需要用temp临时变量保存arr[j]的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 直接交换是不行的，值会覆盖</span></span><br><span class="line">                    <span class="comment">/*arr[j] = arr[j+1];</span></span><br><span class="line"><span class="comment">                    arr[j+1] = arr[j];*/</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮过后，arr="</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 选择排序</span></span><br><span class="line"><span class="comment"> * arr[] = &#123;101, 34, 119, 1&#125;</span></span><br><span class="line"><span class="comment"> * （1）第一次从arr[0]~arr[n]中选取最小值，与arr[0]交换</span></span><br><span class="line"><span class="comment"> * （2）第二次从arr[1]~arr[n]中选取最小值，与arr[1]交换</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * （3）第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换</span></span><br><span class="line"><span class="comment"> * （4）第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// arr.length - 1 只要n-1次就能排好顺序</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// i+1，每结束一轮，最小下标往后移</span></span><br><span class="line">                <span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 不是最小值</span></span><br><span class="line">                    min = arr[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到最小值，与arr[0]交换，并放在第一个位置，即arr[0]</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123; <span class="comment">// 最小下标发生改变，才调整位置</span></span><br><span class="line">                arr[minIndex] = arr[i]; <span class="comment">// [101, 34, 119, 1] =&gt; [34, 101, 119, 1]</span></span><br><span class="line">                arr[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮过后，arr="</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 插入排序</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  （1）把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中含有n-1个元素</span></span><br><span class="line"><span class="comment"> *  （2）排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序的排序码进行比较，将它插入到有序表中的适当位置，</span></span><br><span class="line"><span class="comment"> *      使之成为新的有序节点</span></span><br><span class="line"><span class="comment"> * 实例：</span></span><br><span class="line"><span class="comment"> *  &#123;101, 34, 119, 1&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">34</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[160000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 160000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        insert_sort2(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序（plus版插入排序）"><a href="#希尔排序（plus版插入排序）" class="headerlink" title="希尔排序（plus版插入排序）"></a>希尔排序（plus版插入排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 希尔排序</span></span><br><span class="line"><span class="comment"> *  它是一种更高效的插入排序，也称为缩小增量排序。</span></span><br><span class="line"><span class="comment"> *  产生原因：</span></span><br><span class="line"><span class="comment"> *      由于插入排序存在问题，当需要插入数最小时，后移的次数明显增多，对效率有影响</span></span><br><span class="line"><span class="comment"> *  基本思想：</span></span><br><span class="line"><span class="comment"> *      把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；</span></span><br><span class="line"><span class="comment"> *      随着增量减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line"><span class="comment">        shellSort2(arr);</span></span><br><span class="line"><span class="comment">        System.out.println("第1轮过后，arr=" + Arrays.toString(arr));*/</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> Random().nextInt(<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        shellSort2(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序（plus版冒泡排序）"><a href="#快速排序（plus版冒泡排序）" class="headerlink" title="快速排序（plus版冒泡排序）"></a>快速排序（plus版冒泡排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 快速排序</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * （1）将一个数组分割成左右两部分</span></span><br><span class="line"><span class="comment"> * （2）分操作</span></span><br><span class="line"><span class="comment"> *      A.左边进行递归冒泡排序，直到有序</span></span><br><span class="line"><span class="comment"> *      B.右边进行递归冒泡排序，直到有序</span></span><br><span class="line"><span class="comment"> * （3）合操作（左边 + 右边）</span></span><br><span class="line"><span class="comment"> * （4）依次执行1-3步骤，直到有序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;-9,78,0,23,-567,70&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">23</span>, -<span class="number">567</span>, <span class="number">70</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 归并排序</span></span><br><span class="line"><span class="comment"> *  利用分治策略，分而治之，即先分再合</span></span><br><span class="line"><span class="comment"> * （1）分</span></span><br><span class="line"><span class="comment"> *      A.找到中间下标mid</span></span><br><span class="line"><span class="comment"> *      B.向左递归</span></span><br><span class="line"><span class="comment"> *      C.向右递归</span></span><br><span class="line"><span class="comment"> * （2）治</span></span><br><span class="line"><span class="comment"> *      A.将左右两边（有序）的数据按照规则填充到temp数组，直到左右两边的有序序列有一边处理完毕为止</span></span><br><span class="line"><span class="comment"> *      B.把剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="comment"> *      C.将temp数组的元素拷贝到arr（注意，并不是每次都拷贝所有！！！）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">// 归并排序需要额外的一个数组</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(LocalDateTime.now());</span></span><br><span class="line"><span class="comment">        int[] temp = new int[arr.length]; // 归并排序需要额外的一个数组</span></span><br><span class="line"><span class="comment">        mergeSort(arr, 0, arr.length - 1, temp);</span></span><br><span class="line"><span class="comment">        System.out.println(LocalDateTime.now());*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 基数排序</span></span><br><span class="line"><span class="comment"> * 特别说明：</span></span><br><span class="line"><span class="comment"> *      该demo不支持负数排序，如想实现负数排序，请参考https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> * 排序思想：</span></span><br><span class="line"><span class="comment"> * （1）将所有比较数值统一为同样的数位长度，数位较短的数前面补0。</span></span><br><span class="line"><span class="comment"> * （2）然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序</span></span><br><span class="line"><span class="comment"> *      完成后，数列就变成一个有序序列了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;53, 3, 542, 748, 14, 214&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>（1）速度方面：桶排序、快速排序、希尔排序、插入排序、选择排序、冒泡排序<br>（2）归并排序需要一个arr[length]的额外数组<br>（3）基数排序需要一个arr[10][length]的二维数组</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二分查找</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;1, 8, 10, 89, 1000, 1234&#125;</span></span><br><span class="line"><span class="comment"> * 一、思路分析（返回第一个）：</span></span><br><span class="line"><span class="comment"> *  1.首先确定该数组的中间下标</span></span><br><span class="line"><span class="comment"> *      mid = (left + right) / 2</span></span><br><span class="line"><span class="comment"> *  2.然后让需要查找的数findVal与arr[mid]比较</span></span><br><span class="line"><span class="comment"> *  2.1 findVal &gt; arr[mid]，说明要查找的数在右边，需要向右递归</span></span><br><span class="line"><span class="comment"> *  2.2 findVal &lt; arr[mid]，说明要查找的数在左边，需要向左递归</span></span><br><span class="line"><span class="comment"> *  2.3 findVal == arr[mid]，说明已经找到了，返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  问题：结束递归的条件是什么?</span></span><br><span class="line"><span class="comment"> *  1) 找到就结束递归</span></span><br><span class="line"><span class="comment"> *  2) 递归完整个数组，仍然没找到findVal，也需要结束递归，当left&gt;right就需要退出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、思路分析（返回所有符合条件的下标）：</span></span><br><span class="line"><span class="comment"> *  1.在找到mid索引值时，不要立马返回</span></span><br><span class="line"><span class="comment"> *  2.向mid索引值的左边扫描，将所有满足条件元素的下标，加入到集合</span></span><br><span class="line"><span class="comment"> *  3.向mid索引值的右边扫描，将所有满足条件元素的下标，加入到集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="comment">// （1）使用二分查找，返回第一个符合条件的下标</span></span><br><span class="line">        <span class="keyword">int</span> findVal = <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">0</span>, arr.length, findVal);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （2）使用二分查找，返回所有符合条件的下标数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1000</span>, <span class="number">8</span>, <span class="number">1000</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        findVal = <span class="number">1000</span>;</span><br><span class="line">        List&lt;Integer&gt; resIndexList = binarySearch2(arr2, <span class="number">0</span>, arr2.length, findVal);</span><br><span class="line">        System.out.println(<span class="string">"arr2="</span> + resIndexList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 插值查找算法</span></span><br><span class="line"><span class="comment"> *  由于二分查找针对大数据量首、末两端的查找位移次数太多，影响性能，所以出现了动态中间下标，即插值查找算法。</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  int mid = left + (right - left)*(findVal - arr[left])/(arr[right] - arr[left])</span></span><br><span class="line"><span class="comment"> *  如：arr = &#123;1,2,3...100&#125;</span></span><br><span class="line"><span class="comment"> *  （1）查找1</span></span><br><span class="line"><span class="comment"> *      mid = 0 + (99 - 0)*(1 - 1)/(100 - 1) =&gt; 0 + 99 * 0/99 = 0</span></span><br><span class="line"><span class="comment"> *  （2）查找100</span></span><br><span class="line"><span class="comment"> *      mid = 0 + (99 - 0)*(100 - 1)/(100 - 1) =&gt; 0 + 99 * 99/99 = 99</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;1,2,3...100&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = Stream.iterate(<span class="number">1</span>, x -&gt; x+<span class="number">1</span>).limit(<span class="number">100</span>).collect(Collectors.toList()).toArray(<span class="keyword">new</span> Integer[<span class="number">100</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">100</span>); <span class="comment">// arr.length - 1</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="斐波那契算法（黄金分割算法）"><a href="#斐波那契算法（黄金分割算法）" class="headerlink" title="斐波那契算法（黄金分割算法）"></a>斐波那契算法（黄金分割算法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 斐波那契查找算法</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1.原理与二分查找、插值查找类似，也是通过改变mid值（该值在黄金分割点附近）位置，算法：mid = low + f[k-1] - 1</span></span><br><span class="line"><span class="comment"> *  f代码斐波那契数列</span></span><br><span class="line"><span class="comment"> *  （1）斐波那契数列特点：f[k] = f[k-1] + f[k-2] =&gt; (f[k] - 1) = (f[k-1]-1) + (f[k-2]-1) + 1</span></span><br><span class="line"><span class="comment"> *      假设顺序表长度为：length = (f[k] - 1) ，刚好可以分成 f[k-1]-1和f[k-2]-1两部分</span></span><br><span class="line"><span class="comment"> *      即中间位置 mid = low + (f[k-1] - 1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">12</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">56</span>, <span class="number">87</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = fibSearch(arr, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="简单的员工添加、查询"><a href="#简单的员工添加、查询" class="headerlink" title="简单的员工添加、查询"></a>简单的员工添加、查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 哈希表案例</span></span><br><span class="line"><span class="comment"> *  有一个公司，当有新员式来报道时，要求该员工的信息加入</span></span><br><span class="line"><span class="comment"> *  （id，性别，年龄，名字、住址），当输入该员工的id时，要求查询该员工的所有信息</span></span><br><span class="line"><span class="comment"> *  要求：</span></span><br><span class="line"><span class="comment"> *  不使用数据库，速度越快越好=&gt; 哈希表（散列）</span></span><br><span class="line"><span class="comment"> *  添加时，保证按照id从低至高的顺序插入？</span></span><br><span class="line"><span class="comment"> *  （1）使用链表来实现哈希表，该链表不带表头，即：链表的第一个结点放存放雇员</span></span><br><span class="line"><span class="comment"> *  （2）思路分析并画出示意图</span></span><br><span class="line"><span class="comment"> *  （3）代码实现【增删改查（显示所有员工，按id查询）】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashTab hashTab = <span class="keyword">new</span> HashTab();</span><br><span class="line">        String key;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add: 添加雇员"</span>);</span><br><span class="line">            System.out.println(<span class="string">"list: 显示雇员"</span>);</span><br><span class="line">            System.out.println(<span class="string">"find: 查找"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入id"</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入id"</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树结构基础部分"><a href="#树结构基础部分" class="headerlink" title="树结构基础部分"></a>树结构基础部分</h4><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二叉树遍历</span></span><br><span class="line"><span class="comment"> *  案例：1-宋江、2-吴用、3-卢俊义、4-林冲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.前、中、后序遍历</span></span><br><span class="line">        test_simple_order();</span><br><span class="line">        <span class="comment">// 2.查找指定节点（前、中、后序查找）</span></span><br><span class="line">        <span class="comment">//test_sample_order_search();</span></span><br><span class="line">        <span class="comment">// 3.删除节点（后序遍历为例）</span></span><br><span class="line">        <span class="comment">//test_del_node();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="顺序二叉树"><a href="#顺序二叉树" class="headerlink" title="顺序二叉树"></a>顺序二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 顺序二叉树（只考虑完全二叉树）</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  n: 表示二叉树中的第几个元素（按0开始编号）</span></span><br><span class="line"><span class="comment"> *  （1）第n个元素的左子节点为2*n + 1</span></span><br><span class="line"><span class="comment"> *  （2）第n个元素的右子节点为2*n + 2、</span></span><br><span class="line"><span class="comment"> *  （3）第n个元素的父节点为arr[(n-1)/2]</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  给个数组：&#123;1, 2, 3, 4, 5, 6, 7&#125;，要求以前序遍历的方式遍历，结果为：1,2,4,5,3,6,7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        ArrayBinaryTree arrayBinaryTree = <span class="keyword">new</span> ArrayBinaryTree(arr);</span><br><span class="line">        arrayBinaryTree.preOrder(); <span class="comment">// 前序：1,2,4,5,3,6,7</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        arrayBinaryTree.infixOrder(); <span class="comment">// 中序：4,2,5,1,6,3,7</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        arrayBinaryTree.postOrder(); <span class="comment">// 后序：4,5,2,6,7,3,1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 线索化二叉树</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;1, 3, 6, 8, 10, 14&#125;</span></span><br><span class="line"><span class="comment"> *  中序遍历方式：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 3, 10, 1, 14, 6&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"林冲"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"关胜"</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"张包"</span>);</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line">        <span class="comment">// 测试：以10号结点测试</span></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">"10号结点的前驱节点："</span> + leftNode); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(<span class="string">"10号结点的后继节点："</span> + rightNode); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 堆排序</span></span><br><span class="line"><span class="comment"> * 排序思想：</span></span><br><span class="line"><span class="comment"> *  1.将待排序序列构造成一个大顶堆</span></span><br><span class="line"><span class="comment"> *  2.此时，整个队列最大的就是堆顶</span></span><br><span class="line"><span class="comment"> *  3.将其与末尾元素进行交换，此时末尾就为最大值</span></span><br><span class="line"><span class="comment"> *  4.然后将剩余n-1个元素重新构成一个堆，这样会得到n个元素的次小值，</span></span><br><span class="line"><span class="comment"> *      如此反复执行，便能得到一个有序序列</span></span><br><span class="line"><span class="comment"> *  可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后得到一个有序序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *    &#123;4, 6, 8, 5, 9&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="赫夫曼编码（数据压缩）"><a href="#赫夫曼编码（数据压缩）" class="headerlink" title="赫夫曼编码（数据压缩）"></a>赫夫曼编码（数据压缩）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 数据压缩</span></span><br><span class="line"><span class="comment"> * 原理分析：</span></span><br><span class="line"><span class="comment"> * （1）生成赫夫曼树</span></span><br><span class="line"><span class="comment"> *      i like like like java do you like a java</span></span><br><span class="line"><span class="comment"> * （2）生成赫夫曼树对应的编码</span></span><br><span class="line"><span class="comment"> *      =01,a=100 d=11000 u=11101 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</span></span><br><span class="line"><span class="comment"> * （3）使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将"i like like ..."</span></span><br><span class="line"><span class="comment"> *      字符串生成对应的编码数据，形式如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanZip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 赫夫曼编码集合</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// （1）生成赫夫曼树</span></span><br><span class="line">        String content = <span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line">        <span class="comment">// （3）使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将"i like like ..."</span></span><br><span class="line">        <span class="comment">//      字符串生成对应的编码数据，形式如下：</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodesBytes = huffmanZip(content.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"压缩后的结果："</span> + <span class="keyword">new</span> String(huffmanCodesBytes) + <span class="string">" 长度="</span> + huffmanCodesBytes.length);</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span><br><span class="line">        System.out.println(<span class="string">"原字符串："</span> + <span class="keyword">new</span> String(sourceBytes));</span><br><span class="line">        String srcFile = <span class="string">"D:\\2019\\doc\\img\\huffman.png"</span>;</span><br><span class="line">        String dstFile = <span class="string">"D:\\2019\\doc\\img\\huffman.zip"</span>;</span><br><span class="line">        zipFile(srcFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二叉排序树</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  1.排序树添加：</span></span><br><span class="line"><span class="comment"> *      （1）if（待插入节点值 &gt; 当前节点值） -&gt; 往右子树递归找（当右子树为空，找到了）</span></span><br><span class="line"><span class="comment"> *      （2）if（待插入节点值 &lt; 当前节点值） -&gt; 往左子树递归找（当左子树为空，找到了）</span></span><br><span class="line"><span class="comment"> *  2.排序树删除：（三种情况）</span></span><br><span class="line"><span class="comment"> *  情况一：删除叶子节点（比如：2,5,9,12）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）确定targetNode是parent的左子节点还是右子节点</span></span><br><span class="line"><span class="comment"> *      （4）根据前面的情况来删除：</span></span><br><span class="line"><span class="comment"> *              左子结点 -&gt; parent.left = null</span></span><br><span class="line"><span class="comment"> *              右子结点 -&gt; parent.right = null</span></span><br><span class="line"><span class="comment"> *  情况二：删除只有一颗子树的节点（比如：1）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）确定targetNode的子节点是左节点还右节点</span></span><br><span class="line"><span class="comment"> *      （4）确定targetNode是parent的左子节点还是右子节点</span></span><br><span class="line"><span class="comment"> *      （5）如果targetNode有左子节点</span></span><br><span class="line"><span class="comment"> *          5.1 如果targetNode是parent的左子节点 -&gt; parent.left = targetNode.left</span></span><br><span class="line"><span class="comment"> *          5.2 如果targetNode是parent的右子节点 -&gt; parent.right = targetNode.left</span></span><br><span class="line"><span class="comment"> *      （6）如果targetNode有右子节点</span></span><br><span class="line"><span class="comment"> *          6.1 如果targetNode是parent的左子节点 -&gt; parent.left = targetNode.right</span></span><br><span class="line"><span class="comment"> *          6.2 如果targetNode是parent的右子节点 -&gt; parent.right = targetNode.right</span></span><br><span class="line"><span class="comment"> *  情况三：删除有两颗子树的节点（比如：7, 3, 10）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）从targetNode的右子树找到最小的结点</span></span><br><span class="line"><span class="comment"> *      （4）用一个临时变量，将最小结点值保存temp=12</span></span><br><span class="line"><span class="comment"> *      （5）删除该最小节点</span></span><br><span class="line"><span class="comment"> *      （6）targetNode=temp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * &#123;7,3,10,12,5,1,9&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----中序遍历----"</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        <span class="comment">// 节点删除</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">1</span>; <span class="comment">// 2,5,9,12 | 7, 3, 10</span></span><br><span class="line">        binarySortTree.delNode(value);</span><br><span class="line">        System.out.println(<span class="string">"----中序遍历----"</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="平衡树（AVL树）"><a href="#平衡树（AVL树）" class="headerlink" title="平衡树（AVL树）"></a>平衡树（AVL树）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 平衡二叉树（AVL树）</span></span><br><span class="line"><span class="comment"> *  由于二叉排序树可能会出现问题，如&#123;1,2,3,4,5,6&#125;，就变成单链表了，引出解决方案：平衡二叉树</span></span><br><span class="line"><span class="comment"> * （1）左旋转</span></span><br><span class="line"><span class="comment"> *      条件：当右子树高度-左子树高度&gt;1</span></span><br><span class="line"><span class="comment"> *      步骤：</span></span><br><span class="line"><span class="comment"> *          1）将A节点的右节点的左节点，指向A节点</span></span><br><span class="line"><span class="comment"> *          2）将A节点的右节点，指向A节点的右节点的左节点</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）创建一个新节点newNode，并设置值为当前节点的值：newNode.value = value</span></span><br><span class="line"><span class="comment"> *          2）把新节点的左子树设置为当前节点的左子树：newNode.left = left</span></span><br><span class="line"><span class="comment"> *          3）把当前节点的值替换为右子节点的值</span></span><br><span class="line"><span class="comment"> *          4）把当前节点的右子树设置成右子树的右子树</span></span><br><span class="line"><span class="comment"> *          5）把当前节点的左子树设置成新的节点</span></span><br><span class="line"><span class="comment"> *      案例：</span></span><br><span class="line"><span class="comment"> *          &#123;4,3,6,5,7,8&#125;</span></span><br><span class="line"><span class="comment"> * （2）右旋转（与左旋转原理一样）</span></span><br><span class="line"><span class="comment"> * （3）双旋转</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）当符合右旋转的条件时，</span></span><br><span class="line"><span class="comment"> *          1.1）如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="comment"> *          1.2）先对当前这个节点的左节点进行左旋转</span></span><br><span class="line"><span class="comment"> *          1.3）再对当前结点进行右旋转的操作即可</span></span><br><span class="line"><span class="comment"> *          2）当符合左旋转的条件时（与符合右旋转的条件同理）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;;</span></span><br><span class="line">        <span class="comment">// 双旋转</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;2, 1, 6, 5, 7, 3&#125;;</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        Arrays.stream(arr).forEach(m -&gt; avlTree.add(<span class="keyword">new</span> Node(m)));</span><br><span class="line">        System.out.println(<span class="string">"---中序遍历---"</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">"---平衡处理---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"树的高度："</span> + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">"左子树的高度："</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">"右子树的高度："</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>描述：包括二叉树与B树、2-3树、B树、B+树和B*树<br>代码：暂无</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 图</span></span><br><span class="line"><span class="comment"> * 基本概念：顶点、边、路径、无向图、有向图、带权图</span></span><br><span class="line"><span class="comment"> * 案例：(实现如下的效果)</span></span><br><span class="line"><span class="comment"> *      A   B   C   D   E</span></span><br><span class="line"><span class="comment"> *  A   0   1   1   0   0</span></span><br><span class="line"><span class="comment"> *  B   1   0   1   1   1</span></span><br><span class="line"><span class="comment"> *  C   1   1   0   0   0</span></span><br><span class="line"><span class="comment"> *  D   0   1   0   0   0</span></span><br><span class="line"><span class="comment"> *  E   0   1   0   0   0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  （1）用图的方式实现上述效果图</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）5个顶点：A\B\C\D\E</span></span><br><span class="line"><span class="comment"> *          2）1-表示连通，0-表示不连通</span></span><br><span class="line"><span class="comment"> *  （2）用深度优先方式遍历</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line"><span class="comment"> *          2）查找结点v的第一个邻接结点</span></span><br><span class="line"><span class="comment"> *          3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line"><span class="comment"> *          4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line"><span class="comment"> *          5）查找结点v的w邻接结点的下一个结点，转到步骤3</span></span><br><span class="line"><span class="comment"> *  （3）用广度优先方式遍历</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）访问初始结点v并标记结点v已访问</span></span><br><span class="line"><span class="comment"> *          2）结点v入队列</span></span><br><span class="line"><span class="comment"> *          3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line"><span class="comment"> *          4）出队列，取得队头结点u</span></span><br><span class="line"><span class="comment"> *          5）查找结点u的第一个邻接结点w</span></span><br><span class="line"><span class="comment"> *          6）若结点u的邻接结点w不存在，则转到步骤3；否则执行以下三个步骤：</span></span><br><span class="line"><span class="comment"> *              6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line"><span class="comment"> *              6.2 结点w入队列</span></span><br><span class="line"><span class="comment"> *              6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList; <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">// 存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited; <span class="comment">// 边是否被访问过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建图</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// （1）添加顶点</span></span><br><span class="line">        graph.insertVertex(<span class="string">"A"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"B"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"C"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"D"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"E"</span>);</span><br><span class="line">        <span class="comment">// （2）添加边</span></span><br><span class="line">        <span class="comment">// A-B,A-C,B-C,B-D,B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// show一把</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">// 深度优先思路分析：</span></span><br><span class="line">        <span class="comment">// 1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line">        <span class="comment">// 2）查找结点v的第一个邻接结点</span></span><br><span class="line">        <span class="comment">// 3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line">        <span class="comment">// 4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line">        <span class="comment">// 5）查找结点v的w邻接结点的下一个结点，转到步骤3</span></span><br><span class="line">        System.out.println(<span class="string">"=========== 深度优先  =========="</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 广度优先思路分析：思路分析：</span></span><br><span class="line">        <span class="comment">// 1）访问初始结点v并标记结点v已访问</span></span><br><span class="line">        <span class="comment">// 2）结点v入队列</span></span><br><span class="line">        <span class="comment">// 3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line">        <span class="comment">// 4）出队列，取得队头结点u</span></span><br><span class="line">        <span class="comment">// 5）查找结点u的第一个邻接结点w</span></span><br><span class="line">        <span class="comment">// 6）若结点u的邻接结点w不存在，则转到步骤3；否则执行以下三个步骤：</span></span><br><span class="line">        <span class="comment">//  6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line">        <span class="comment">//  6.2 结点w入队列</span></span><br><span class="line">        <span class="comment">//  6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line">        System.out.println(<span class="string">"=========== 广度优先  =========="</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先算法"><a href="#深度优先算法" class="headerlink" title="深度优先算法"></a>深度优先算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isVisited 访问标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 从第0个元素开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 2）查找结点v的第一个邻接结点</span></span><br><span class="line">    <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">    <span class="comment">// 3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line">    <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">            dfs(isVisited, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果w已经被访问过</span></span><br><span class="line">        w = getNextNeighbor(i, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1）访问初始结点v并标记结点v已访问</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 2）结点v入队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.addLast(i);</span><br><span class="line">    <span class="comment">// 3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line">    Integer u;</span><br><span class="line">    Integer w;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 4）出队列，取得队头结点u</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">// 5）查找结点u的第一个邻接结点w</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">"-&gt;"</span>);</span><br><span class="line">                isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 6.2 结点w入队列</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="程序员常用10大算法"><a href="#程序员常用10大算法" class="headerlink" title="程序员常用10大算法"></a>程序员常用10大算法</h3><h4 id="二分查找算法（非递归）"><a href="#二分查找算法（非递归）" class="headerlink" title="二分查找算法（非递归）"></a>二分查找算法（非递归）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二分查询（非递归方式）</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * &#123;1,3,8,10,11,67,100&#125;，编程实现二分查找，要求使用非递归方式完成。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNonRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 向左找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 向右找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 分治算法案例：汉诺塔</span></span><br><span class="line"><span class="comment"> * （1）基本概念</span></span><br><span class="line"><span class="comment"> * 分治算法是一种很重要的算法，字面上的解释是“分而治之”，就是把一个复杂的问题</span></span><br><span class="line"><span class="comment"> * 分解成两个或更多的相同或相似的子问题...直到最后子问题可以简单的直接求解，原</span></span><br><span class="line"><span class="comment"> * 问题的解即子问题的解的合并，这个技巧就是很多高效算法的基础，如排序算法（快速排序，归并排序），傅里叶变换（快速傅里叶变换）...</span></span><br><span class="line"><span class="comment"> * （2）基本步骤</span></span><br><span class="line"><span class="comment"> * 1）分解：将原问题分解为若干个规模较小的问题，相互独立，与原问题形式相同的子问题</span></span><br><span class="line"><span class="comment"> * 2）解决：若子问题规模较小则直接解决，否则递归地解各个子问题</span></span><br><span class="line"><span class="comment"> * 3）合并：将各个子问题的解合并为原问题的解</span></span><br><span class="line"><span class="comment"> * （3）分治算法设计模式</span></span><br><span class="line"><span class="comment"> * if |P|&lt;=n0</span></span><br><span class="line"><span class="comment"> * then return (ADHOC(P))</span></span><br><span class="line"><span class="comment"> * // 将P分解为较小的问题P1,P2...PK</span></span><br><span class="line"><span class="comment"> * for i &lt;- 1 to k</span></span><br><span class="line"><span class="comment"> * do yi &lt;- Divide-and-Conquer(Pi) 递归解决Pi</span></span><br><span class="line"><span class="comment"> * T &lt;- MERGE(y1,y2...yk) 合并子问题</span></span><br><span class="line"><span class="comment"> * return (T)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * |P|：表示问题P的规模</span></span><br><span class="line"><span class="comment"> * n0：表示阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。</span></span><br><span class="line"><span class="comment"> * ADHOC(P)：是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解</span></span><br><span class="line"><span class="comment"> * 算法MERGE(y1,y2...yk)：是该分治算法中的合并子算法，用于将P的子问题P1,P2...PK的相应的解y1,y2,..yk合并为P的解。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 经典案例：汉诺塔</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * （1）如果有一个盘，A-&gt;C</span></span><br><span class="line"><span class="comment"> * n0=2</span></span><br><span class="line"><span class="comment"> * if (n&lt;=n0) &#123;</span></span><br><span class="line"><span class="comment"> * // 直接解出来</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * // 将P分解为较小的问题P1,P2...PK</span></span><br><span class="line"><span class="comment"> * while(n&gt;n0) &#123;</span></span><br><span class="line"><span class="comment"> * 分(n);</span></span><br><span class="line"><span class="comment"> * n--;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * // T &lt;- MERGE(y1,y2...yk) 合并子问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiTower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">// 只有一个盘，直接解出</span></span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果n&gt;=2的情况</span></span><br><span class="line">            <span class="comment">// 1.先把最上面的所有盘A-&gt;B，移动过程会使用C</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">// 2.把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">            <span class="comment">// 3.把B塔所有盘从B-&gt;C，移动过程使用到A</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 动态规划算法案例：背包问题</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * （1）假设：</span></span><br><span class="line"><span class="comment"> * 用w[i],v[i]来确定是否需要将该物品放入背包中；</span></span><br><span class="line"><span class="comment"> * 即对于给定的n个物品，设v[i],w[i]分别为第i个物品的价值和重量，C为背包的容量。</span></span><br><span class="line"><span class="comment"> * 再令v[i][j] 表示在前i个物品中能够装入容量j的背包的最大价值。则我们有下面的结果：</span></span><br><span class="line"><span class="comment"> * （2）结论：</span></span><br><span class="line"><span class="comment"> * 1）当v[i][0]=v[0][j]=0; // 表示填入表 第一行和第一列是0</span></span><br><span class="line"><span class="comment"> * 2）当w[i]&gt;j时；v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span></span><br><span class="line"><span class="comment"> * 3）当j&gt;=w[i]时；v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</span></span><br><span class="line"><span class="comment"> * // 当准入的新增的商品的容量小于等于当前背包的容量，装入方式：</span></span><br><span class="line"><span class="comment"> * v[i-1][j]：就是上一个单元格的装入的最大值</span></span><br><span class="line"><span class="comment"> * v[i]：表示当前商品的价值</span></span><br><span class="line"><span class="comment"> * v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值</span></span><br><span class="line"><span class="comment"> * 当j&gt;=w[i]时：v[i][j] = max&#123;v[i-1][j], v[i-1][j-w[i]]&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * 物品      重量  价格</span></span><br><span class="line"><span class="comment"> * 吉他（G）   1   1500</span></span><br><span class="line"><span class="comment"> * 音响（S）   4   3000</span></span><br><span class="line"><span class="comment"> * 电脑（L）   3   2000</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;; <span class="comment">// 物品重量</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">// 物品价值</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">// 背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length; <span class="comment">// 物品个数</span></span><br><span class="line">        <span class="comment">// 创建二维数据</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 1）当v[i][0]=v[0][j]=0; // 表示填入表 第一行和第一列是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">// 第一列为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一行为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123; <span class="comment">// 不处理第1列</span></span><br><span class="line">                <span class="comment">// 当w[i]&gt;j时；v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当j&gt;=w[i]时；v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</span></span><br><span class="line">                    <span class="comment">// v[i-1][j]：就是上一个单元格的装入的最大值</span></span><br><span class="line">                    <span class="comment">// v[i]：表示当前商品的价值</span></span><br><span class="line">                    <span class="comment">// v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值</span></span><br><span class="line">                    <span class="comment">// 当准入的新增的商品的容量小于等于当前背包的容量，装入方式：</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123; <span class="comment">// w[i]-&gt;w[i-1]替换?</span></span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">// 把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出一把</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if (path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(String.format("第%d个商品放入背包", i));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// 其实我们只需要最后的放入</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"第%d个商品放入到背包"</span>, i));</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> KMP算法</span></span><br><span class="line"><span class="comment"> * 基本介绍：</span></span><br><span class="line"><span class="comment"> * （1）暴力匹配算法</span></span><br><span class="line"><span class="comment"> *      1）如果当前字符匹配成功（即str1[i]=str2[i]），则i++,j++，继续匹配下一个字符</span></span><br><span class="line"><span class="comment"> *      2）如果失败，令i=i-(j-1)，j=0，相当于每次匹配失败时，i回溯，j被转为0</span></span><br><span class="line"><span class="comment"> *      3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费大量时间。（不可行）</span></span><br><span class="line"><span class="comment"> *      4）暴力匹配实现</span></span><br><span class="line"><span class="comment"> * （2）KMP算法介绍</span></span><br><span class="line"><span class="comment"> *      1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置就经典算法。</span></span><br><span class="line"><span class="comment"> *      2）Knuth-Morris-Pratt字符串查找法，简称KMP。</span></span><br><span class="line"><span class="comment"> *      3）KMP算法就是利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共序列的长度，每次回溯时，通过next数组找到，</span></span><br><span class="line"><span class="comment"> *          前面匹配的位置，省去了大量的计算时间</span></span><br><span class="line"><span class="comment"> *      4）参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力匹配</span></span><br><span class="line">        String str1 = <span class="string">"ABCDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"CD"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，位置："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// KMP算法介绍</span></span><br><span class="line">        <span class="comment">// 字符串模板匹配值</span></span><br><span class="line">        str1 = <span class="string">"BBC ABCDAD ABCDABCDABDE"</span>;</span><br><span class="line">        str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">        <span class="comment">/*int[] next = kmpNext("ABCDABD");</span></span><br><span class="line"><span class="comment">        System.out.println("next=" + Arrays.toString(next));*/</span></span><br><span class="line">        index = kmpMatch(str1, str2, kmpNext(str2));</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，位置："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 贪心算法</span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> * （1）使用穷举法，列出每个可能广播台集合，这被称为幂集。</span></span><br><span class="line"><span class="comment"> * （2）假设有n个广播台，则广播台的组合共有2^n-1个，假设每秒可以计算10个子集</span></span><br><span class="line"><span class="comment"> *      广播台数量   子集总数    需要的时间</span></span><br><span class="line"><span class="comment"> *      5               32          3.2秒</span></span><br><span class="line"><span class="comment"> *      10              1024        102.4秒</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：集合覆盖问题</span></span><br><span class="line"><span class="comment"> *      假设存在下面需要付费的广播台，以及广播信号可以覆盖的地区，如何选择</span></span><br><span class="line"><span class="comment"> *      最少的广播台，让所有的地区都可以接收信息</span></span><br><span class="line"><span class="comment"> *      广播台     覆盖地区</span></span><br><span class="line"><span class="comment"> *      K1          "北京","上海","天津"</span></span><br><span class="line"><span class="comment"> *      K2          "广州","北京","深圳"</span></span><br><span class="line"><span class="comment"> *      K3          "成都","上海","杭州"</span></span><br><span class="line"><span class="comment"> *      K4          "上海","天津"</span></span><br><span class="line"><span class="comment"> *      K5          "杭州","大连"</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 广播电台</span></span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"天津"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"广州"</span>, <span class="string">"北京"</span>, <span class="string">"深圳"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"成都"</span>, <span class="string">"上海"</span>, <span class="string">"杭州"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"上海"</span>, <span class="string">"天津"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"杭州"</span>, <span class="string">"大连"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        <span class="comment">// [上海, 天津, 北京, 广州, 深圳, 成都, 杭州, 大连]</span></span><br><span class="line">        List&lt;String&gt; allAreas = broadcasts.values().stream().flatMap(Collection::stream).distinct().collect(Collectors.toList()); <span class="comment">// 表示所有需要覆盖的地区</span></span><br><span class="line">        System.out.println(<span class="string">"allAreas="</span> + allAreas);</span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 选择的地区集合</span></span><br><span class="line">        <span class="comment">// 定义一个临时的集合，在遍历过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String maxKey; <span class="comment">// 最大的电台，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台key</span></span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>; <span class="comment">// 置空</span></span><br><span class="line">            <span class="comment">// 遍历broadcasts，取出对应key</span></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear(); <span class="comment">// 清空</span></span><br><span class="line">                Set&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                tempSet.retainAll(allAreas); <span class="comment">// tempSet = tempSet与allAreas的交集</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span></span><br><span class="line">                        || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">// 将maxKey指向的广播电台覆盖地区，从allAreas去掉</span></span><br><span class="line">                System.out.println(<span class="string">"maxKey="</span> + maxKey);</span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"得到的选择结果是："</span> + selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普利姆算法"><a href="#普利姆算法" class="headerlink" title="普利姆算法"></a>普利姆算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 普利姆算法</span></span><br><span class="line"><span class="comment"> * 应用案例：修路问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> *  1.从&lt;A&gt;顶点开始处理=&gt;&lt;A,G&gt; 2</span></span><br><span class="line"><span class="comment"> *      A,C[7] A-G[2] A-B[5] =&gt;</span></span><br><span class="line"><span class="comment"> *  2.&lt;A,G&gt;开始，将A和G顶点和他们相邻的还没有访问的顶面进行处理=&gt; &lt;A,G,B&gt;</span></span><br><span class="line"><span class="comment"> *      A-C[7] A-B[5] G-B[3] G-F[6]</span></span><br><span class="line"><span class="comment"> *  3.&lt;A,G,B&gt;开始，将A,G,B顶点和他们相邻的还没有访问的顶面进行处理=&gt; &lt;A,G,B&gt;</span></span><br><span class="line"><span class="comment"> *      A-C[7] G-E[4] G-F[6] B-D[9]</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  4.&#123;A,G,B,E,F,D&#125; -&gt; C // 第6次大循环，对应边&lt;A,C&gt;权值：7 =&gt; &lt;A,G,B,E,F,D,C&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">// 创建最小树</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        <span class="comment">// 测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 克鲁斯卡尔算法</span></span><br><span class="line"><span class="comment"> * 案例：公交车问题</span></span><br><span class="line"><span class="comment"> * 1. 某城市新增7个站点，A,B,C,D,E,F,G,现在需要修路7个站点连通</span></span><br><span class="line"><span class="comment"> * 2. 各个站点距离用连线表示，比如A-B距离12公里</span></span><br><span class="line"><span class="comment"> * 3. 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNums; <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs,<span class="keyword">int</span>[][] matrix )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexs = vertexs;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="comment">// 统计边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123; <span class="comment">// 每次少一条边，所以是i+1</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNums++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                     <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span>&#123; <span class="number">0</span>,   <span class="number">12</span>, INF,  INF, INF, <span class="number">16</span>,  <span class="number">14</span> &#125;,</span><br><span class="line">                <span class="comment">/*B*/</span>&#123; <span class="number">12</span>,  <span class="number">0</span>,   <span class="number">10</span>,  INF, INF, <span class="number">7</span>,   INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span>&#123; INF, <span class="number">10</span>,  <span class="number">0</span>,   <span class="number">3</span>,    <span class="number">5</span>,  <span class="number">6</span>,   INF &#125;,</span><br><span class="line">                <span class="comment">/*D*/</span>&#123; INF, INF, <span class="number">3</span>,   <span class="number">0</span>,    <span class="number">4</span>,  INF, INF &#125;,</span><br><span class="line">                <span class="comment">/*E*/</span>&#123; INF, INF, <span class="number">5</span>,   <span class="number">4</span>,    <span class="number">0</span>,  <span class="number">2</span>,   <span class="number">8</span> &#125;,</span><br><span class="line">                <span class="comment">/*F*/</span>&#123; <span class="number">16</span>,  <span class="number">7</span>,   <span class="number">6</span>,   INF,  <span class="number">2</span>,  <span class="number">0</span>,   <span class="number">9</span> &#125;,</span><br><span class="line">                <span class="comment">/*G*/</span>&#123; <span class="number">14</span>,  INF, INF, INF,  <span class="number">8</span>,  <span class="number">9</span>,   <span class="number">0</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建KruskalCase对象实例</span></span><br><span class="line">        KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 迪杰斯特拉算法</span></span><br><span class="line"><span class="comment"> * 案例：最短路径问题</span></span><br><span class="line"><span class="comment"> * 1. 战争时期，胜利乡有7个村庄(A,B,C,D,E,F,G)，现在有6个邮差，从G点出发，需要分别把邮件分别送到A,B,C,D,E,F 六个村庄</span></span><br><span class="line"><span class="comment"> * 2. 各个村庄的距离用边线表示（权），比如A-B距离5公里</span></span><br><span class="line"><span class="comment"> * 3. 问：如何计算最短距离</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">// 创建Graph对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">// 测试迪杰斯特拉算法</span></span><br><span class="line">        graph.dsj(<span class="number">6</span>); <span class="comment">// G</span></span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 弗洛伊德算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        FloydGraph graph = <span class="keyword">new</span> FloydGraph(vertex.length, matrix, vertex);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 马踏棋盘算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">// 棋盘的列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y; <span class="comment">// 棋盘的行数</span></span><br><span class="line">    <span class="comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line">    <span class="comment">//使用一个属性，标记是否棋盘的所有位置都被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished; <span class="comment">// 如果为true,表示成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑士周游算法，开始运行~~"</span>);</span><br><span class="line">        <span class="comment">//测试骑士周游算法是否正确</span></span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>; <span class="comment">//马儿初始位置的行，从1开始编号</span></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>; <span class="comment">//马儿初始位置的列，从1开始编号</span></span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];<span class="comment">//初始值都是false</span></span><br><span class="line">        <span class="comment">//测试一下耗时</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"共耗时: "</span> + (end - start) + <span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="comment">//输出棋盘的最后情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] rows : chessboard) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> step: rows) &#123;</span><br><span class="line">                System.out.print(step + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring常用注解</title>
    <url>/2019/10/28/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>该文章主要是描述spring常用的几个注解，每个注解都有一个小case去测试验证，感兴趣的同学可以在以下测试用例中断点调试每个注解的原理。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>描述：相关于spring-context.xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试获取第一个bean..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig01<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 根据类型获取bean</span></span><br><span class="line">    String[] namesForType = applicationContext.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String name : namesForType) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据id获取bean</span></span><br><span class="line">    Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    Person person01 = applicationContext.getBean(<span class="string">"person01"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    assertEquals(<span class="string">"zhangsan"</span>, person.getName());</span><br><span class="line">    assertEquals(<span class="string">"zhangsan01"</span>, person01.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 配置类==配置文件</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@Configuration</span> 使用配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 告诉Spring这是一个配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// @Bean(name = "person")，bean对应的id默认是方法名：person</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person01"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan01"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>描述：spring组件扫描的包位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_ComponentScan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@ComponentScan注解..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig02<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取所有bean定义信息</span></span><br><span class="line">    printBeans(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 配置类==配置文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span> 使用配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ComponentScan</span> 扫描组件包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Filter</span></span></span><br><span class="line"><span class="comment"> *      1.excludeFilters：扫描时需要排除哪些组件</span></span><br><span class="line"><span class="comment"> *      2.includeFilters + useDefaultFilters=false：扫描时需要包含哪些组件</span></span><br><span class="line"><span class="comment"> *      3.FilterType</span></span><br><span class="line"><span class="comment"> *              FilterType.ANNOTATION 按照注释</span></span><br><span class="line"><span class="comment"> *              FilterType.ASSIGNABLE_TYPE 按照给定的类型</span></span><br><span class="line"><span class="comment"> *              FilterType.CUSTOM 按照自定义规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.line.spring.ch01.config02"</span>,</span><br><span class="line">    <span class="comment">/*excludeFilters = &#123;</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;),</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;PersonService.class&#125;),</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    includeFilters = &#123;</span><br><span class="line">            <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    &#125;, <span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig02</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>描述：spring bean的作用域，包括多例、单例、request、session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Scope</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Scope：作用域..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig03<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Person person1 = applicationContext.getBean(<span class="string">"person03"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Person person2 = applicationContext.getBean(<span class="string">"person03"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    assertTrue(<span class="string">"scope不是为singleton"</span>,person1 == person2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Scope作用域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig03</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Scope</span></span></span><br><span class="line"><span class="comment">     *      prototype：多例</span></span><br><span class="line"><span class="comment">     *      singleton：单例（spring默认值）</span></span><br><span class="line"><span class="comment">     *      request：同一次请求创建一个实例</span></span><br><span class="line"><span class="comment">     *      session：同一个session创建一个请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scope</span>(scopeName = <span class="string">"prototype"</span>)</span><br><span class="line"><span class="comment">//    @Scope</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person03"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给容器添加Person..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan03"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>描述：懒加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Lazy：懒加载..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig04<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"spring加载完成..."</span>);</span><br><span class="line">    applicationContext.getBean(<span class="string">"person04"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Lazy懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig04</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Lazy</span></span></span><br><span class="line"><span class="comment">     *      单实例Bean，默认在容器启动的时候创建对象，</span></span><br><span class="line"><span class="comment">     *      懒加载，容器启动不创建对象，第一次使用（获取）bean创建对象并初始化。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Scope(scopeName = "singleton")</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person04"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给容器添加person04...懒加载..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan04"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>描述：条件配置，是指符合条件的才使用配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Conditional</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Conditional：条件..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig05<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 根据类型获取bean</span></span><br><span class="line">    String[] namesForType = applicationContext.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String name : namesForType) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Conditional条件</span></span><br><span class="line"><span class="comment"> * 1.是指符合条件的才使用配置</span></span><br><span class="line"><span class="comment"> * 2.Conditional注解可以添加在类、方法上</span></span><br><span class="line"><span class="comment"> *  案例：根据当前系统自动使用不同的配置类，linux使用linuxCondition，window使用windowCondition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig05</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill Gates"</span>, <span class="number">62</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>, <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>描述：导入组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Import</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Import：导入组件..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig06<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取所有bean定义信息</span></span><br><span class="line">    printBeans(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Import：导入组件</span></span><br><span class="line"><span class="comment"> *  1.直接导入普通类，如：Color.class, Red.class</span></span><br><span class="line"><span class="comment"> *  2.使用ImportSelector选择器导入，如：MyImportSelector，</span></span><br><span class="line"><span class="comment"> *      (AnnotationMetadata annotationMetadata) &#123;</span></span><br><span class="line"><span class="comment"> *          return new String[]&#123;"com.line.spring.ch01.config06.Blue", "com.line.spring.ch01.config06.Yellow"&#125;;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *  3.使用ImportBeanDefinitionRegistrar注册组件，如MyImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> *      (AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry) &#123;</span></span><br><span class="line"><span class="comment"> *          registry.registerBeanDefinition("rainbow", new RootBeanDefinition(Rainbow.class));</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>, <span class="title">MyImportSelector</span>.<span class="title">class</span>, <span class="title">MyImportBeanDefinitionRegistrar</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig06</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>github地址： <a href="https://github.com/line007/jucdemo2/tree/master/src/main/java/com/line/spring/ch01" target="_blank" rel="noopener" title="完整代码">查看</a> </p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>markdownlearn</title>
    <url>/2019/10/25/markdownlearn/</url>
    <content><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</li>
<li>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</li>
<li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</li>
<li>Markdown 编写的文档后缀为 .md, .markdown。</li>
</ul>
<h3 id="哪里下载"><a href="#哪里下载" class="headerlink" title="哪里下载"></a>哪里下载</h3><p>下载地址：<a href="https://typora.io/#windows" target="_blank" rel="noopener" title="typora">typora</a>.</p>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p>学习网址：<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener" title="markdown中文网">markdown中文网</a>. </p>
<h4 id="第一个hello-world"><a href="#第一个hello-world" class="headerlink" title="第一个hello world"></a>第一个hello world</h4><p>新建一个helloWord.md</p>
<blockquote>
<p># Hello World!</p>
</blockquote>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>新建一个block.md<br><img src="/images/001.png" alt="Alt text"></p>
<h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><p>新建一个inline.md<br><img src="/images/002.png" alt="Alt text"></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>新建一个other.md<br><img src="/images/003.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>

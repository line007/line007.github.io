<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第4章-Java并发编程基础</title>
    <url>/2019/11/02/%E7%AC%AC4%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本章主要介绍了什么是线程、线程的启动和终止、线程之间的通信和几个实际案例。</p>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程：操作系统调度的最小单元，也叫轻量级进程（LightWeight Process）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取Java线程管理MXBean</span></span><br><span class="line">		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程ID和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.</span><br><span class="line">			getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出内容</span></span><br><span class="line">		[<span class="number">4</span>] Signal Dispatcher　 <span class="comment">// 分发处理发送给JVM信号的线程</span></span><br><span class="line">		[<span class="number">3</span>] Finalizer　　　　 <span class="comment">// 调用对象finalize方法的线程</span></span><br><span class="line">		[<span class="number">2</span>] Reference Handler <span class="comment">// 清除Reference的线程</span></span><br><span class="line">		[<span class="number">1</span>] main　 　　　　 <span class="comment">// main线程，用户程序入口</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><p>因为正确使用多线程，总是能够给开发人员带来显著的好处，而使用多线程的原因主要有以下几点。</p>
<ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10。可以通过setPriority(int)方法来修改优先级，默认优先级是5。程序正确性不能依赖线程的优先级高低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Priority</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notStart = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> notEnd = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Job&gt; jobs = <span class="keyword">new</span> ArrayList&lt;Job&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> priority = i &lt; <span class="number">5</span> Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;</span><br><span class="line">            Job job = <span class="keyword">new</span> Job(priority);</span><br><span class="line">            jobs.add(job);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(job, <span class="string">"Thread:"</span> + i);</span><br><span class="line">            thread.setPriority(priority);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        notStart = <span class="keyword">false</span>;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        notEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Job job : jobs) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Job Priority : "</span> + job.priority + <span class="string">",</span></span><br><span class="line"><span class="string">                    Count : "</span> + job.jobCount);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 输出内容</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1259592</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1260717</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1264510</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1251897</span></span><br><span class="line">		Job Priority : <span class="number">1</span>, Count : <span class="number">1264060</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1256938</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1267663</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1260637</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1261705</span></span><br><span class="line">		Job Priority : <span class="number">10</span>, Count : <span class="number">1259967</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> jobCount;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (notStart) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (notEnd) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                jobCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li>初始状态</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>等待状态</li>
<li>超时等待状态</li>
<li>终止状态</li>
</ul>
<p>状态图<br><img src="/images/javaconcurrent20191102001.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[代码示例]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TimeWaiting (), <span class="string">"TimeWaitingThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Waiting(), <span class="string">"WaitingThread"</span>).start();</span><br><span class="line"><span class="comment">// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blocked(), <span class="string">"BlockedThread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程不断地进行睡眠</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeWaiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Waiting.class实例上等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiting</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Waiting<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Waiting<span class="class">.<span class="keyword">class</span>.<span class="title">wait</span>()</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该线程在Blocked.class实例上加锁后，不会释放该锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Blocked<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    SleepUtils.second(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。<br>注意：Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daemon</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(), <span class="string">"DaemonRunner"</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"DaemonThread finally run."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><p>start()、run()</p>
<h3 id="构造线程"><a href="#构造线程" class="headerlink" title="构造线程"></a>构造线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="keyword">long</span> stackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 当前线程就是该线程的父线程</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">	<span class="comment">// 将daemon、priority属性设置为父线程的对应属性</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">	<span class="comment">// 将父线程的InheritableThreadLocal复制过来</span></span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.</span><br><span class="line">                inheritableThreadLocals);</span><br><span class="line">	<span class="comment">// 分配一个线程ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。<br>关键方法：</p>
<ul>
<li>isInterrupted()：是否被中断</li>
<li>Thread.interrupted()：复位（对当前线程的中断标识）</li>
<li>Thread.sleep(longmillis)：睡眠指定时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interrupted</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// sleepThread不停的尝试睡眠</span></span><br><span class="line">        Thread sleepThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SleepRunner(), <span class="string">"SleepThread"</span>);</span><br><span class="line">        sleepThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// busyThread不停的运行</span></span><br><span class="line">        Thread busyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BusyRunner(), <span class="string">"BusyThread"</span>);</span><br><span class="line">        busyThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        sleepThread.start();</span><br><span class="line">        busyThread.start();</span><br><span class="line">		<span class="comment">// 休眠5秒，让sleepThread和busyThread充分运行</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        sleepThread.interrupt();</span><br><span class="line">        busyThread.interrupt();</span><br><span class="line">        System.out.println(<span class="string">"SleepThread interrupted is "</span> + sleepThread.isInterrupted());</span><br><span class="line">        System.out.println(<span class="string">"BusyThread interrupted is "</span> + busyThread.isInterrupted());</span><br><span class="line">		<span class="comment">// 防止sleepThread和busyThread立刻退出</span></span><br><span class="line">        SleepUtils.second(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                SleepUtils.second(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="过期的suspend-、resume-和stop"><a href="#过期的suspend-、resume-和stop" class="headerlink" title="过期的suspend()、resume()和stop()"></a>过期的suspend()、resume()和stop()</h3><p>大家对于CD机肯定不会陌生，如果把它播放音乐比作一个线程的运作。</p>
<ul>
<li>suspend()：暂停<ul>
<li>过期的API</li>
<li>占有着资源进入睡眠状态，容易引发死锁</li>
</ul>
</li>
<li>resume()：恢复</li>
<li>stop()：停止<ul>
<li>过期的API</li>
<li>不会保证线程的资源正常释放</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deprecated</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runner(), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行暂停，输出内容工作停止</span></span><br><span class="line">        printThread.suspend();</span><br><span class="line">        System.out.println(<span class="string">"main suspend PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行恢复，输出内容继续</span></span><br><span class="line">        printThread.resume();</span><br><span class="line">        System.out.println(<span class="string">"main resume PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">// 将PrintThread进行终止，输出内容停止</span></span><br><span class="line">        printThread.stop();</span><br><span class="line">        System.out.println(<span class="string">"main stop PrintThread at "</span> + format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出如下</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">36</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">37</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">38</span></span><br><span class="line">		main suspend PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">39</span></span><br><span class="line">		main resume PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">42</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">42</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">43</span></span><br><span class="line">		PrintThread Run at <span class="number">17</span>:<span class="number">34</span>:<span class="number">44</span></span><br><span class="line">		main stop PrintThread at <span class="number">17</span>:<span class="number">34</span>:<span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" Run at "</span> +</span><br><span class="line">                        format.format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安全地终止线程"><a href="#安全地终止线程" class="headerlink" title="安全地终止线程"></a>安全地终止线程</h3><p>中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">		<span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two, <span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">		<span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>线程开始运行，拥有自己的栈空间，如果多个线程能够相互配合完成工作，这将会带来巨大的价值。</p>
<h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><p>关键字volatile：轻量级锁，可以用来修饰字段（成员变量）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 对Synchronized Class对象进行加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 静态同步方法，对Synchronized Class对象进行加锁</span></span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ javap–v Synchronized<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">// 输出以下内容：</span></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    <span class="comment">// 方法修饰符，表示：public staticflags: ACC_PUBLIC, ACC_STATIC</span></span><br><span class="line">    Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">		0: ldc #1　　// class com/murdock/books/multithread/book/Synchronized</span><br><span class="line">		<span class="number">2</span>: dup</span><br><span class="line">		<span class="number">3</span>: monitorenter　　<span class="comment">// monitorenter：监视器进入，获取锁</span></span><br><span class="line">		<span class="number">4</span>: monitorexit　　 <span class="comment">// monitorexit：监视器退出，释放锁</span></span><br><span class="line">		5: invokestatic　　#16 // Method m:()V</span><br><span class="line">		<span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 方法修饰符，表示： public static synchronized</span></span><br><span class="line">	flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">		   Code:</span><br><span class="line">					stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">					<span class="number">0</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>                    

<p><img src="/images/javaconcurrent20191102002.png" alt="Alt text"><br>结论：</p>
<ul>
<li>同步块：使用了monitorenter和monitorexit指令。</li>
<li>同步方法：依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。                    </li>
</ul>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h3><p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。<br>相关方法：<br><img src="/images/javaconcurrent20191102003.png" alt="Alt text"></p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(), <span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(), <span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出如下</span></span><br><span class="line">		Thread[WaitThread,<span class="number">5</span>,main] flag is <span class="keyword">true</span>. wait @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">03</span></span><br><span class="line">		Thread[NotifyThread,<span class="number">5</span>,main] hold lock. notify @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">04</span></span><br><span class="line">		Thread[NotifyThread,<span class="number">5</span>,main] hold lock again. sleep @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">09</span></span><br><span class="line">		Thread[WaitThread,<span class="number">5</span>,main] flag is <span class="keyword">false</span>. running @ <span class="number">22</span>:<span class="number">23</span>:<span class="number">14</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true. wait</span></span><br><span class="line"><span class="string">                        @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false. running</span></span><br><span class="line"><span class="string">                @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 加锁，拥有lock的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">				<span class="comment">// 获取lock的锁，然后进行通知，通知时不会释放lock的锁，</span></span><br><span class="line">				<span class="comment">// 直到当前线程释放了lock后，WaitThread才能从wait方法中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock. notify @ "</span> +</span><br><span class="line">                        <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock again. sleep</span></span><br><span class="line"><span class="string">                @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程图：<br><img src="/images/javaconcurrent20191102003.png" alt="Alt text">        </p>
<h3 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h3><p>该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。</p>
<h4 id="等待方遵循如下原则。"><a href="#等待方遵循如下原则。" class="headerlink" title="等待方遵循如下原则。"></a>等待方遵循如下原则。</h4><ul>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ul>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	<span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">		对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通知方遵循如下原则。"><a href="#通知方遵循如下原则。" class="headerlink" title="通知方遵循如下原则。"></a>通知方遵循如下原则。</h4><ul>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程。</li>
</ul>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	改变条件</span><br><span class="line">	对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h3><p>可以理解为它是用于线程之间的数据传输，传输的媒介为内存的流。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">		<span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h3><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才<br>从thread.join()返回。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread previous = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous), String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">            previous = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" terminate."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK中Thread.join()方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁当前线程对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// 条件不满足，继续等待</span></span><br><span class="line">	<span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 条件符合，方法返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h2><h3 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool</span><br><span class="line">            &lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span></span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个简单的数据库连接池示例"><a href="#一个简单的数据库连接池示例" class="headerlink" title="一个简单的数据库连接池示例"></a>一个简单的数据库连接池示例</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; i++) &#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">				<span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool) &#123;</span><br><span class="line">			<span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty()) &#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pool.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!pool.isEmpty()) &#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池技术及其示例"><a href="#线程池技术及其示例" class="headerlink" title="线程池技术及其示例"></a>线程池技术及其示例</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池接口的默认实现：</p>
<figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;Job&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span></span><br><span class="line">            ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_</span><br><span class="line">        NUMBERS MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">			<span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count)</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.</span><br><span class="line">                    incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">					<span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">							<span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">						<span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个基于线程池技术的简单Web服务器"><a href="#一个基于线程池技术的简单Web服务器" class="headerlink" title="一个基于线程池技术的简单Web服务器"></a>一个基于线程池技术的简单Web服务器</h3><figure class="highlight java"><figcaption><span>[代码块]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool</span><br><span class="line">            &lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">				<span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">				<span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    in = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span></span><br><span class="line">                            FileInputStream(filePath)));</span><br><span class="line">                    out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    out.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    out.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    out.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    out.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                out.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                out.println(<span class="string">""</span>);</span><br><span class="line">                out.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, in, reader, out, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... closeables)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章-Java内存模型</title>
    <url>/2019/11/01/%E7%AC%AC3%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本章主要讲了JMM内存模型原理及使用volatile、锁、concurrent并发包、final域等方式来进行多线程高并发环境下编码。</p>
<h2 id="Java内存模型的基础"><a href="#Java内存模型的基础" class="headerlink" title="Java内存模型的基础"></a>Java内存模型的基础</h2><h3 id="并发编程模型的两个关键问题"><a href="#并发编程模型的两个关键问题" class="headerlink" title="并发编程模型的两个关键问题"></a>并发编程模型的两个关键问题</h3><ul>
<li>线程之间如何通信<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</li>
<li>线程之间如何同步<br>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</li>
</ul>
<h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a>Java内存模型的抽象结构</h3><p>JMM：Java内存模型。<br>两个步骤：</p>
<ul>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>线程B到主内存中去读取线程A之前已更新过的共享变量。<br><img src="/images/javaconcurrent005.png" alt="Alt text"></li>
</ul>
<h3 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a>从源代码到指令序列的重排序</h3><p><img src="/images/javaconcurrent006.png" alt="Alt text"></p>
<h3 id="并发编程模型的分类"><a href="#并发编程模型的分类" class="headerlink" title="并发编程模型的分类"></a>并发编程模型的分类</h3><p><img src="/images/javaconcurrent007.png" alt="Alt text"></p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p><img src="/images/javaconcurrent008.png" alt="Alt text"></p>
<h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><h4 id="数据依赖性-1"><a href="#数据依赖性-1" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p><img src="/images/javaconcurrent009.png" alt="Alt text"></p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>描述：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>; <span class="comment">// B</span></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/javaconcurrent010.png" alt="Alt text"></p>
<h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">		flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Public <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (f?lag) &#123; <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">			……</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/javaconcurrent011.png" alt="Alt text"></p>
<h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><ul>
<li>数据竞争与顺序一致性</li>
<li>顺序一致性内存模型</li>
<li>同步程序的顺序一致性效果</li>
<li>未同步程序的执行特性</li>
</ul>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><ul>
<li>可见性</li>
<li>原子性<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">		vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">==&gt; 等价以下代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">		vl = l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">		<span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">		temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">		set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">		<span class="keyword">return</span> vl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><p>锁是Java并发编程中最重要的同步机制。<br><img src="/images/javaconcurrent012.png" alt="Alt text"></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();　　　　 <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			a++;</span><br><span class="line">		&#125; f　　inally &#123;</span><br><span class="line">			lock.unlock();　　<span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		lock.lock();　　　　 <span class="comment">// 获取锁</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> i = a;</span><br><span class="line">			……</span><br><span class="line">		&#125; f　　inally &#123;</span><br><span class="line">			lock.unlock();　 <span class="comment">// 释放锁</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="concurrent包"><a href="#concurrent包" class="headerlink" title="concurrent包"></a>concurrent包</h3><p><img src="/images/javaconcurrent013.png" alt="Alt text"></p>
<h2 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h2><p>inal域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceEscapeExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">static</span> FinalReferenceEscapeExample obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceEscapeExample</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		i = <span class="number">1</span>; <span class="comment">// 1写final域</span></span><br><span class="line">		obj = <span class="keyword">this</span>; <span class="comment">// 2 this引用在此"逸出"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> FinalReferenceEscapeExample ();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">int</span> temp = obj.i; <span class="comment">// 4</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> DCL单例 + volatile（禁止指令重排）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>第2章-Java并发机制的底层实现原理</title>
    <url>/2019/10/31/%E7%AC%AC2%E7%AB%A0-Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>本章我们主要学习volatile轻量级锁、synchronized关键字及原子操作的原理。</p>
<h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>概念：volatile是一种轻量级的synchronized（锁）。<br>特点：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<figure class="highlight java"><figcaption><span>[案例一]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> volatile可见性、非原子性验证</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证可见性</span></span><br><span class="line">        seeOkVisibility();</span><br><span class="line">        <span class="comment">// 验证非原子性</span></span><br><span class="line">        seeNonAtomic();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seeNonAtomic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span> ; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over value:"</span> + myData.number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置可见性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">seeOkVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            myData.addTO60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated number value: "</span> + myData.number);</span><br><span class="line">        &#125;, <span class="string">"AAA"</span>).start();</span><br><span class="line">        <span class="keyword">while</span> (myData.number == <span class="number">0</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTO60</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>[案例二]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> DCL单例 + volatile（禁止指令重排）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 我是构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">"T"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>概念：锁<br>三种表现形式：</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized用的锁是存在Java对象头里的。<br><img src="/images/javaconcurrent003.png" alt="Alt text"></p>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在<br>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状<br>态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏<br>向锁升级成轻量级锁后不能降级成偏向锁。<br><img src="/images/javaconcurrent004.png" alt="Alt text"></p>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><p>概念<br>原子：不能被进一步分割的最小粒子。<br>原子操作：不可被中断的一个或一系列操作。</p>
<h3 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h3><h4 id="使用循环CAS实现原子操作"><a href="#使用循环CAS实现原子操作" class="headerlink" title="使用循环CAS实现原子操作"></a>使用循环CAS实现原子操作</h4><ul>
<li>存在几个问题<ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作<figure class="highlight java"><figcaption><span>[代码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> CAS保证原子性</span></span><br><span class="line"><span class="comment"> *  T1 100 -&gt; 101</span></span><br><span class="line"><span class="comment"> *  T2 100 -&gt; 2019</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// T1 100 -&gt; 101</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated: "</span> + atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">101</span>) + <span class="string">",value: "</span> + atomicInteger.get());</span><br><span class="line">        &#125;, <span class="string">"T1"</span>).start();</span><br><span class="line">        <span class="comment">// T2 100 -&gt; 2019</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t updated: "</span> + atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">",value: "</span> + atomicInteger.get());</span><br><span class="line">        &#125;, <span class="string">"T2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。</p>
<figure class="highlight java"><figcaption><span>[代码]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicReferenceABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">        atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">    &#125;, <span class="string">"t2"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础版</span></span><br><span class="line">    atomicReferenceABA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章-并发编程的挑战</title>
    <url>/2019/10/31/%E7%AC%AC1%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<p>该文章主要介绍了多线程环境的上下文切换和死锁场景以及如何避免、解决死锁。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p><strong>概念</strong>：任务从保存到再加载的过程就是一次上下文切换。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。</p>
<h3 id="两个案例"><a href="#两个案例" class="headerlink" title="两个案例"></a>两个案例</h3><h4 id="多线程一定快吗？"><a href="#多线程一定快吗？" class="headerlink" title="多线程一定快吗？"></a>多线程一定快吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> count = <span class="number">10000l</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		concurrency();</span><br><span class="line">		serial();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">concurrency</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">					a += <span class="number">5</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			b--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">		thread.join();</span><br><span class="line">		System.out.println(<span class="string">"concurrency :"</span> + time+<span class="string">"ms,b="</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			a += <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			b--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">		System.out.println(<span class="string">"serial:"</span> + time+<span class="string">"ms,b="</span>+b+<span class="string">",a="</span>+a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：不一定，当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。<br>为什么并发执行慢：因为线程有创建和上下文切换的开销</p>
<h4 id="测试上下文切换次数和时长"><a href="#测试上下文切换次数和时长" class="headerlink" title="测试上下文切换次数和时长"></a>测试上下文切换次数和时长</h4><p><img src="/images/javaconcurrent001.png" alt="Alt text"></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><img src="/images/javaconcurrent002.png" alt="Alt text"></p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ul>
<li>系统资源不足</li>
<li>进程间推进的顺序非法</li>
<li>资源分配不当<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">	privat <span class="keyword">static</span> String A = <span class="string">"A"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String B = <span class="string">"B"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123; Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">						System.out.println(<span class="string">"1"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">						System.out.println(<span class="string">"2"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h3 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h3><ul>
<li>jps命令定位进程号（jsp -l）</li>
<li>jstack死锁查看（jstack 进程号）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java并发编程的艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>java如何写出简洁代码</title>
    <url>/2019/10/30/java%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E7%AE%80%E6%B4%81%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>该文章主要是描述如何使用重构方法来精简代码，使代码看起来更有灵性。</p>
<h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 三次法则（事不过三，三则重构）</span><br><span class="line"><span class="number">2</span>. 何时重构：</span><br><span class="line">（<span class="number">1</span>）添加功能时重构</span><br><span class="line">（<span class="number">2</span>）修补错误时重构</span><br><span class="line">（<span class="number">3</span>）复审代码时重构</span><br><span class="line"><span class="number">3</span>. 重构优点：</span><br><span class="line">（<span class="number">1</span>）允许逻辑共享</span><br><span class="line">（<span class="number">2</span>）分开解释意图和实现</span><br><span class="line">（<span class="number">3</span>）隔离变化</span><br><span class="line">（<span class="number">4</span>）封装条件逻辑</span><br><span class="line"><span class="number">4</span>. 重构难点：</span><br><span class="line">（<span class="number">1</span>）数据库</span><br><span class="line">（<span class="number">2</span>）修改接口</span><br><span class="line">	解决办法：不要过早发布接口，请修改你的代码所有权策略，</span><br><span class="line">	使重构更顺畅。</span><br><span class="line">（<span class="number">3</span>）难以通过重构手法完成的设计改动</span><br><span class="line"><span class="number">5</span>. 重构与设计：</span><br><span class="line"> 重构肩负一项特殊使命，它和设计彼此互补。</span><br></pre></td></tr></table></figure>

<h2 id="代码坏味道"><a href="#代码坏味道" class="headerlink" title="代码坏味道"></a>代码坏味道</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duplicated Code（重复代码）</span><br><span class="line">Long Method（过长函数）</span><br><span class="line">Large Class（过大的类）</span><br><span class="line">Long Parameters List（过长参数列）</span><br><span class="line">Divergent Change（发散式变化）-&gt; 一个类受多种变化的影响</span><br><span class="line">Shotgun Surgery（霰弹式修改）-&gt; 一种变化引发多个类相应修改</span><br><span class="line">Feature Envy（依恋情结）-&gt; 将数据和数据的操作行为包装在一起的技术</span><br><span class="line">Data Clumps（数据泥团）</span><br><span class="line">Primitive Obsession（基本类型偏执）</span><br><span class="line">Switch Statements（<span class="keyword">switch</span>惊悚现身）</span><br><span class="line">Parallel Inheritance Hierarchies（平行继承行为）</span><br><span class="line">Lazy Class（冗余类）</span><br><span class="line">Sepculative Generality</span><br><span class="line">Temporary Field（令人迷惑的暂时字段）</span><br><span class="line">Message Chain（过度耦合的消息链）</span><br><span class="line">Middle Many（中间人）</span><br><span class="line">Inappropriate Intimacy（狎昵关系）</span><br><span class="line">Alternative Classes with Different Interfaces（异曲同工的类）</span><br><span class="line">Incomplete Library Class（不完善的类库）</span><br><span class="line">Data Class（纯稚的数据类）</span><br><span class="line">Refused Bequest（被拒绝的遗赠）</span><br><span class="line">Comments（过多的注释）-&gt; 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释变得多余。</span><br></pre></td></tr></table></figure>
<h2 id="构筑测试体系"><a href="#构筑测试体系" class="headerlink" title="构筑测试体系"></a>构筑测试体系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">确保所有测试都完全自动化，让它们检查自己的测试结果。</span><br><span class="line">一套测试就是一个强大的侦测器，能够大大缩短查询bug所需要的时间</span><br><span class="line">频繁的运行测试，每次编译请把测试也考虑进去————每天至少执行每个测试一次</span><br><span class="line">每当你收到bug报告，请先写一个单元测试来暴露bug.</span><br><span class="line">编写未臻完善的测试并实际运行，好过对完善测试的无尽等待。</span><br><span class="line">考虑可能出错的边界条件，把测试火力集中在那儿</span><br><span class="line">当事情被认为应该出错时，别忘了检查是否抛出了预期的异常。</span><br><span class="line">不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数的bug。</span><br></pre></td></tr></table></figure>

<h2 id="重构列表"><a href="#重构列表" class="headerlink" title="重构列表"></a>重构列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 重构记录格式：</span><br><span class="line">name、summary、motivation、mechanics、examples</span><br><span class="line">（<span class="number">1</span>）summary：</span><br><span class="line">一句话，介绍这个重构能够帮助解决的问题</span><br><span class="line">一段简述，介绍你应该做的事</span><br><span class="line">一幅速写图，简单展现重构前后示例</span><br><span class="line">（<span class="number">2</span>）mechanics：</span><br><span class="line">简短的笔记，为了让自己在一段时间不做某项重构之后还能记录怎么做。</span><br><span class="line">（<span class="number">3</span>）examples</span><br><span class="line">像是简单有趣的教科书</span><br><span class="line"><span class="number">2</span>. 寻找引用点</span><br><span class="line">（<span class="number">1</span>）如果被删除的部分在继承体系中声明不上一次</span><br><span class="line">（<span class="number">2</span>）编译器可能很慢</span><br><span class="line">（<span class="number">3</span>）编译器无法找到通过反射机制而得到的引用点</span><br></pre></td></tr></table></figure>

<h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">motivation：喜欢简短而命名良好的函数，细粒度函数，被复用的机会更大，函数的覆写也更容易些</span><br><span class="line">mechanics：</span><br><span class="line">（<span class="number">1</span>）创造一个新函数</span><br><span class="line">（<span class="number">2</span>）将提炼的代码从源函数复制到新建的目标函数中</span><br><span class="line">（<span class="number">3</span>）仔细检查提炼出的代码，看看其中是否引用了“作用域源于源函数”的变量（包括局部变量和源函数参数）</span><br><span class="line">（<span class="number">4</span>）检查是否有“仅用于被提炼代码段”的临时变量。如果有，在目标函数中将它们声明为临时变量</span><br><span class="line">（<span class="number">5</span>）检查被提炼代码段，看看是否有任何局部变量的值被它改变。</span><br><span class="line">（<span class="number">6</span>）将被提炼代码段中需要读取的局部变量，当作参数传给目标函数</span><br></pre></td></tr></table></figure>

<h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *（1）查检函数，确定它不具备多态性</span></span><br><span class="line"><span class="comment"> *（2）找出这个函数的所有被调用点</span></span><br><span class="line"><span class="comment"> *（3）将这个函数的所有被调用点都替换为函数本体</span></span><br><span class="line"><span class="comment"> *（4）编译，测试</span></span><br><span class="line"><span class="comment"> *（5）删除该函数的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moreThanFiveDeliveries() ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">moreThanFiveDelivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _numberOfLateDeliveries &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_numberOfLateDeliveries &gt; <span class="number">5</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> (basePrice &gt; <span class="number">1000</span>);</span><br><span class="line">-&gt; </span><br><span class="line"><span class="keyword">return</span> (anOrder.basePrice() &gt; <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Replace-Temp-With-Query（以查询取代临时变量）"><a href="#Replace-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Replace Temp With Query（以查询取代临时变量）"></a>Replace Temp With Query（以查询取代临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span> (basePrice &gt; <span class="number">1000</span>) </span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.98</span>;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">if</span> (basePrice() &gt; <span class="number">1000</span>) </span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.98</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Introduce-Explaing-Variable（引入解释性变量）"><a href="#Introduce-Explaing-Variable（引入解释性变量）" class="headerlink" title="Introduce Explaing Variable（引入解释性变量）"></a>Introduce Explaing Variable（引入解释性变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>) &amp;&amp; </span><br><span class="line">    (browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">    wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">final</span> boolen isMacOs = platform.toUpperCase().indexOf(<span class="string">"MAC"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">"IE"</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasResized) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice - </span><br><span class="line">        Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span> +</span><br><span class="line">        Math.min(_quantity * _itemPrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> quantityDiscount = Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> shpping = Math.min(basePrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> basePrice - quantityDiscount + shpping;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> basePrice() * quantityDiscount() * shpping();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quantityDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">0</span>, _quantity - <span class="number">500</span>) * _itemPrice * <span class="number">0.05</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">shpping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(basePrice * <span class="number">0.1</span>, <span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_heigth + _width);</span><br><span class="line">sysout(temp);</span><br><span class="line">temp = _heigth * _width;</span><br><span class="line">sysout(temp);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_heigth + _width);</span><br><span class="line">sysout(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _heigth * _width;</span><br><span class="line">sysout(area);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistanceTravelled</span><span class="params">(<span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    finall <span class="keyword">double</span> primaryAcc = _primaryForce / _mass;</span><br><span class="line">    <span class="keyword">int</span> primaryTime = Math.min(time, _delay);</span><br><span class="line">    <span class="keyword">return</span> = <span class="number">0.5</span> * primaryAcc * primaryTime * primaryTime;</span><br><span class="line">    <span class="keyword">int</span> secondaryTime = time - _delay;</span><br><span class="line">    <span class="keyword">if</span> (secondaryTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> primaryVel = primaryAcc * _delay;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> secondaryAcc = (_primaryForce + _secondaryForce) / _mass;</span><br><span class="line">        result += primaryVel * secondaryTime + <span class="number">0.5</span> * secondaryAcc * secondaryTime * secondaryTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gamma</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> importantValue1 = (inputVal * quantity) + delta();</span><br><span class="line">        <span class="keyword">int</span> importantValue2 = (inputVal * quantity) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> importantValue3 = importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line">Gamma &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Account _account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> inputVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> yearToDate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> importantValue3;</span><br><span class="line">        Gamma(source, inputVal, quantity, yearToDate) &#123;</span><br><span class="line">        _account = source;</span><br><span class="line">        inputVal = inputVal;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        importantValue1 = (inputVal * quantity) + _account.delta();</span><br><span class="line">        importantValue2 = (inputVal * quantity) + <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">        importantValue3 = importantValue2 * <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> importantValue3 - <span class="number">2</span> * importantValue1;</span><br><span class="line">    &#125;</span><br><span class="line">    -&gt;</span><br><span class="line">    importThing() &#123;</span><br><span class="line">        <span class="keyword">if</span> (yearToDate - importantValue1 &gt; <span class="number">100</span>)</span><br><span class="line">            importantValue2 -= <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gamma</span> <span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Gamma(<span class="keyword">this</span>, inputVal, quantity, yearToDate).compute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Substitude-Algorithm（替换算法）"><a href="#Substitude-Algorithm（替换算法）" class="headerlink" title="Substitude Algorithm（替换算法）"></a>Substitude Algorithm（替换算法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"Don"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"John"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (people[i].equals(<span class="string">"Kent"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span> </span>&#123; </span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="string">"Don"</span>,<span class="string">"John"</span>,<span class="string">"Kent"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; people.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (candidates.contains(people[i])) </span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：搬移函数是重构理论的支柱，解耦。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *（1）检查源类中被源函数所使用的一切特性（包括字段和函数），考虑它们是否也该被搬移。</span></span><br><span class="line"><span class="comment"> *（2）检查源类的子类和超类，看看是否有该函数的其它声明。</span></span><br><span class="line"><span class="comment"> *（3）在目标类中声明这个函数。</span></span><br><span class="line"><span class="comment"> *（4）将源函数的代码复制到目标函数中，并在源函数调用后者。</span></span><br><span class="line"><span class="comment"> *（5）编译目标类</span></span><br><span class="line"><span class="comment"> *（6）决定如何从源函数正确引用目标对象</span></span><br><span class="line"><span class="comment"> *（7）修改源函数，使之成为一个纯委托函数</span></span><br><span class="line"><span class="comment"> *（8）编译，测试</span></span><br><span class="line"><span class="comment"> *（9）决定是否删除源函数，或将它当作一个委托函数保留下来。</span></span><br><span class="line"><span class="comment"> *（10）如果要移除源函数，请将源类中对源函数的所有调用，替换为目标函数的调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">overdraftCharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**f (_type.isPreminum()) &#123;</span></span><br><span class="line"><span class="comment">            double result = 10;</span></span><br><span class="line"><span class="comment">            if (_dayOverdrawn &gt; 7) result += (_dayOverdrawn - 7) * 0.85;</span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">        else return _dayOverdrawn * 1.75;*/</span></span><br><span class="line">        <span class="keyword">return</span> _type.overdraftCharge(_dayOverdrawn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">bankCharge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">4.5</span>;</span><br><span class="line">        <span class="comment">// if (_dayOverdrawn &gt; 0) result += overdraftCharge();</span></span><br><span class="line">        <span class="keyword">if</span> (_dayOverdrawn &gt; <span class="number">0</span>)</span><br><span class="line">            result += _type.overdraftCharge(_dayOverdrawn);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountType</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">overdraftCharge</span><span class="params">(<span class="keyword">int</span> dayOverdrawn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPreminum()) &#123;</span><br><span class="line">            <span class="keyword">double</span> result = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (dayOverdrawn &gt; <span class="number">7</span>) result += (dayOverdrawn - <span class="number">7</span>) * <span class="number">0.85</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dayOverdrawn * <span class="number">1.75</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Move-Field-搬移字段"><a href="#Move-Field-搬移字段" class="headerlink" title="Move Field 搬移字段"></a>Move Field 搬移字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：在类之间移动状态与行为，是重构过程中必不可少的措施。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *  （1）如果字段的访问级是pulic，使用Encaspsulate Field将它封装起来</span></span><br><span class="line"><span class="comment"> *  （2）编译，测试</span></span><br><span class="line"><span class="comment"> *  （3）在目标类中建立与源字段相同的字段，并同时建立相应的设值/取值函数。</span></span><br><span class="line"><span class="comment"> *  （4）编译目标类。</span></span><br><span class="line"><span class="comment"> *  （5）决定如何在源对象中引用目标对象</span></span><br><span class="line"><span class="comment"> *  （6）删除源字段。</span></span><br><span class="line"><span class="comment"> *  （7）编译，测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountType _type;</span><br><span class="line">    <span class="comment">// private double _interestRate;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">interestForAmount_days</span><span class="params">(<span class="keyword">double</span> amount, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInterestRate() * amount * days / <span class="number">365</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInterestRate</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        _type.setInterestRate(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getInterestRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _type.getInterestRate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> _interestRate;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setInterestRate</span><span class="params">(<span class="keyword">double</span> arg)</span> </span>&#123;</span><br><span class="line">        _interestRate = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getInterestRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _interestRate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：单类做一件事情</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *   （1）决定如何分解类所负的责任</span></span><br><span class="line"><span class="comment"> *   （2）建立一个新类，用以表现从旧类中分离出来的责任</span></span><br><span class="line"><span class="comment"> *   （3）建立“从旧类访问新类”的连接关系</span></span><br><span class="line"><span class="comment"> *   （4）对于你想搬移的每一个字段，运用Move Field搬移</span></span><br><span class="line"><span class="comment"> *   （5）每次搬移后，重新编译</span></span><br><span class="line"><span class="comment"> *   （6）将必要函数搬移至新类，从低层函数（被其他函数调用次数&gt;调用其他函数）到高层函数</span></span><br><span class="line"><span class="comment"> *   （7）每次搬移后，重新编译</span></span><br><span class="line"><span class="comment"> *   （8）检查，精简每个类的接口。</span></span><br><span class="line"><span class="comment"> *   （9）决定是否公开新类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String _name;</span><br><span class="line">    TelephoneNumber _officeTelephone;</span><br><span class="line">    String _officeAreaCode;</span><br><span class="line">    String _officeNumber;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">    <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TelephoneNumber <span class="title">getOfficeTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">    String _areaCode;</span><br><span class="line">    String _number;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">            <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + _areaCode + <span class="string">")"</span> + _number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String _name;</span><br><span class="line">    TelephoneNumber _officeTelephone;</span><br><span class="line">    String _officeAreaCode;</span><br><span class="line">    String _officeNumber;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">    <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TelephoneNumber <span class="title">getOfficeTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _officeTelephone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span> </span>&#123;</span><br><span class="line">        String _areaCode;</span><br><span class="line">        String _number;</span><br><span class="line">        <span class="comment">// setter、getter</span></span><br><span class="line">                <span class="function">String <span class="title">getTelephoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"("</span> + _areaCode + <span class="string">")"</span> + _number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机："封装"即使不是对象的最关键特征，也是最关键特征之一。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *    （1）对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数。</span></span><br><span class="line"><span class="comment"> *    （2）调整客户</span></span><br><span class="line"><span class="comment"> *    （3）每次调整后，编译并测试</span></span><br><span class="line"><span class="comment"> *    （4）如果将来不再有任何客户需要取用Delegate，即可移除服务类</span></span><br><span class="line"><span class="comment"> *    （5）编译、测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Department _department;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    String _chargeCode;</span><br><span class="line">    Person _manager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Person manager)</span> </span>&#123;</span><br><span class="line">        _manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">-&gt; manager = john.getDepartment().getManager();</span><br><span class="line">    -&gt; manager = john.getManager();</span><br></pre></td></tr></table></figure>
<h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    Department _department;</span><br><span class="line">    <span class="comment">// setter、getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    String _chargeCode;</span><br><span class="line">    Person _manager;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Person manager)</span> </span>&#123;</span><br><span class="line">        _manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _manager;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Indroduce-Foreign-Method（引入外加函数）"><a href="#Indroduce-Foreign-Method（引入外加函数）" class="headerlink" title="Indroduce Foreign Method（引入外加函数）"></a>Indroduce Foreign Method（引入外加函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previous.getYear(), </span><br><span class="line">    previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Indroduce-Local-Extension（引入本地扩展）"><a href="#Indroduce-Local-Extension（引入本地扩展）" class="headerlink" title="Indroduce Local Extension（引入本地扩展）"></a>Indroduce Local Extension（引入本地扩展）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动机：很遗憾，类的作者无法预知未来，他们常常没能为你预先准备一些有用的函数。</span></span><br><span class="line"><span class="comment"> * 做法：</span></span><br><span class="line"><span class="comment"> *（1）建立一个扩展类，将它作为原始类的子类或包装类。</span></span><br><span class="line"><span class="comment"> *（2）在扩展中加入转型构造函数。</span></span><br><span class="line"><span class="comment"> *（3）在扩展类中加入新特性</span></span><br><span class="line"><span class="comment"> *（4）根据需要，将原对象替换为扩展对象</span></span><br><span class="line"><span class="comment"> *（5）将针对原始类定义的所有外加函数搬移到扩展中</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>齐白石的故事</title>
    <url>/2019/10/29/%E9%BD%90%E7%99%BD%E7%9F%B3%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>齐白石年少的时候家庭并不富裕，所以他16岁开始拜师学习雕花木工，给家里面赚钱。齐白石学手艺，不仅勤动手，更善动脑。他发现，师父雕的花，以及其他木工做的，翻来覆去就几个固定的式样，什么“麒麟送子”、“状元及第”，没什么新意。于是他就搞了些创新，把国画里其他的一些元素如虫草、花鸟等迁移到木雕里。起初只是试探，没想到雕出来的这些新品，颇被大家欢迎。<br>这种经历让他对国画有了强烈的兴趣，但没有人教他画，而他能看的国画画册也是比较初级的，没有什么好的资料可看，所以他一直无法真正入门学画。<br>直到二十岁的一天，齐白石在一个主顾家里干活时，发现了一套《芥子园画谱》。<br>《芥子园画谱》是一套非常经典的国画教科书。一个想学画的人看到一套画谱就如同一个想学武的人看到了一套武功秘籍，如获至宝。可是这套书是别人的，在当时又很稀少珍贵，他没法从别处得到。于是只能向书主借来，用薄竹纸覆在书页上，描红一般把原画一笔一笔勾描在竹纸上。就这样勾画了足有半年，画成十六册，才悉数描完，然后才把原书交还。<br>接下来的五年，齐白石靠这套勾描出来的《芥子园画谱》做木雕，并且闲时也反反复复拿出来临摹，勤学苦练，他画画的底子就这么打了下来。<br>后来齐白石的画在当地出了名，引来名画家收他为徒。有了专业指导后，齐白石的画技更上一层楼，终于成了一代国画大家。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>象棋的故事</title>
    <url>/2019/10/29/%E8%B1%A1%E6%A3%8B%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>茨威格曾经讲过一个象棋的故事：<br>在纳粹的集中营里，一个知识分子被关在小房间里。墙壁是白的，床单被套是白的，他也不知道时间，不知道白天和黑夜。最受折磨的不是拷打，而是没有书看了，对于一个潜心做研究的知识分子，相当于天天让他饿肚子。<br>在一次审讯的时候，他看到一本书，于是冒着生命危险偷来回去。<br>对于他来说最好的书应该是一本可以反复看很多次的，比如数学这类的，结果掏出来一看，是一本象棋的棋谱。<br>他非常的失望，但是没有办法，但这也总比没有好啊！<br>因为书很薄，于是他强迫自己每天只能看一页，但是再怎么省着看，结果还是很快看完了。<br>那怎么办呢？<br>他尝试在大脑中还原书上每一页的棋局，结果几个月下来，这本书还是又读完一遍。<br>没得读了，那怎么办？<br>他开始在脑子里自己和自己下象棋。<br>想想看，两个自我都知道对方要出什么招，这其实很难下的，但是为保持大脑的运转让自己不疯掉，他开始每天在脑子里自己和自己下棋。<br>后来，等他被逃出生天，他并不知道自己的象棋水平怎么样。<br>直到有一次他在轮船上遇到一个象棋世界冠军，他以前也没有怎么下过象棋，于是抱着开玩笑赌两把的心态开始向世界冠军讨教切磋。<br>于是结果3局下来，世界冠军都输了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>泥瓦匠的故事</title>
    <url>/2019/10/29/%E6%B3%A5%E7%93%A6%E5%8C%A0%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>讲的是一个记者去采访三个正在修教堂的泥瓦匠，问他们在干什么。<br>一个说，没看我正在忙着吗，我在干活啊；<br>第二个说，我在工作啊，我们在修一座教堂；<br>第三个说，我在建造上帝的房子，等完成了，我就可以很自豪得每周带着我的孩子来礼拜了。<br>这三个人有什么区别？<br>第一个是谋生；<br>第二个是工作；<br>第三个也是在工作，但是他找到了做这份工作的“终极目标”。<br>三个人的价值观有高低对错吗？<br>没有。<br>但你想一下，但当出现没有很多的钱，太阳太大，失败返工的时候，你觉得哪种人会坚持下来呢？<br>当我们学习，工作，做事情都依赖于制度和奖励的时候，哪一种人更容易坚持呢？<br>显然我们还需要另一种智慧。<br>不过坏消息是，这种智慧，我们在时间稀缺和循规蹈矩中，慢慢忘掉了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>管道的故事</title>
    <url>/2019/10/29/%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>故事讲的是一个村里的两个年轻人。<br>这个村常年缺水，于是这两个年轻人有了一个赚钱的机会，就是通过给村里人去很远的地方提水来赚钱。<br>这是一个很不错的生意，两个年轻人靠这个生活一点问题都没有。<br>有一天青年A就觉得这样做不行，于是他开始想，如果建一条管道，将水源处的水引过来，以后就再也不用靠自己的体力来挣钱了。于是青年A一边用一半的时间继续提水赚钱，另一半的时间用赚到的钱来铺设管道。<br>因为两头都要忙，还要把钱投入到铺设管子的的事情上，所以青年A过的很辛苦；<br>青年B觉得这事儿不靠谱，他觉得每天靠自己的提水可以赚到足够多的钱了，于是他继续每天赶着提桶取水的活，收入不错，下班还有时间花钱消遣，生活挺不错。<br>直到有一天，青年A的水管建成了。<br>水源从管子里自动流出来的时候，青年A就不用再花时间花体力自己去提水赚钱了，从那天起他就算在睡觉，也有源源不断的收入。<br>而青年B因为常年的劳动，身体越来越差了，提水的量也开始减少了，收入就越来越少了。</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>遗失的智慧</title>
    <url>/2019/10/29/%E9%81%97%E5%A4%B1%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<p>A是医院的清洁工，他每天的工作就是打扫自己负责的楼层中各个病人床位的卫生。有一个床位的病人是一个年轻人，因为被袭击受伤，已经在床上昏迷6个月了，这个期间一直都是他的父亲在看护。<br>有一天他去给这个病人的房间做清洁的时候，他的父亲刚好出去抽烟了。等他打扫完出去，他的父亲在走廊遇到他，很咆哮地质问他，为什么没有打扫他儿子的房间。事实你已经知道了，A已经打扫过了房间，但是病人的父亲认为没有。<br>如果是你是A，你会怎么办？</p>
]]></content>
      <categories>
        <category>小故事</category>
      </categories>
      <tags>
        <tag>小故事</tag>
      </tags>
  </entry>
  <entry>
    <title>github常用命令</title>
    <url>/2019/10/29/github%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="github提交一个项目"><a href="#github提交一个项目" class="headerlink" title="github提交一个项目"></a>github提交一个项目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 1.github添加新仓库jucdemo2</span><br><span class="line"># 2.添加客户端id_ras.pub秘钥（C:\Users\Czz\.ssh\id_ras.pub）</span><br><span class="line"># 3.添加远程仓库：</span><br><span class="line"># 初始化本地仓库，并提交到本地仓库</span><br><span class="line">$ cd D:\ideawk\jucdemo</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'first commit'</span></span><br><span class="line"># 关联远程仓库并推送项目</span><br><span class="line">$ git remote add origin git<span class="meta">@github</span>.com:line007/jucdemo2.git</span><br><span class="line"># 第一次推送</span><br><span class="line">$ git push -u origin master</span><br><span class="line"># 非第一次推送</span><br><span class="line">$  git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="git-checkout远程分支、标签"><a href="#git-checkout远程分支、标签" class="headerlink" title="git checkout远程分支、标签"></a>git checkout远程分支、标签</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">命令：git clone --branch [tags标签] [git地址] </span><br><span class="line">	或者 git clone --b [tags标签] [git地址]</span><br><span class="line">例如：git clone -b <span class="number">1.4</span><span class="number">.1</span> https:<span class="comment">//github.com/jumpserver/coco.git</span></span><br><span class="line"></span><br><span class="line">$ git clone -b v7<span class="number">.4</span><span class="number">.2</span> https:<span class="comment">//github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/10/29/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ cd hexo网站根据目录</span><br><span class="line"></span><br><span class="line"># 1.新建文章（测试文章）</span><br><span class="line">$ hexo <span class="keyword">new</span> 测试文章</span><br><span class="line"></span><br><span class="line"># 2.新建草稿（测试草稿）</span><br><span class="line">$ hexo <span class="keyword">new</span> draft 测试草稿</span><br><span class="line">$ hexo s --draft</span><br><span class="line"></span><br><span class="line"># 3.发布草稿（测试草稿）</span><br><span class="line">$ hexo publish 测试草稿</span><br><span class="line"></span><br><span class="line"># 4.新建类目（categories）</span><br><span class="line">$ hexo <span class="keyword">new</span> page categories</span><br><span class="line"></span><br><span class="line"># 5.引入分类（上面已经新建了类目-categories）</span><br><span class="line">## 5.1 打开 hexo根目录/source/categories/index.md</span><br><span class="line">$ vi index.md # 编辑文件index.md，新增以下内容</span><br><span class="line">type: <span class="string">"categories"</span></span><br><span class="line"></span><br><span class="line">## 5.2 在需要添加的文章中加入分类属性，如xx.md</span><br><span class="line">---</span><br><span class="line">title: github如何精确搜索项目</span><br><span class="line">date: <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">17</span>:<span class="number">16</span>:<span class="number">28</span></span><br><span class="line">categories: </span><br><span class="line">- 工具</span><br><span class="line">tags:</span><br><span class="line">- github</span><br><span class="line">- 常用命令</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 6.引入标签（如果没有创建分类tags，请先按照步骤4创建分类tags）</span><br><span class="line">打开 hexo根目录/source/tags/index.md</span><br><span class="line">$ vi index.md # 编辑文件index.md，新增以下内容</span><br><span class="line">type: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>github如何精确搜索项目</title>
    <url>/2019/10/28/github%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E6%90%9C%E7%B4%A2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">watch：会持续收到项目的动态</span><br><span class="line">fork：复制某个项目到自己的仓库</span><br><span class="line">star：可以理解为点赞</span><br><span class="line">clone：将项目下载到本地</span><br><span class="line">follow：关注你感兴趣的作者，会收到他们的动态</span><br></pre></td></tr></table></figure>

<h2 id="in关键词限制搜索范围"><a href="#in关键词限制搜索范围" class="headerlink" title="in关键词限制搜索范围"></a>in关键词限制搜索范围</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    xxx in:name 项目名包含xxx的</span><br><span class="line">    xxx in:description 项目描述包含xxx的</span><br><span class="line">    xxx in:readme 项目</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    搜索项目名或者readme中包含秒杀的项目</span><br><span class="line">        seckill in:name,readme</span><br></pre></td></tr></table></figure>        

<h2 id="stars或fork数量关键词去查找"><a href="#stars或fork数量关键词去查找" class="headerlink" title="stars或fork数量关键词去查找"></a>stars或fork数量关键词去查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    :&gt; 或者 :&gt;=</span><br><span class="line">    数字<span class="number">1.</span>.数字<span class="number">2</span></span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    查找star数大于等于<span class="number">5000</span>的springboot项目</span><br><span class="line">        springboot stars:&gt;=<span class="number">5000</span></span><br><span class="line">    查找fork数大于<span class="number">500</span>的springcloud项目</span><br><span class="line">        springcloud forks:&gt;<span class="number">500</span></span><br><span class="line">    查找fork在<span class="number">100</span>到<span class="number">200</span>之间并且stars数在<span class="number">80</span>到<span class="number">100</span>之间的springboot项目</span><br><span class="line">        springboot forks:<span class="number">100.</span><span class="number">.200</span> stars:<span class="number">80.</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>        

<h2 id="awesome加强搜索"><a href="#awesome加强搜索" class="headerlink" title="awesome加强搜索"></a>awesome加强搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    awesome 关键字</span><br><span class="line">        awesome 系列一般是用来收集学习、工具、书籍类相关的项目</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    搜索优秀的redis相关的项目，包括框架、教程等</span><br><span class="line">        awesome redis</span><br></pre></td></tr></table></figure>        

<h2 id="高亮显示某一行代码"><a href="#高亮显示某一行代码" class="headerlink" title="高亮显示某一行代码"></a>高亮显示某一行代码</h2><blockquote>
<p>地址后面紧跟#L数字<br>地址后面紧跟#L数字1-数字2                        </p>
</blockquote>
<h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><blockquote>
<p>按英文t<br><a href="https://help.github.com/en/articles/keyboard-shortcuts" target="_blank" rel="noopener" title="更多操作">更多快捷操作</a> .</p>
</blockquote>
<h2 id="搜索某个地区内的牛逼人物"><a href="#搜索某个地区内的牛逼人物" class="headerlink" title="搜索某个地区内的牛逼人物"></a>搜索某个地区内的牛逼人物</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）公式</span><br><span class="line">    location：地区</span><br><span class="line">    language：语言</span><br><span class="line">（<span class="number">2</span>）<span class="keyword">case</span></span><br><span class="line">    location:guangzhou language:java</span><br></pre></td></tr></table></figure>    
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决windows10启动内存过高</title>
    <url>/2019/10/28/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3windows10%E5%90%AF%E5%8A%A8%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98/</url>
    <content><![CDATA[<p>1.以管理员的方式运行程序 PowerShell<br><img src="/images/20191028001.png" alt="Alt text"><br>2.执行命令：<br><img src="/images/20191028002.png" alt="Alt text"><br>3.关闭缓存服务<br><img src="/images/20191028003.png" alt="Alt text"><br>4.禁用缓存计划<br><img src="/images/20191028004.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>jdk8基本用法</title>
    <url>/2019/10/28/jdk8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>该文章主要是描述了jdk8函数式接口编程的基本用法，主要包括内置四大函数式接口、函数式接口应用案例及Stream集合流式操作。以下内容都是jdk8常用的语法demo，针对每一个点都有一个小case测试。</p>
<h2 id="内置四大函数式接口"><a href="#内置四大函数式接口" class="headerlink" title="内置四大函数式接口"></a>内置四大函数式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Java四大内置函数式接口</span></span><br><span class="line"><span class="comment"> *  Consumer&lt;T&gt;：消费型接口</span></span><br><span class="line"><span class="comment"> *      void accept(T t);</span></span><br><span class="line"><span class="comment"> *  Suppler&lt;T&gt;：供给型接口</span></span><br><span class="line"><span class="comment"> *      T get();</span></span><br><span class="line"><span class="comment"> *  Function&lt;T, R&gt;：函数型接口</span></span><br><span class="line"><span class="comment"> *      R apply(T t);</span></span><br><span class="line"><span class="comment"> *  Predicate&lt;T&gt;：断言型接口</span></span><br><span class="line"><span class="comment"> *      boolean test(T t);</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKFuncInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Consumer&lt;T&gt;：消费型接口</span></span><br><span class="line">        printConsumer(<span class="string">"abcd"</span>, (x) -&gt; System.out.println(x));</span><br><span class="line">        <span class="comment">// Suppler&lt;T&gt;：供给型接口；</span></span><br><span class="line">        <span class="comment">// 案例：产生指定个数的整数，并放入集合中</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">        getNumList(num, () -&gt; <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>)).stream().forEach(System.out::println);</span><br><span class="line">        <span class="comment">// Function&lt;T, R&gt;：函数型接口；</span></span><br><span class="line">        <span class="comment">// 案例：字符串处理（转大小写、截取等）</span></span><br><span class="line">        System.out.println(strHandler(<span class="string">"abcdefg"</span>, str -&gt; str.toUpperCase()));</span><br><span class="line">        System.out.println(strHandler(<span class="string">"abcdefg"</span>, str -&gt; str.substring(<span class="number">0</span>,<span class="number">3</span>)));</span><br><span class="line">        <span class="comment">// Predicate&lt;T&gt;：断言型接口（见MyFuncInterfaceDemo）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConsumer</span><span class="params">(String str, Consumer&lt;String&gt; func)</span> </span>&#123;</span><br><span class="line">        func.accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            list.add(sup.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数式接口案例"><a href="#函数式接口案例" class="headerlink" title="函数式接口案例"></a>函数式接口案例</h2><h3 id="案例需要的初始化数据"><a href="#案例需要的初始化数据" class="headerlink" title="案例需要的初始化数据"></a>案例需要的初始化数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; list = Arrays.asList(</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="number">2500</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"lisi"</span>, <span class="number">25</span>, <span class="number">4000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"wangwu"</span>, <span class="number">35</span>, <span class="number">8000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"maliu"</span>, <span class="number">45</span>, <span class="number">9000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"tianqi"</span>, <span class="number">50</span>, <span class="number">8000</span>),</span><br><span class="line">               <span class="keyword">new</span> Employee(<span class="string">"smis"</span>, <span class="number">26</span>, <span class="number">3000</span>));</span><br></pre></td></tr></table></figure>
<h3 id="接口引用"><a href="#接口引用" class="headerlink" title="接口引用"></a>接口引用</h3><h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_normal</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmpByAge(list);</span><br><span class="line">    System.out.println(<span class="string">"----------大于25岁的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">    newList = filterEmpBySalary(newList);</span><br><span class="line">    System.out.println(<span class="string">"----------薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_strategy</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, <span class="keyword">new</span> AgePredicateStrategy());</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">    newList = filterEmployee(newList, <span class="keyword">new</span> SalaryPredicateStrategy());</span><br><span class="line">    System.out.println(<span class="string">"----------薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_inner_class</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_lambda</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*filterEmployee(list, (Employee e) -&gt; &#123;return e.getAge() &gt; 25 &amp;&amp; e.getSalary() &gt; 5000;&#125;);</span></span><br><span class="line"><span class="comment">    filterEmployee(list, (Employee e) -&gt; e.getAge() &gt; 25 &amp;&amp; e.getSalary() &gt; 5000);*/</span></span><br><span class="line">    List&lt;Employee&gt; newList = filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    newList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_stream01</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>).stream()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_stream02</span><span class="params">(List&lt;Employee&gt; list)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----------年龄大于25岁 &amp;&amp; 薪资大于5K的-----------"</span>);</span><br><span class="line">    filterEmployee(list, (e) -&gt; e.getAge() &gt; <span class="number">25</span> &amp;&amp; e.getSalary() &gt; <span class="number">5000</span>).stream()</span><br><span class="line">            .map(Employee::getName)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><h4 id="对象-实例方法"><a href="#对象-实例方法" class="headerlink" title="对象::实例方法"></a>对象::实例方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_instance_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintStream ps1 = System.out;</span><br><span class="line">    Consumer&lt;String&gt; str1 = (x) -&gt; ps1.println(x);</span><br><span class="line">    str1.accept(<span class="string">"abc1"</span>);</span><br><span class="line">    PrintStream ps2 = System.out;</span><br><span class="line">    Consumer&lt;String&gt; str2 = ps2::println;</span><br><span class="line">    str2.accept(<span class="string">"abc2"</span>);</span><br><span class="line">    Consumer&lt;String&gt; str3 = System.out::println;</span><br><span class="line">    str3.accept(<span class="string">"abc3"</span>);</span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">    Supplier&lt;String&gt; funcName = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(funcName.get());</span><br><span class="line">    Supplier&lt;Integer&gt; funcAge = emp::getAge;</span><br><span class="line">    System.out.println(funcAge.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类-静态方法名"><a href="#类-静态方法名" class="headerlink" title="类::静态方法名"></a>类::静态方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_static_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(com.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compareTo;</span><br><span class="line">    System.out.println(com2.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类-实例方法名"><a href="#类-实例方法名" class="headerlink" title="类::实例方法名"></a>类::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_normal_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器引用（实例名-new）"><a href="#构造器引用（实例名-new）" class="headerlink" title="构造器引用（实例名::new）"></a>构造器引用（实例名::new）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_constructor_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt; funcEmp = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">    System.out.println(funcEmp.get());</span><br><span class="line">    Supplier&lt;Employee&gt; funcEmp2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(funcEmp2.get());</span><br><span class="line">    <span class="comment">// 指定调用构造方法</span></span><br><span class="line">    Function&lt;Integer, Employee&gt; funcEmpAge = (x) -&gt; <span class="keyword">new</span> Employee(x);</span><br><span class="line">    System.out.println(funcEmpAge.apply(<span class="number">101</span>));</span><br><span class="line">    Function&lt;Integer, Employee&gt; funcEmpAge2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(funcEmpAge2.apply(<span class="number">102</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_array_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; funcArray = (x) -&gt; <span class="keyword">new</span> String[x];</span><br><span class="line">    String[] strs = funcArray.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(strs.length);</span><br><span class="line">    Function&lt;Integer, String[]&gt; funcArray2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] strs2 = funcArray.apply(<span class="number">20</span>);</span><br><span class="line">    System.out.println(strs2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Stream常规操作"><a href="#Stream常规操作" class="headerlink" title="Stream常规操作"></a>Stream常规操作</h2><h3 id="创建Stream的几种方式"><a href="#创建Stream的几种方式" class="headerlink" title="创建Stream的几种方式"></a>创建Stream的几种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_create_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().stream();</span><br><span class="line">    Stream&lt;String&gt; stream2 = Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line">    Stream&lt;String&gt; stream3 = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    Stream&lt;Integer&gt; stream4 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>); <span class="comment">// 无限流</span></span><br><span class="line">    stream4.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    Stream.generate(() -&gt; Math.random())</span><br><span class="line">            .limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="流转集合的几种方式"><a href="#流转集合的几种方式" class="headerlink" title="流转集合的几种方式"></a>流转集合的几种方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_collect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = employees.stream().map(Employee::getName).collect(Collectors.toList());</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">    Set&lt;String&gt; set = employees.stream().map(Employee::getName).collect(Collectors.toSet());</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">    HashSet&lt;String&gt; hashSet = employees.stream().map(Employee::getName).collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">    hashSet.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><h4 id="总数、平均值、最小值"><a href="#总数、平均值、最小值" class="headerlink" title="总数、平均值、最小值"></a>总数、平均值、最小值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_count1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"总数："</span> + employees.stream().collect(Collectors.counting()));</span><br><span class="line">    System.out.println(<span class="string">"平均值："</span> + employees.stream().collect(Collectors.averagingDouble(Employee::getSalary)));</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().collect(Collectors.minBy((x, y) -&gt; Double.compare(x.getSalary(), y.getSalary()))).get()); <span class="comment">// 已过时</span></span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().min(Comparator.comparing(Employee::getSalary)).get());</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + employees.stream().min(Comparator.comparing(Employee::getSalary).thenComparing(Employee::getAge)).get());</span><br><span class="line">    System.out.println(<span class="string">"------------另一种方式-----------"</span>);</span><br><span class="line">    DoubleSummaryStatistics collect = employees.stream().collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">    System.out.println(<span class="string">"总数："</span> + collect.getCount());</span><br><span class="line">    System.out.println(<span class="string">"平均值："</span> + collect.getAverage());</span><br><span class="line">    System.out.println(<span class="string">"最小值："</span> + collect.getMin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_to_count2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 归约</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    Integer sum = list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    Integer amount1 = employees.stream().map(Employee::getSalary).reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(amount1);</span><br><span class="line">    Integer amount2 = employees.stream().map(Employee::getSalary).reduce(Integer::sum).get();</span><br><span class="line">    System.out.println(amount2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_append_str</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = employees.stream().map(Employee::getName).collect(Collectors.joining(<span class="string">","</span>,<span class="string">"("</span>,<span class="string">")"</span>));</span><br><span class="line">    System.out.println(<span class="string">"str="</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组、分区"><a href="#分组、分区" class="headerlink" title="分组、分区"></a>分组、分区</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_groupby_partitioningBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按员工类型分组</span></span><br><span class="line">    Map&lt;Employee.EmployeeType, Long&gt; map1 = employees.stream().collect(Collectors.groupingBy(Employee::getEmployeeType, Collectors.counting()));</span><br><span class="line">    System.out.println(map1);</span><br><span class="line">    <span class="comment">// 按员工类型 + 薪资分组</span></span><br><span class="line">    Map&lt;Employee.EmployeeType, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map2 = employees.stream().collect(Collectors.groupingBy(Employee::getEmployeeType, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSalary() &gt;= <span class="number">8000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"高收入"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSalary() &gt;= <span class="number">4000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"中收入"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"解决温饱"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)));</span><br><span class="line">    System.out.println(map2);</span><br><span class="line">    <span class="comment">// 按薪资分区，&gt;=8000 一个区，另外一个区</span></span><br><span class="line">    Map&lt;Boolean, List&lt;Employee&gt;&gt; map3 = employees.stream().collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt;= <span class="number">8000</span>));</span><br><span class="line">    System.out.println(map3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdk8语法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2019/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>该文章主要是学习数据结构（链表、栈、哈希表、树、图）和算法（排序算法、程序员常用10大算法），针对每个结构都有一个小case测试验证。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>一种数据结构，包括单向链表、双向链表、单向环形链表</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 单链表demo</span></span><br><span class="line"><span class="comment"> *  1.链表添加</span></span><br><span class="line"><span class="comment"> *      1.1 普通添加</span></span><br><span class="line"><span class="comment"> *      1.2 顺序添加</span></span><br><span class="line"><span class="comment"> *  2.遍历</span></span><br><span class="line"><span class="comment"> *  3.删除</span></span><br><span class="line"><span class="comment"> *  4.修改</span></span><br><span class="line"><span class="comment"> *  5.查找倒数第k个元素</span></span><br><span class="line"><span class="comment"> *  6.链表反转</span></span><br><span class="line"><span class="comment"> *      6.1 数组方式反转</span></span><br><span class="line"><span class="comment"> *      6.2 栈的方式反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/8/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 添加操作</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">/*// 1.1 正常添加</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">        singleLinkedList.add(hero4);*/</span></span><br><span class="line">        <span class="comment">// 1.2 顺序添加</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        <span class="comment">// 2.遍历</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------------"</span>);</span><br><span class="line">        <span class="comment">// 3.修改</span></span><br><span class="line">        HeroNode editHero = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨2"</span>);</span><br><span class="line">        singleLinkedList.update(editHero);</span><br><span class="line">        System.out.println(<span class="string">"修改后-----------------------"</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">// 4.删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除后-----------------------"</span>);</span><br><span class="line">        <span class="keyword">int</span> no = <span class="number">3</span>;</span><br><span class="line">        singleLinkedList.del(no);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">// 5.查找倒数第k个元素</span></span><br><span class="line">        HeroNode head = singleLinkedList.getHead();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>; <span class="comment">// 倒数第1个</span></span><br><span class="line">        HeroNode lastIndexNode = singleLinkedList.findLastIndexNode(head, index);</span><br><span class="line">        System.out.println(<span class="string">"倒数第"</span>+index+<span class="string">"个元素是：\n"</span>+lastIndexNode);</span><br><span class="line">        <span class="comment">// 6.链表反转</span></span><br><span class="line">        System.out.println(<span class="string">"反转后--------------"</span>);</span><br><span class="line"><span class="comment">//        singleLinkedList.reverseByArray(head);</span></span><br><span class="line">        singleLinkedList.reverseByStack(head);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 双向链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line">        <span class="comment">// 添加操作</span></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        <span class="comment">// 1.1 正常添加</span></span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">// 3.修改</span></span><br><span class="line">        HeroNode editHero = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>, <span class="string">"及时雨2"</span>);</span><br><span class="line">        doubleLinkedList.update(editHero);</span><br><span class="line">        System.out.println(<span class="string">"修改后-----------------------"</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">// 4.删除</span></span><br><span class="line">        System.out.println(<span class="string">"删除后-----------------------"</span>);</span><br><span class="line">        <span class="keyword">int</span> no = <span class="number">3</span>;</span><br><span class="line">        doubleLinkedList.del(no);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单向环形链表（约瑟夫问题）"><a href="#单向环形链表（约瑟夫问题）" class="headerlink" title="单向环形链表（约瑟夫问题）"></a>单向环形链表（约瑟夫问题）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 单向环形列表</span></span><br><span class="line"><span class="comment"> * 1.约瑟夫问题：</span></span><br><span class="line"><span class="comment"> *  设编号为1，2，...n的n个人围坐一圈，约定编号为k(1&lt;=k&lt;=n)的人</span></span><br><span class="line"><span class="comment"> *  从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，</span></span><br><span class="line"><span class="comment"> *  依次类推，直到所有人出列为止，由此产生一个环形队列</span></span><br><span class="line"><span class="comment"> * 2.假设问题：</span></span><br><span class="line"><span class="comment"> *  n = 5 有5个人</span></span><br><span class="line"><span class="comment"> *  k = 1 从第一个人开始</span></span><br><span class="line"><span class="comment"> *  m = 2 每次数2下</span></span><br><span class="line"><span class="comment"> * 3.思路分析：</span></span><br><span class="line"><span class="comment"> * （1）定义一个辅助变量helper，指向最后一个节点</span></span><br><span class="line"><span class="comment"> * （2）当小孩报数时，first、helper同时移动 m-1 次（每次是从自己开始数）</span></span><br><span class="line"><span class="comment"> * （3）这时，可以将first指向的小孩节点出圈</span></span><br><span class="line"><span class="comment"> *      first = first.next</span></span><br><span class="line"><span class="comment"> *      helper.next = first</span></span><br><span class="line"><span class="comment"> *      原来的first节点没有任何引用，就会被回收</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 数据模拟栈</span></span><br><span class="line"><span class="comment"> * 1.使用数组模拟栈 arr = new Array[maxSize]</span></span><br><span class="line"><span class="comment"> * 2.定义一个top表示顶</span></span><br><span class="line"><span class="comment"> * 3.入栈 arr[++top] = data</span></span><br><span class="line"><span class="comment"> * 4.出栈 return arr[--top]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack arrayStack = <span class="keyword">new</span> ArrayStack(<span class="number">3</span>);</span><br><span class="line">        arrayStack.push(<span class="number">1</span>);</span><br><span class="line">        arrayStack.push(<span class="number">2</span>);</span><br><span class="line">        arrayStack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现统合计数器"><a href="#实现统合计数器" class="headerlink" title="实现统合计数器"></a>实现统合计数器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 波兰计算器</span></span><br><span class="line"><span class="comment"> *  suffixExpression=(30+4)*5-6 =&gt; 30 4 + 5 * 6 - =&gt; 164</span></span><br><span class="line"><span class="comment"> * 1.将suffixExpression放入ArrayList中 [30, 4, +, 5, *, 6, -]</span></span><br><span class="line"><span class="comment"> * 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 中缀转后缀表达式</span></span><br><span class="line"><span class="comment"> * 1.初始化两个栈：运算符栈s1和存储结果栈s2</span></span><br><span class="line"><span class="comment"> * 2.从左至右扫描中缀表达式</span></span><br><span class="line"><span class="comment"> * 3.遇到数字时，将其压入s2</span></span><br><span class="line"><span class="comment"> * 4.遇到运算符时，比较其与s1栈顶运算符的优先级；</span></span><br><span class="line"><span class="comment"> * （1）如果s1为空，或栈顶运算符为左括号“（”，则直接将些运算符入栈s1；</span></span><br><span class="line"><span class="comment"> * （2）否则，若优先级比栈顶优先级高，也将运算符压入s1</span></span><br><span class="line"><span class="comment"> * （3）否则，将s1栈顶的运算符弹出并压入s2中，再次转到（4.1）与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="comment"> * 5.遇到括号时：</span></span><br><span class="line"><span class="comment"> * （1）如果是“（”，则直接压入s1</span></span><br><span class="line"><span class="comment"> * （2）如果是“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到“（”为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="comment"> * 6.重复步骤2-5，一直到表达式的最右边</span></span><br><span class="line"><span class="comment"> * 7.将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line"><span class="comment"> * 8.依次弹出s2中的元素并输出，结果的逆序即为表达式对应的后缀表达式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中缀转后缀表达式</span></span><br><span class="line">        <span class="comment">/*String expression = "(30+4)*5-6"; // 30 4 + 5 * 6 - =&gt; 164</span></span><br><span class="line"><span class="comment">        expression = "4*5-8+60+8/2"; // 4 5 * 8 - 60 + 8 2 / + =&gt; 76</span></span><br><span class="line"><span class="comment">        List&lt;String&gt; list = infixToSuffixExpression(expression);</span></span><br><span class="line"><span class="comment">        System.out.println("后缀表达式：" + list);</span></span><br><span class="line"><span class="comment">        int res = calculate(list);</span></span><br><span class="line"><span class="comment">        System.out.println("res=" + res);*/</span></span><br><span class="line">        <span class="comment">// 长+2x（宽+高）&gt;100cm =&gt; (%s+%s*(%s+%s))&gt;%s</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">10</span>;</span><br><span class="line">        String expression = String.format(<span class="string">"(%s+2*(%s+%s))&gt;%s"</span>, length, width, height, <span class="number">100</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>, expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">// 长&gt;100CM 或者 宽&gt;100cm</span></span><br><span class="line">        length = <span class="number">120</span>;</span><br><span class="line">        width = <span class="number">77</span>;</span><br><span class="line">        expression = String.format(<span class="string">"%s&gt;%s|%s&gt;%s"</span>, length, <span class="number">100</span>, width, <span class="number">100</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>,expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">// 重量&gt;100kg</span></span><br><span class="line">        <span class="keyword">double</span> weight = <span class="number">100.75</span>;</span><br><span class="line">        expression = String.format(<span class="string">"%s&gt;%s"</span>, weight, <span class="number">100.75</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s=&gt;%s"</span>, expression, calculate2(infixToSuffixExpression(expression)).intValue()));</span><br><span class="line">        <span class="comment">/*System.out.println(1|0|0|0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(1|0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(0|0); // 0</span></span><br><span class="line"><span class="comment">        System.out.println(1&amp;1&amp;0); // 1</span></span><br><span class="line"><span class="comment">        System.out.println(1&amp;0); // 0</span></span><br><span class="line"><span class="comment">        System.out.println(0&amp;0); // 0*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="打印、阶乘问题"><a href="#打印、阶乘问题" class="headerlink" title="打印、阶乘问题"></a>打印、阶乘问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 打印问题</span></span><br><span class="line"><span class="comment"> * （1）打印</span></span><br><span class="line"><span class="comment"> * （2）阶乘</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionPrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印问题</span></span><br><span class="line">        test1(<span class="number">4</span>); <span class="comment">// 2 3 4</span></span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        test2(<span class="number">4</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 阶乘 4x3x2x1</span></span><br><span class="line">        System.out.println(factorial(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶乘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test1(n -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出什么？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test2(n -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 迷宫问题</span></span><br><span class="line"><span class="comment"> * 1.初始化一个8行7列的矩阵 map[8][7]</span></span><br><span class="line"><span class="comment"> * 2.假设：</span></span><br><span class="line"><span class="comment"> * （1）三种类型：0-还没有走,1-档板,2-可以走（已走）,3-走不通</span></span><br><span class="line"><span class="comment"> * （2）策略：下-》右-》下-》左</span></span><br><span class="line"><span class="comment"> * （3）初始值：周围都是1</span></span><br><span class="line"><span class="comment"> * 3.过程分析：</span></span><br><span class="line"><span class="comment"> * （1）已经找到（确定找到的条件：第7行6列即为找到 =》 [6,5]=2）</span></span><br><span class="line"><span class="comment"> * （2）还没有找到按策略去找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MingGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.初始化一个8行7列的矩阵arr[8][7]</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 2.初始值：周围都是1</span></span><br><span class="line">        <span class="comment">// 第1行和第8行设置档板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第1列和第7列设置档板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出矩阵</span></span><br><span class="line">        print(map);</span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line">        <span class="comment">// 设置档板 [3,1]=1,[3,2]=1</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        print(map);</span><br><span class="line">        <span class="comment">// 策略：下-》右-》上-》左</span></span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从[1,1]这个位置开始</span></span><br><span class="line">        System.out.println(<span class="string">"策略:下-》右-》上-》左 =&gt;"</span>);</span><br><span class="line">        print(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 8皇后问题</span></span><br><span class="line"><span class="comment"> * 1.是什么？</span></span><br><span class="line"><span class="comment"> *  8x8的矩阵，任意两个位置不能处于同一行、同一列或同一斜线，能找出多少种解法，这就是8皇后问题</span></span><br><span class="line"><span class="comment"> * 2.思路分析</span></span><br><span class="line"><span class="comment"> * （1）第一个皇后放第一行第一列[0,0]</span></span><br><span class="line"><span class="comment"> * （2）第二个皇后放第二行第一列[1,0]...直到判断ok，</span></span><br><span class="line"><span class="comment"> *      如果不ok，继续放在第二列、第三列、依次把所有列放完，找到一个合适位置</span></span><br><span class="line"><span class="comment"> * （3）继续第三个皇后，还是第一列、第二列...直到第8个皇后也放在一个不冲突的位置，</span></span><br><span class="line"><span class="comment"> *      算是找到一个正确解</span></span><br><span class="line"><span class="comment"> * （4）当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放在第一列的所有正确解，全部得到</span></span><br><span class="line"><span class="comment"> * （5）然后回头继续第一个皇后放第二列，后面继续循环执行1-4步骤</span></span><br><span class="line"><span class="comment"> * 3.说明</span></span><br><span class="line"><span class="comment"> *  理论上创建一个二维数组来表示一个棋盘，但实际上可以通过算法，</span></span><br><span class="line"><span class="comment"> *  用一个一维数组即可解决 arr[8] = &#123;0, 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line"><span class="comment"> *  // arr[0] = 0 表示第1个皇后（第一行）放在第1列，即[0,0]</span></span><br><span class="line"><span class="comment"> *  // arr[1] = 4 表示第2个皇后（第二行）放在第5列，即[1,4]</span></span><br><span class="line"><span class="comment">  * 下标表示第几行 即第几个皇后</span></span><br><span class="line"><span class="comment"> *  arr[i] = val，val表示第i+1个皇后放在第i+1行的第val+1列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queen8</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            System.out.print(String.format(<span class="string">"R%s\t"</span>, i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Queen8 queen8 = <span class="keyword">new</span> Queen8(<span class="number">8</span>);</span><br><span class="line">        queen8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"共有%s种解法"</span>, queen8.count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 冒泡排序</span></span><br><span class="line"><span class="comment"> *  案例：arr[] = &#123;3, 9, -1, 10, 20&#125;</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1.两层for循环遍历待排序的数组，i的index=[0,arr.length-1],j的index=[0,arr.length-1-i]</span></span><br><span class="line"><span class="comment"> *  （1）length-1：每一轮循环是两个数比较，所以-1</span></span><br><span class="line"><span class="comment"> *  （2）length-1-i：-1跟同上；每一轮结束会有一个最小值到数组最末端，所以每次-i</span></span><br><span class="line"><span class="comment"> * 2.如果 arr[j] &gt; arr[j+1] 交换两个值的位置（arr[j] = arr[j+1]），需要用temp临时变量保存arr[j]的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 直接交换是不行的，值会覆盖</span></span><br><span class="line">                    <span class="comment">/*arr[j] = arr[j+1];</span></span><br><span class="line"><span class="comment">                    arr[j+1] = arr[j];*/</span></span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮过后，arr="</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 选择排序</span></span><br><span class="line"><span class="comment"> * arr[] = &#123;101, 34, 119, 1&#125;</span></span><br><span class="line"><span class="comment"> * （1）第一次从arr[0]~arr[n]中选取最小值，与arr[0]交换</span></span><br><span class="line"><span class="comment"> * （2）第二次从arr[1]~arr[n]中选取最小值，与arr[1]交换</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> * （3）第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换</span></span><br><span class="line"><span class="comment"> * （4）第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// arr.length - 1 只要n-1次就能排好顺序</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// i+1，每结束一轮，最小下标往后移</span></span><br><span class="line">                <span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 不是最小值</span></span><br><span class="line">                    min = arr[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到最小值，与arr[0]交换，并放在第一个位置，即arr[0]</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123; <span class="comment">// 最小下标发生改变，才调整位置</span></span><br><span class="line">                arr[minIndex] = arr[i]; <span class="comment">// [101, 34, 119, 1] =&gt; [34, 101, 119, 1]</span></span><br><span class="line">                arr[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮过后，arr="</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 插入排序</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  （1）把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中含有n-1个元素</span></span><br><span class="line"><span class="comment"> *  （2）排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序的排序码进行比较，将它插入到有序表中的适当位置，</span></span><br><span class="line"><span class="comment"> *      使之成为新的有序节点</span></span><br><span class="line"><span class="comment"> * 实例：</span></span><br><span class="line"><span class="comment"> *  &#123;101, 34, 119, 1&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">34</span>, <span class="number">101</span>, <span class="number">119</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[160000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 160000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        insert_sort2(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序（plus版插入排序）"><a href="#希尔排序（plus版插入排序）" class="headerlink" title="希尔排序（plus版插入排序）"></a>希尔排序（plus版插入排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 希尔排序</span></span><br><span class="line"><span class="comment"> *  它是一种更高效的插入排序，也称为缩小增量排序。</span></span><br><span class="line"><span class="comment"> *  产生原因：</span></span><br><span class="line"><span class="comment"> *      由于插入排序存在问题，当需要插入数最小时，后移的次数明显增多，对效率有影响</span></span><br><span class="line"><span class="comment"> *  基本思想：</span></span><br><span class="line"><span class="comment"> *      把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；</span></span><br><span class="line"><span class="comment"> *      随着增量减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line"><span class="comment">        shellSort2(arr);</span></span><br><span class="line"><span class="comment">        System.out.println("第1轮过后，arr=" + Arrays.toString(arr));*/</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> Random().nextInt(<span class="number">8000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        shellSort2(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序（plus版冒泡排序）"><a href="#快速排序（plus版冒泡排序）" class="headerlink" title="快速排序（plus版冒泡排序）"></a>快速排序（plus版冒泡排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 快速排序</span></span><br><span class="line"><span class="comment"> * 思想：</span></span><br><span class="line"><span class="comment"> * （1）将一个数组分割成左右两部分</span></span><br><span class="line"><span class="comment"> * （2）分操作</span></span><br><span class="line"><span class="comment"> *      A.左边进行递归冒泡排序，直到有序</span></span><br><span class="line"><span class="comment"> *      B.右边进行递归冒泡排序，直到有序</span></span><br><span class="line"><span class="comment"> * （3）合操作（左边 + 右边）</span></span><br><span class="line"><span class="comment"> * （4）依次执行1-3步骤，直到有序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;-9,78,0,23,-567,70&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">23</span>, -<span class="number">567</span>, <span class="number">70</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 归并排序</span></span><br><span class="line"><span class="comment"> *  利用分治策略，分而治之，即先分再合</span></span><br><span class="line"><span class="comment"> * （1）分</span></span><br><span class="line"><span class="comment"> *      A.找到中间下标mid</span></span><br><span class="line"><span class="comment"> *      B.向左递归</span></span><br><span class="line"><span class="comment"> *      C.向右递归</span></span><br><span class="line"><span class="comment"> * （2）治</span></span><br><span class="line"><span class="comment"> *      A.将左右两边（有序）的数据按照规则填充到temp数组，直到左右两边的有序序列有一边处理完毕为止</span></span><br><span class="line"><span class="comment"> *      B.把剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line"><span class="comment"> *      C.将temp数组的元素拷贝到arr（注意，并不是每次都拷贝所有！！！）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">// 归并排序需要额外的一个数组</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(LocalDateTime.now());</span></span><br><span class="line"><span class="comment">        int[] temp = new int[arr.length]; // 归并排序需要额外的一个数组</span></span><br><span class="line"><span class="comment">        mergeSort(arr, 0, arr.length - 1, temp);</span></span><br><span class="line"><span class="comment">        System.out.println(LocalDateTime.now());*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 基数排序</span></span><br><span class="line"><span class="comment"> * 特别说明：</span></span><br><span class="line"><span class="comment"> *      该demo不支持负数排序，如想实现负数排序，请参考https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> * 排序思想：</span></span><br><span class="line"><span class="comment"> * （1）将所有比较数值统一为同样的数位长度，数位较短的数前面补0。</span></span><br><span class="line"><span class="comment"> * （2）然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序</span></span><br><span class="line"><span class="comment"> *      完成后，数列就变成一个有序序列了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;53, 3, 542, 748, 14, 214&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        System.out.println(<span class="string">"arr="</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>（1）速度方面：桶排序、快速排序、希尔排序、插入排序、选择排序、冒泡排序<br>（2）归并排序需要一个arr[length]的额外数组<br>（3）基数排序需要一个arr[10][length]的二维数组</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二分查找</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;1, 8, 10, 89, 1000, 1234&#125;</span></span><br><span class="line"><span class="comment"> * 一、思路分析（返回第一个）：</span></span><br><span class="line"><span class="comment"> *  1.首先确定该数组的中间下标</span></span><br><span class="line"><span class="comment"> *      mid = (left + right) / 2</span></span><br><span class="line"><span class="comment"> *  2.然后让需要查找的数findVal与arr[mid]比较</span></span><br><span class="line"><span class="comment"> *  2.1 findVal &gt; arr[mid]，说明要查找的数在右边，需要向右递归</span></span><br><span class="line"><span class="comment"> *  2.2 findVal &lt; arr[mid]，说明要查找的数在左边，需要向左递归</span></span><br><span class="line"><span class="comment"> *  2.3 findVal == arr[mid]，说明已经找到了，返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  问题：结束递归的条件是什么?</span></span><br><span class="line"><span class="comment"> *  1) 找到就结束递归</span></span><br><span class="line"><span class="comment"> *  2) 递归完整个数组，仍然没找到findVal，也需要结束递归，当left&gt;right就需要退出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、思路分析（返回所有符合条件的下标）：</span></span><br><span class="line"><span class="comment"> *  1.在找到mid索引值时，不要立马返回</span></span><br><span class="line"><span class="comment"> *  2.向mid索引值的左边扫描，将所有满足条件元素的下标，加入到集合</span></span><br><span class="line"><span class="comment"> *  3.向mid索引值的右边扫描，将所有满足条件元素的下标，加入到集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="comment">// （1）使用二分查找，返回第一个符合条件的下标</span></span><br><span class="line">        <span class="keyword">int</span> findVal = <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">0</span>, arr.length, findVal);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （2）使用二分查找，返回所有符合条件的下标数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1000</span>, <span class="number">8</span>, <span class="number">1000</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        findVal = <span class="number">1000</span>;</span><br><span class="line">        List&lt;Integer&gt; resIndexList = binarySearch2(arr2, <span class="number">0</span>, arr2.length, findVal);</span><br><span class="line">        System.out.println(<span class="string">"arr2="</span> + resIndexList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 插值查找算法</span></span><br><span class="line"><span class="comment"> *  由于二分查找针对大数据量首、末两端的查找位移次数太多，影响性能，所以出现了动态中间下标，即插值查找算法。</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  int mid = left + (right - left)*(findVal - arr[left])/(arr[right] - arr[left])</span></span><br><span class="line"><span class="comment"> *  如：arr = &#123;1,2,3...100&#125;</span></span><br><span class="line"><span class="comment"> *  （1）查找1</span></span><br><span class="line"><span class="comment"> *      mid = 0 + (99 - 0)*(1 - 1)/(100 - 1) =&gt; 0 + 99 * 0/99 = 0</span></span><br><span class="line"><span class="comment"> *  （2）查找100</span></span><br><span class="line"><span class="comment"> *      mid = 0 + (99 - 0)*(100 - 1)/(100 - 1) =&gt; 0 + 99 * 99/99 = 99</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;1,2,3...100&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = Stream.iterate(<span class="number">1</span>, x -&gt; x+<span class="number">1</span>).limit(<span class="number">100</span>).collect(Collectors.toList()).toArray(<span class="keyword">new</span> Integer[<span class="number">100</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">100</span>); <span class="comment">// arr.length - 1</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="斐波那契算法（黄金分割算法）"><a href="#斐波那契算法（黄金分割算法）" class="headerlink" title="斐波那契算法（黄金分割算法）"></a>斐波那契算法（黄金分割算法）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 斐波那契查找算法</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * 1.原理与二分查找、插值查找类似，也是通过改变mid值（该值在黄金分割点附近）位置，算法：mid = low + f[k-1] - 1</span></span><br><span class="line"><span class="comment"> *  f代码斐波那契数列</span></span><br><span class="line"><span class="comment"> *  （1）斐波那契数列特点：f[k] = f[k-1] + f[k-2] =&gt; (f[k] - 1) = (f[k-1]-1) + (f[k-2]-1) + 1</span></span><br><span class="line"><span class="comment"> *      假设顺序表长度为：length = (f[k] - 1) ，刚好可以分成 f[k-1]-1和f[k-2]-1两部分</span></span><br><span class="line"><span class="comment"> *      即中间位置 mid = low + (f[k-1] - 1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  &#123;1, 1, 2, 3, 5, 8, 13, 21, 34, 55&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">12</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">56</span>, <span class="number">87</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = fibSearch(arr, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="简单的员工添加、查询"><a href="#简单的员工添加、查询" class="headerlink" title="简单的员工添加、查询"></a>简单的员工添加、查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 哈希表案例</span></span><br><span class="line"><span class="comment"> *  有一个公司，当有新员式来报道时，要求该员工的信息加入</span></span><br><span class="line"><span class="comment"> *  （id，性别，年龄，名字、住址），当输入该员工的id时，要求查询该员工的所有信息</span></span><br><span class="line"><span class="comment"> *  要求：</span></span><br><span class="line"><span class="comment"> *  不使用数据库，速度越快越好=&gt; 哈希表（散列）</span></span><br><span class="line"><span class="comment"> *  添加时，保证按照id从低至高的顺序插入？</span></span><br><span class="line"><span class="comment"> *  （1）使用链表来实现哈希表，该链表不带表头，即：链表的第一个结点放存放雇员</span></span><br><span class="line"><span class="comment"> *  （2）思路分析并画出示意图</span></span><br><span class="line"><span class="comment"> *  （3）代码实现【增删改查（显示所有员工，按id查询）】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashTab hashTab = <span class="keyword">new</span> HashTab();</span><br><span class="line">        String key;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"add: 添加雇员"</span>);</span><br><span class="line">            System.out.println(<span class="string">"list: 显示雇员"</span>);</span><br><span class="line">            System.out.println(<span class="string">"find: 查找"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit: 退出系统"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入id"</span>);</span><br><span class="line">                    <span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请输入名字"</span>);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入id"</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树结构基础部分"><a href="#树结构基础部分" class="headerlink" title="树结构基础部分"></a>树结构基础部分</h4><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二叉树遍历</span></span><br><span class="line"><span class="comment"> *  案例：1-宋江、2-吴用、3-卢俊义、4-林冲</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.前、中、后序遍历</span></span><br><span class="line">        test_simple_order();</span><br><span class="line">        <span class="comment">// 2.查找指定节点（前、中、后序查找）</span></span><br><span class="line">        <span class="comment">//test_sample_order_search();</span></span><br><span class="line">        <span class="comment">// 3.删除节点（后序遍历为例）</span></span><br><span class="line">        <span class="comment">//test_del_node();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="顺序二叉树"><a href="#顺序二叉树" class="headerlink" title="顺序二叉树"></a>顺序二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 顺序二叉树（只考虑完全二叉树）</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  n: 表示二叉树中的第几个元素（按0开始编号）</span></span><br><span class="line"><span class="comment"> *  （1）第n个元素的左子节点为2*n + 1</span></span><br><span class="line"><span class="comment"> *  （2）第n个元素的右子节点为2*n + 2、</span></span><br><span class="line"><span class="comment"> *  （3）第n个元素的父节点为arr[(n-1)/2]</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> *  给个数组：&#123;1, 2, 3, 4, 5, 6, 7&#125;，要求以前序遍历的方式遍历，结果为：1,2,4,5,3,6,7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        ArrayBinaryTree arrayBinaryTree = <span class="keyword">new</span> ArrayBinaryTree(arr);</span><br><span class="line">        arrayBinaryTree.preOrder(); <span class="comment">// 前序：1,2,4,5,3,6,7</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        arrayBinaryTree.infixOrder(); <span class="comment">// 中序：4,2,5,1,6,3,7</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        arrayBinaryTree.postOrder(); <span class="comment">// 后序：4,5,2,6,7,3,1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 线索化二叉树</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *      &#123;1, 3, 6, 8, 10, 14&#125;</span></span><br><span class="line"><span class="comment"> *  中序遍历方式：</span></span><br><span class="line"><span class="comment"> *      &#123;8, 3, 10, 1, 14, 6&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"林冲"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"关胜"</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"张包"</span>);</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line">        <span class="comment">// 测试：以10号结点测试</span></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">"10号结点的前驱节点："</span> + leftNode); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(<span class="string">"10号结点的后继节点："</span> + rightNode); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 堆排序</span></span><br><span class="line"><span class="comment"> * 排序思想：</span></span><br><span class="line"><span class="comment"> *  1.将待排序序列构造成一个大顶堆</span></span><br><span class="line"><span class="comment"> *  2.此时，整个队列最大的就是堆顶</span></span><br><span class="line"><span class="comment"> *  3.将其与末尾元素进行交换，此时末尾就为最大值</span></span><br><span class="line"><span class="comment"> *  4.然后将剩余n-1个元素重新构成一个堆，这样会得到n个元素的次小值，</span></span><br><span class="line"><span class="comment"> *      如此反复执行，便能得到一个有序序列</span></span><br><span class="line"><span class="comment"> *  可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后得到一个有序序列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：</span></span><br><span class="line"><span class="comment"> *    &#123;4, 6, 8, 5, 9&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">/*int[] arr = new int[8000000];</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; 8000000; i++) &#123;</span></span><br><span class="line"><span class="comment">            arr[i] = new Random().nextInt(8000000);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">//System.out.println("arr=" + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="赫夫曼编码（数据压缩）"><a href="#赫夫曼编码（数据压缩）" class="headerlink" title="赫夫曼编码（数据压缩）"></a>赫夫曼编码（数据压缩）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 数据压缩</span></span><br><span class="line"><span class="comment"> * 原理分析：</span></span><br><span class="line"><span class="comment"> * （1）生成赫夫曼树</span></span><br><span class="line"><span class="comment"> *      i like like like java do you like a java</span></span><br><span class="line"><span class="comment"> * （2）生成赫夫曼树对应的编码</span></span><br><span class="line"><span class="comment"> *      =01,a=100 d=11000 u=11101 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011</span></span><br><span class="line"><span class="comment"> * （3）使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将"i like like ..."</span></span><br><span class="line"><span class="comment"> *      字符串生成对应的编码数据，形式如下：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanZip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 赫夫曼编码集合</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// （1）生成赫夫曼树</span></span><br><span class="line">        String content = <span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line">        <span class="comment">// （3）使用赫夫曼编码来生成赫夫曼编码数据，即按照上面的赫夫曼编码，将"i like like ..."</span></span><br><span class="line">        <span class="comment">//      字符串生成对应的编码数据，形式如下：</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodesBytes = huffmanZip(content.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"压缩后的结果："</span> + <span class="keyword">new</span> String(huffmanCodesBytes) + <span class="string">" 长度="</span> + huffmanCodesBytes.length);</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span><br><span class="line">        System.out.println(<span class="string">"原字符串："</span> + <span class="keyword">new</span> String(sourceBytes));</span><br><span class="line">        String srcFile = <span class="string">"D:\\2019\\doc\\img\\huffman.png"</span>;</span><br><span class="line">        String dstFile = <span class="string">"D:\\2019\\doc\\img\\huffman.zip"</span>;</span><br><span class="line">        zipFile(srcFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二叉排序树</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> *  1.排序树添加：</span></span><br><span class="line"><span class="comment"> *      （1）if（待插入节点值 &gt; 当前节点值） -&gt; 往右子树递归找（当右子树为空，找到了）</span></span><br><span class="line"><span class="comment"> *      （2）if（待插入节点值 &lt; 当前节点值） -&gt; 往左子树递归找（当左子树为空，找到了）</span></span><br><span class="line"><span class="comment"> *  2.排序树删除：（三种情况）</span></span><br><span class="line"><span class="comment"> *  情况一：删除叶子节点（比如：2,5,9,12）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）确定targetNode是parent的左子节点还是右子节点</span></span><br><span class="line"><span class="comment"> *      （4）根据前面的情况来删除：</span></span><br><span class="line"><span class="comment"> *              左子结点 -&gt; parent.left = null</span></span><br><span class="line"><span class="comment"> *              右子结点 -&gt; parent.right = null</span></span><br><span class="line"><span class="comment"> *  情况二：删除只有一颗子树的节点（比如：1）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）确定targetNode的子节点是左节点还右节点</span></span><br><span class="line"><span class="comment"> *      （4）确定targetNode是parent的左子节点还是右子节点</span></span><br><span class="line"><span class="comment"> *      （5）如果targetNode有左子节点</span></span><br><span class="line"><span class="comment"> *          5.1 如果targetNode是parent的左子节点 -&gt; parent.left = targetNode.left</span></span><br><span class="line"><span class="comment"> *          5.2 如果targetNode是parent的右子节点 -&gt; parent.right = targetNode.left</span></span><br><span class="line"><span class="comment"> *      （6）如果targetNode有右子节点</span></span><br><span class="line"><span class="comment"> *          6.1 如果targetNode是parent的左子节点 -&gt; parent.left = targetNode.right</span></span><br><span class="line"><span class="comment"> *          6.2 如果targetNode是parent的右子节点 -&gt; parent.right = targetNode.right</span></span><br><span class="line"><span class="comment"> *  情况三：删除有两颗子树的节点（比如：7, 3, 10）</span></span><br><span class="line"><span class="comment"> *      （1）先找到要删除的节点targetNode</span></span><br><span class="line"><span class="comment"> *      （2）找到targetNode的父节点</span></span><br><span class="line"><span class="comment"> *      （3）从targetNode的右子树找到最小的结点</span></span><br><span class="line"><span class="comment"> *      （4）用一个临时变量，将最小结点值保存temp=12</span></span><br><span class="line"><span class="comment"> *      （5）删除该最小节点</span></span><br><span class="line"><span class="comment"> *      （6）targetNode=temp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * &#123;7,3,10,12,5,1,9&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----中序遍历----"</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        <span class="comment">// 节点删除</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">1</span>; <span class="comment">// 2,5,9,12 | 7, 3, 10</span></span><br><span class="line">        binarySortTree.delNode(value);</span><br><span class="line">        System.out.println(<span class="string">"----中序遍历----"</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="平衡树（AVL树）"><a href="#平衡树（AVL树）" class="headerlink" title="平衡树（AVL树）"></a>平衡树（AVL树）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 平衡二叉树（AVL树）</span></span><br><span class="line"><span class="comment"> *  由于二叉排序树可能会出现问题，如&#123;1,2,3,4,5,6&#125;，就变成单链表了，引出解决方案：平衡二叉树</span></span><br><span class="line"><span class="comment"> * （1）左旋转</span></span><br><span class="line"><span class="comment"> *      条件：当右子树高度-左子树高度&gt;1</span></span><br><span class="line"><span class="comment"> *      步骤：</span></span><br><span class="line"><span class="comment"> *          1）将A节点的右节点的左节点，指向A节点</span></span><br><span class="line"><span class="comment"> *          2）将A节点的右节点，指向A节点的右节点的左节点</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）创建一个新节点newNode，并设置值为当前节点的值：newNode.value = value</span></span><br><span class="line"><span class="comment"> *          2）把新节点的左子树设置为当前节点的左子树：newNode.left = left</span></span><br><span class="line"><span class="comment"> *          3）把当前节点的值替换为右子节点的值</span></span><br><span class="line"><span class="comment"> *          4）把当前节点的右子树设置成右子树的右子树</span></span><br><span class="line"><span class="comment"> *          5）把当前节点的左子树设置成新的节点</span></span><br><span class="line"><span class="comment"> *      案例：</span></span><br><span class="line"><span class="comment"> *          &#123;4,3,6,5,7,8&#125;</span></span><br><span class="line"><span class="comment"> * （2）右旋转（与左旋转原理一样）</span></span><br><span class="line"><span class="comment"> * （3）双旋转</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）当符合右旋转的条件时，</span></span><br><span class="line"><span class="comment"> *          1.1）如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="comment"> *          1.2）先对当前这个节点的左节点进行左旋转</span></span><br><span class="line"><span class="comment"> *          1.3）再对当前结点进行右旋转的操作即可</span></span><br><span class="line"><span class="comment"> *          2）当符合左旋转的条件时（与符合右旋转的条件同理）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;;</span></span><br><span class="line">        <span class="comment">// 双旋转</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;2, 1, 6, 5, 7, 3&#125;;</span></span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        Arrays.stream(arr).forEach(m -&gt; avlTree.add(<span class="keyword">new</span> Node(m)));</span><br><span class="line">        System.out.println(<span class="string">"---中序遍历---"</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        System.out.println(<span class="string">"---平衡处理---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"树的高度："</span> + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">"左子树的高度："</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">"右子树的高度："</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>描述：包括二叉树与B树、2-3树、B树、B+树和B*树<br>代码：暂无</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 图</span></span><br><span class="line"><span class="comment"> * 基本概念：顶点、边、路径、无向图、有向图、带权图</span></span><br><span class="line"><span class="comment"> * 案例：(实现如下的效果)</span></span><br><span class="line"><span class="comment"> *      A   B   C   D   E</span></span><br><span class="line"><span class="comment"> *  A   0   1   1   0   0</span></span><br><span class="line"><span class="comment"> *  B   1   0   1   1   1</span></span><br><span class="line"><span class="comment"> *  C   1   1   0   0   0</span></span><br><span class="line"><span class="comment"> *  D   0   1   0   0   0</span></span><br><span class="line"><span class="comment"> *  E   0   1   0   0   0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  （1）用图的方式实现上述效果图</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）5个顶点：A\B\C\D\E</span></span><br><span class="line"><span class="comment"> *          2）1-表示连通，0-表示不连通</span></span><br><span class="line"><span class="comment"> *  （2）用深度优先方式遍历</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line"><span class="comment"> *          2）查找结点v的第一个邻接结点</span></span><br><span class="line"><span class="comment"> *          3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line"><span class="comment"> *          4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line"><span class="comment"> *          5）查找结点v的w邻接结点的下一个结点，转到步骤3</span></span><br><span class="line"><span class="comment"> *  （3）用广度优先方式遍历</span></span><br><span class="line"><span class="comment"> *      思路分析：</span></span><br><span class="line"><span class="comment"> *          1）访问初始结点v并标记结点v已访问</span></span><br><span class="line"><span class="comment"> *          2）结点v入队列</span></span><br><span class="line"><span class="comment"> *          3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line"><span class="comment"> *          4）出队列，取得队头结点u</span></span><br><span class="line"><span class="comment"> *          5）查找结点u的第一个邻接结点w</span></span><br><span class="line"><span class="comment"> *          6）若结点u的邻接结点w不存在，则转到步骤3；否则执行以下三个步骤：</span></span><br><span class="line"><span class="comment"> *              6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line"><span class="comment"> *              6.2 结点w入队列</span></span><br><span class="line"><span class="comment"> *              6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; vertexList; <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges; <span class="comment">// 存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges; <span class="comment">// 表示边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited; <span class="comment">// 边是否被访问过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建图</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// （1）添加顶点</span></span><br><span class="line">        graph.insertVertex(<span class="string">"A"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"B"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"C"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"D"</span>);</span><br><span class="line">        graph.insertVertex(<span class="string">"E"</span>);</span><br><span class="line">        <span class="comment">// （2）添加边</span></span><br><span class="line">        <span class="comment">// A-B,A-C,B-C,B-D,B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// show一把</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">// 深度优先思路分析：</span></span><br><span class="line">        <span class="comment">// 1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line">        <span class="comment">// 2）查找结点v的第一个邻接结点</span></span><br><span class="line">        <span class="comment">// 3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line">        <span class="comment">// 4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line">        <span class="comment">// 5）查找结点v的w邻接结点的下一个结点，转到步骤3</span></span><br><span class="line">        System.out.println(<span class="string">"=========== 深度优先  =========="</span>);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 广度优先思路分析：思路分析：</span></span><br><span class="line">        <span class="comment">// 1）访问初始结点v并标记结点v已访问</span></span><br><span class="line">        <span class="comment">// 2）结点v入队列</span></span><br><span class="line">        <span class="comment">// 3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line">        <span class="comment">// 4）出队列，取得队头结点u</span></span><br><span class="line">        <span class="comment">// 5）查找结点u的第一个邻接结点w</span></span><br><span class="line">        <span class="comment">// 6）若结点u的邻接结点w不存在，则转到步骤3；否则执行以下三个步骤：</span></span><br><span class="line">        <span class="comment">//  6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line">        <span class="comment">//  6.2 结点w入队列</span></span><br><span class="line">        <span class="comment">//  6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line">        System.out.println(<span class="string">"=========== 广度优先  =========="</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先算法"><a href="#深度优先算法" class="headerlink" title="深度优先算法"></a>深度优先算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isVisited 访问标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 从第0个元素开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1）访问初始结点，并标记结点v为已访问</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 2）查找结点v的第一个邻接结点</span></span><br><span class="line">    <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">    <span class="comment">// 3）若w存在，则继续执行步骤4，如果w不存在，则回到步骤1，将从v的下一个结点继续</span></span><br><span class="line">    <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">            dfs(isVisited, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果w已经被访问过</span></span><br><span class="line">        w = getNextNeighbor(i, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4）若w未被访问，对w进行深度优先遍历递归（即把w当作别一个v，然后进行步骤123）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1）访问初始结点v并标记结点v已访问</span></span><br><span class="line">    System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">    isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 2）结点v入队列</span></span><br><span class="line">    LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.addLast(i);</span><br><span class="line">    <span class="comment">// 3）当队列非空时，继续执行，否则算法结束</span></span><br><span class="line">    Integer u;</span><br><span class="line">    Integer w;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 4）出队列，取得队头结点u</span></span><br><span class="line">        u = (Integer) queue.removeFirst();</span><br><span class="line">        <span class="comment">// 5）查找结点u的第一个邻接结点w</span></span><br><span class="line">        w = getFirstNeighbor(u);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 6.1 若结点w尚未被访问，则访问结点w并标记为已访问</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + <span class="string">"-&gt;"</span>);</span><br><span class="line">                isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 6.2 结点w入队列</span></span><br><span class="line">                queue.addLast(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6</span></span><br><span class="line">            w = getNextNeighbor(u, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="程序员常用10大算法"><a href="#程序员常用10大算法" class="headerlink" title="程序员常用10大算法"></a>程序员常用10大算法</h3><h4 id="二分查找算法（非递归）"><a href="#二分查找算法（非递归）" class="headerlink" title="二分查找算法（非递归）"></a>二分查找算法（非递归）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 二分查询（非递归方式）</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * &#123;1,3,8,10,11,67,100&#125;，编程实现二分查找，要求使用非递归方式完成。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNonRecursive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，下标为："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 向左找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 向右找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 分治算法案例：汉诺塔</span></span><br><span class="line"><span class="comment"> * （1）基本概念</span></span><br><span class="line"><span class="comment"> * 分治算法是一种很重要的算法，字面上的解释是“分而治之”，就是把一个复杂的问题</span></span><br><span class="line"><span class="comment"> * 分解成两个或更多的相同或相似的子问题...直到最后子问题可以简单的直接求解，原</span></span><br><span class="line"><span class="comment"> * 问题的解即子问题的解的合并，这个技巧就是很多高效算法的基础，如排序算法（快速排序，归并排序），傅里叶变换（快速傅里叶变换）...</span></span><br><span class="line"><span class="comment"> * （2）基本步骤</span></span><br><span class="line"><span class="comment"> * 1）分解：将原问题分解为若干个规模较小的问题，相互独立，与原问题形式相同的子问题</span></span><br><span class="line"><span class="comment"> * 2）解决：若子问题规模较小则直接解决，否则递归地解各个子问题</span></span><br><span class="line"><span class="comment"> * 3）合并：将各个子问题的解合并为原问题的解</span></span><br><span class="line"><span class="comment"> * （3）分治算法设计模式</span></span><br><span class="line"><span class="comment"> * if |P|&lt;=n0</span></span><br><span class="line"><span class="comment"> * then return (ADHOC(P))</span></span><br><span class="line"><span class="comment"> * // 将P分解为较小的问题P1,P2...PK</span></span><br><span class="line"><span class="comment"> * for i &lt;- 1 to k</span></span><br><span class="line"><span class="comment"> * do yi &lt;- Divide-and-Conquer(Pi) 递归解决Pi</span></span><br><span class="line"><span class="comment"> * T &lt;- MERGE(y1,y2...yk) 合并子问题</span></span><br><span class="line"><span class="comment"> * return (T)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * |P|：表示问题P的规模</span></span><br><span class="line"><span class="comment"> * n0：表示阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。</span></span><br><span class="line"><span class="comment"> * ADHOC(P)：是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解</span></span><br><span class="line"><span class="comment"> * 算法MERGE(y1,y2...yk)：是该分治算法中的合并子算法，用于将P的子问题P1,P2...PK的相应的解y1,y2,..yk合并为P的解。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 经典案例：汉诺塔</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * （1）如果有一个盘，A-&gt;C</span></span><br><span class="line"><span class="comment"> * n0=2</span></span><br><span class="line"><span class="comment"> * if (n&lt;=n0) &#123;</span></span><br><span class="line"><span class="comment"> * // 直接解出来</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * // 将P分解为较小的问题P1,P2...PK</span></span><br><span class="line"><span class="comment"> * while(n&gt;n0) &#123;</span></span><br><span class="line"><span class="comment"> * 分(n);</span></span><br><span class="line"><span class="comment"> * n--;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * // T &lt;- MERGE(y1,y2...yk) 合并子问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiTower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123; <span class="comment">// 只有一个盘，直接解出</span></span><br><span class="line">            System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果n&gt;=2的情况</span></span><br><span class="line">            <span class="comment">// 1.先把最上面的所有盘A-&gt;B，移动过程会使用C</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">// 2.把最下边的盘A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">            <span class="comment">// 3.把B塔所有盘从B-&gt;C，移动过程使用到A</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 动态规划算法案例：背包问题</span></span><br><span class="line"><span class="comment"> * 思路分析：</span></span><br><span class="line"><span class="comment"> * （1）假设：</span></span><br><span class="line"><span class="comment"> * 用w[i],v[i]来确定是否需要将该物品放入背包中；</span></span><br><span class="line"><span class="comment"> * 即对于给定的n个物品，设v[i],w[i]分别为第i个物品的价值和重量，C为背包的容量。</span></span><br><span class="line"><span class="comment"> * 再令v[i][j] 表示在前i个物品中能够装入容量j的背包的最大价值。则我们有下面的结果：</span></span><br><span class="line"><span class="comment"> * （2）结论：</span></span><br><span class="line"><span class="comment"> * 1）当v[i][0]=v[0][j]=0; // 表示填入表 第一行和第一列是0</span></span><br><span class="line"><span class="comment"> * 2）当w[i]&gt;j时；v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span></span><br><span class="line"><span class="comment"> * 3）当j&gt;=w[i]时；v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</span></span><br><span class="line"><span class="comment"> * // 当准入的新增的商品的容量小于等于当前背包的容量，装入方式：</span></span><br><span class="line"><span class="comment"> * v[i-1][j]：就是上一个单元格的装入的最大值</span></span><br><span class="line"><span class="comment"> * v[i]：表示当前商品的价值</span></span><br><span class="line"><span class="comment"> * v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值</span></span><br><span class="line"><span class="comment"> * 当j&gt;=w[i]时：v[i][j] = max&#123;v[i-1][j], v[i-1][j-w[i]]&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 案例：</span></span><br><span class="line"><span class="comment"> * 物品      重量  价格</span></span><br><span class="line"><span class="comment"> * 吉他（G）   1   1500</span></span><br><span class="line"><span class="comment"> * 音响（S）   4   3000</span></span><br><span class="line"><span class="comment"> * 电脑（L）   3   2000</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;; <span class="comment">// 物品重量</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">// 物品价值</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">// 背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length; <span class="comment">// 物品个数</span></span><br><span class="line">        <span class="comment">// 创建二维数据</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 1）当v[i][0]=v[0][j]=0; // 表示填入表 第一行和第一列是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">// 第一列为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一行为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123; <span class="comment">// 不处理第1列</span></span><br><span class="line">                <span class="comment">// 当w[i]&gt;j时；v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当j&gt;=w[i]时；v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</span></span><br><span class="line">                    <span class="comment">// v[i-1][j]：就是上一个单元格的装入的最大值</span></span><br><span class="line">                    <span class="comment">// v[i]：表示当前商品的价值</span></span><br><span class="line">                    <span class="comment">// v[i-1][j-w[i]]：装入i-1商品，到剩余空间j-w[i]的最大值</span></span><br><span class="line">                    <span class="comment">// 当准入的新增的商品的容量小于等于当前背包的容量，装入方式：</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123; <span class="comment">// w[i]-&gt;w[i-1]替换?</span></span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        <span class="comment">// 把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出一把</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">                if (path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(String.format("第%d个商品放入背包", i));</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">// 其实我们只需要最后的放入</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"第%d个商品放入到背包"</span>, i));</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> KMP算法</span></span><br><span class="line"><span class="comment"> * 基本介绍：</span></span><br><span class="line"><span class="comment"> * （1）暴力匹配算法</span></span><br><span class="line"><span class="comment"> *      1）如果当前字符匹配成功（即str1[i]=str2[i]），则i++,j++，继续匹配下一个字符</span></span><br><span class="line"><span class="comment"> *      2）如果失败，令i=i-(j-1)，j=0，相当于每次匹配失败时，i回溯，j被转为0</span></span><br><span class="line"><span class="comment"> *      3）用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费大量时间。（不可行）</span></span><br><span class="line"><span class="comment"> *      4）暴力匹配实现</span></span><br><span class="line"><span class="comment"> * （2）KMP算法介绍</span></span><br><span class="line"><span class="comment"> *      1）KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置就经典算法。</span></span><br><span class="line"><span class="comment"> *      2）Knuth-Morris-Pratt字符串查找法，简称KMP。</span></span><br><span class="line"><span class="comment"> *      3）KMP算法就是利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共序列的长度，每次回溯时，通过next数组找到，</span></span><br><span class="line"><span class="comment"> *          前面匹配的位置，省去了大量的计算时间</span></span><br><span class="line"><span class="comment"> *      4）参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力匹配</span></span><br><span class="line">        String str1 = <span class="string">"ABCDE"</span>;</span><br><span class="line">        String str2 = <span class="string">"CD"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，位置："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// KMP算法介绍</span></span><br><span class="line">        <span class="comment">// 字符串模板匹配值</span></span><br><span class="line">        str1 = <span class="string">"BBC ABCDAD ABCDABCDABDE"</span>;</span><br><span class="line">        str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">        <span class="comment">/*int[] next = kmpNext("ABCDABD");</span></span><br><span class="line"><span class="comment">        System.out.println("next=" + Arrays.toString(next));*/</span></span><br><span class="line">        index = kmpMatch(str1, str2, kmpNext(str2));</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找到了，位置："</span> + index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有找到！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 贪心算法</span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> * （1）使用穷举法，列出每个可能广播台集合，这被称为幂集。</span></span><br><span class="line"><span class="comment"> * （2）假设有n个广播台，则广播台的组合共有2^n-1个，假设每秒可以计算10个子集</span></span><br><span class="line"><span class="comment"> *      广播台数量   子集总数    需要的时间</span></span><br><span class="line"><span class="comment"> *      5               32          3.2秒</span></span><br><span class="line"><span class="comment"> *      10              1024        102.4秒</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例：集合覆盖问题</span></span><br><span class="line"><span class="comment"> *      假设存在下面需要付费的广播台，以及广播信号可以覆盖的地区，如何选择</span></span><br><span class="line"><span class="comment"> *      最少的广播台，让所有的地区都可以接收信息</span></span><br><span class="line"><span class="comment"> *      广播台     覆盖地区</span></span><br><span class="line"><span class="comment"> *      K1          "北京","上海","天津"</span></span><br><span class="line"><span class="comment"> *      K2          "广州","北京","深圳"</span></span><br><span class="line"><span class="comment"> *      K3          "成都","上海","杭州"</span></span><br><span class="line"><span class="comment"> *      K4          "上海","天津"</span></span><br><span class="line"><span class="comment"> *      K5          "杭州","大连"</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/9/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 广播电台</span></span><br><span class="line">        broadcasts.put(<span class="string">"K1"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"北京"</span>, <span class="string">"上海"</span>, <span class="string">"天津"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K2"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"广州"</span>, <span class="string">"北京"</span>, <span class="string">"深圳"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K3"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"成都"</span>, <span class="string">"上海"</span>, <span class="string">"杭州"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K4"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"上海"</span>, <span class="string">"天津"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        broadcasts.put(<span class="string">"K5"</span>, Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"杭州"</span>, <span class="string">"大连"</span>&#125;).collect(Collectors.toSet()));</span><br><span class="line">        <span class="comment">// [上海, 天津, 北京, 广州, 深圳, 成都, 杭州, 大连]</span></span><br><span class="line">        List&lt;String&gt; allAreas = broadcasts.values().stream().flatMap(Collection::stream).distinct().collect(Collectors.toList()); <span class="comment">// 表示所有需要覆盖的地区</span></span><br><span class="line">        System.out.println(<span class="string">"allAreas="</span> + allAreas);</span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 选择的地区集合</span></span><br><span class="line">        <span class="comment">// 定义一个临时的集合，在遍历过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        Set&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String maxKey; <span class="comment">// 最大的电台，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台key</span></span><br><span class="line">        <span class="keyword">while</span> (allAreas.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>; <span class="comment">// 置空</span></span><br><span class="line">            <span class="comment">// 遍历broadcasts，取出对应key</span></span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear(); <span class="comment">// 清空</span></span><br><span class="line">                Set&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                tempSet.retainAll(allAreas); <span class="comment">// tempSet = tempSet与allAreas的交集</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp; (maxKey == <span class="keyword">null</span></span><br><span class="line">                        || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">// 将maxKey指向的广播电台覆盖地区，从allAreas去掉</span></span><br><span class="line">                System.out.println(<span class="string">"maxKey="</span> + maxKey);</span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"得到的选择结果是："</span> + selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普利姆算法"><a href="#普利姆算法" class="headerlink" title="普利姆算法"></a>普利姆算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 普利姆算法</span></span><br><span class="line"><span class="comment"> * 应用案例：修路问题</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> *  1.从&lt;A&gt;顶点开始处理=&gt;&lt;A,G&gt; 2</span></span><br><span class="line"><span class="comment"> *      A,C[7] A-G[2] A-B[5] =&gt;</span></span><br><span class="line"><span class="comment"> *  2.&lt;A,G&gt;开始，将A和G顶点和他们相邻的还没有访问的顶面进行处理=&gt; &lt;A,G,B&gt;</span></span><br><span class="line"><span class="comment"> *      A-C[7] A-B[5] G-B[3] G-F[6]</span></span><br><span class="line"><span class="comment"> *  3.&lt;A,G,B&gt;开始，将A,G,B顶点和他们相邻的还没有访问的顶面进行处理=&gt; &lt;A,G,B&gt;</span></span><br><span class="line"><span class="comment"> *      A-C[7] G-E[4] G-F[6] B-D[9]</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  4.&#123;A,G,B,E,F,D&#125; -&gt; C // 第6次大循环，对应边&lt;A,C&gt;权值：7 =&gt; &lt;A,G,B,E,F,D,C&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10000</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10000</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        <span class="comment">// 创建最小树</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        <span class="comment">// 测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 克鲁斯卡尔算法</span></span><br><span class="line"><span class="comment"> * 案例：公交车问题</span></span><br><span class="line"><span class="comment"> * 1. 某城市新增7个站点，A,B,C,D,E,F,G,现在需要修路7个站点连通</span></span><br><span class="line"><span class="comment"> * 2. 各个站点距离用连线表示，比如A-B距离12公里</span></span><br><span class="line"><span class="comment"> * 3. 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNums; <span class="comment">// 边的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs,<span class="keyword">int</span>[][] matrix )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertexs = vertexs;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="comment">// 统计边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123; <span class="comment">// 每次少一条边，所以是i+1</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNums++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                     <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span>&#123; <span class="number">0</span>,   <span class="number">12</span>, INF,  INF, INF, <span class="number">16</span>,  <span class="number">14</span> &#125;,</span><br><span class="line">                <span class="comment">/*B*/</span>&#123; <span class="number">12</span>,  <span class="number">0</span>,   <span class="number">10</span>,  INF, INF, <span class="number">7</span>,   INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span>&#123; INF, <span class="number">10</span>,  <span class="number">0</span>,   <span class="number">3</span>,    <span class="number">5</span>,  <span class="number">6</span>,   INF &#125;,</span><br><span class="line">                <span class="comment">/*D*/</span>&#123; INF, INF, <span class="number">3</span>,   <span class="number">0</span>,    <span class="number">4</span>,  INF, INF &#125;,</span><br><span class="line">                <span class="comment">/*E*/</span>&#123; INF, INF, <span class="number">5</span>,   <span class="number">4</span>,    <span class="number">0</span>,  <span class="number">2</span>,   <span class="number">8</span> &#125;,</span><br><span class="line">                <span class="comment">/*F*/</span>&#123; <span class="number">16</span>,  <span class="number">7</span>,   <span class="number">6</span>,   INF,  <span class="number">2</span>,  <span class="number">0</span>,   <span class="number">9</span> &#125;,</span><br><span class="line">                <span class="comment">/*G*/</span>&#123; <span class="number">14</span>,  INF, INF, INF,  <span class="number">8</span>,  <span class="number">9</span>,   <span class="number">0</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建KruskalCase对象实例</span></span><br><span class="line">        KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 迪杰斯特拉算法</span></span><br><span class="line"><span class="comment"> * 案例：最短路径问题</span></span><br><span class="line"><span class="comment"> * 1. 战争时期，胜利乡有7个村庄(A,B,C,D,E,F,G)，现在有6个邮差，从G点出发，需要分别把邮件分别送到A,B,C,D,E,F 六个村庄</span></span><br><span class="line"><span class="comment"> * 2. 各个村庄的距离用边线表示（权），比如A-B距离5公里</span></span><br><span class="line"><span class="comment"> * 3. 问：如何计算最短距离</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">// 创建Graph对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">// 测试迪杰斯特拉算法</span></span><br><span class="line">        graph.dsj(<span class="number">6</span>); <span class="comment">// G</span></span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 弗洛伊德算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        FloydGraph graph = <span class="keyword">new</span> FloydGraph(vertex.length, matrix, vertex);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 马踏棋盘算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X; <span class="comment">// 棋盘的列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y; <span class="comment">// 棋盘的行数</span></span><br><span class="line">    <span class="comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line">    <span class="comment">//使用一个属性，标记是否棋盘的所有位置都被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished; <span class="comment">// 如果为true,表示成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"骑士周游算法，开始运行~~"</span>);</span><br><span class="line">        <span class="comment">//测试骑士周游算法是否正确</span></span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>; <span class="comment">//马儿初始位置的行，从1开始编号</span></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>; <span class="comment">//马儿初始位置的列，从1开始编号</span></span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];<span class="comment">//初始值都是false</span></span><br><span class="line">        <span class="comment">//测试一下耗时</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"共耗时: "</span> + (end - start) + <span class="string">" 毫秒"</span>);</span><br><span class="line">        <span class="comment">//输出棋盘的最后情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] rows : chessboard) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> step: rows) &#123;</span><br><span class="line">                System.out.print(step + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>spring常用注解</title>
    <url>/2019/10/28/spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>该文章主要是描述spring常用的几个注解，每个注解都有一个小case去测试验证，感兴趣的同学可以在以下测试用例中断点调试每个注解的原理。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>描述：相关于spring-context.xml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Bean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试获取第一个bean..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig01<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 根据类型获取bean</span></span><br><span class="line">    String[] namesForType = applicationContext.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String name : namesForType) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据id获取bean</span></span><br><span class="line">    Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    Person person01 = applicationContext.getBean(<span class="string">"person01"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    assertEquals(<span class="string">"zhangsan"</span>, person.getName());</span><br><span class="line">    assertEquals(<span class="string">"zhangsan01"</span>, person01.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 配置类==配置文件</span></span><br><span class="line"><span class="comment"> *      <span class="doctag">@Configuration</span> 使用配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 告诉Spring这是一个配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig01</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// @Bean(name = "person")，bean对应的id默认是方法名：person</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person01"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan01"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>描述：spring组件扫描的包位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_ComponentScan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@ComponentScan注解..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig02<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取所有bean定义信息</span></span><br><span class="line">    printBeans(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 配置类==配置文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span> 使用配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ComponentScan</span> 扫描组件包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Filter</span></span></span><br><span class="line"><span class="comment"> *      1.excludeFilters：扫描时需要排除哪些组件</span></span><br><span class="line"><span class="comment"> *      2.includeFilters + useDefaultFilters=false：扫描时需要包含哪些组件</span></span><br><span class="line"><span class="comment"> *      3.FilterType</span></span><br><span class="line"><span class="comment"> *              FilterType.ANNOTATION 按照注释</span></span><br><span class="line"><span class="comment"> *              FilterType.ASSIGNABLE_TYPE 按照给定的类型</span></span><br><span class="line"><span class="comment"> *              FilterType.CUSTOM 按照自定义规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.line.spring.ch01.config02"</span>,</span><br><span class="line">    <span class="comment">/*excludeFilters = &#123;</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;),</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = &#123;PersonService.class&#125;),</span></span><br><span class="line"><span class="comment">            @ComponentScan.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="comment">    &#125;,*/</span></span><br><span class="line">    includeFilters = &#123;</span><br><span class="line">            <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    &#125;, <span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig02</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>描述：spring bean的作用域，包括多例、单例、request、session</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Scope</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Scope：作用域..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig03<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Person person1 = applicationContext.getBean(<span class="string">"person03"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Person person2 = applicationContext.getBean(<span class="string">"person03"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    assertTrue(<span class="string">"scope不是为singleton"</span>,person1 == person2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Scope作用域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig03</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Scope</span></span></span><br><span class="line"><span class="comment">     *      prototype：多例</span></span><br><span class="line"><span class="comment">     *      singleton：单例（spring默认值）</span></span><br><span class="line"><span class="comment">     *      request：同一次请求创建一个实例</span></span><br><span class="line"><span class="comment">     *      session：同一个session创建一个请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scope</span>(scopeName = <span class="string">"prototype"</span>)</span><br><span class="line"><span class="comment">//    @Scope</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person03"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给容器添加Person..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan03"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>描述：懒加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Lazy：懒加载..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig04<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"spring加载完成..."</span>);</span><br><span class="line">    applicationContext.getBean(<span class="string">"person04"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Lazy懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig04</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Lazy</span></span></span><br><span class="line"><span class="comment">     *      单实例Bean，默认在容器启动的时候创建对象，</span></span><br><span class="line"><span class="comment">     *      懒加载，容器启动不创建对象，第一次使用（获取）bean创建对象并初始化。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Scope(scopeName = "singleton")</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"person04"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给容器添加person04...懒加载..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"zhangsan04"</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>描述：条件配置，是指符合条件的才使用配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Conditional</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Conditional：条件..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig05<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 根据类型获取bean</span></span><br><span class="line">    String[] namesForType = applicationContext.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String name : namesForType) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Conditional条件</span></span><br><span class="line"><span class="comment"> * 1.是指符合条件的才使用配置</span></span><br><span class="line"><span class="comment"> * 2.Conditional注解可以添加在类、方法上</span></span><br><span class="line"><span class="comment"> *  案例：根据当前系统自动使用不同的配置类，linux使用linuxCondition，window使用windowCondition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig05</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Conditional(&#123;WindowsCondition.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill Gates"</span>, <span class="number">62</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Conditional(&#123;LinuxCondition.class&#125;)</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>, <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>描述：导入组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Import</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"测试@Import：导入组件..."</span>);</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig06<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取所有bean定义信息</span></span><br><span class="line">    printBeans(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> Import：导入组件</span></span><br><span class="line"><span class="comment"> *  1.直接导入普通类，如：Color.class, Red.class</span></span><br><span class="line"><span class="comment"> *  2.使用ImportSelector选择器导入，如：MyImportSelector，</span></span><br><span class="line"><span class="comment"> *      (AnnotationMetadata annotationMetadata) &#123;</span></span><br><span class="line"><span class="comment"> *          return new String[]&#123;"com.line.spring.ch01.config06.Blue", "com.line.spring.ch01.config06.Yellow"&#125;;</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *  3.使用ImportBeanDefinitionRegistrar注册组件，如MyImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> *      (AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry) &#123;</span></span><br><span class="line"><span class="comment"> *          registry.registerBeanDefinition("rainbow", new RootBeanDefinition(Rainbow.class));</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019/10/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;Color<span class="class">.<span class="keyword">class</span>, <span class="title">Red</span>.<span class="title">class</span>, <span class="title">MyImportSelector</span>.<span class="title">class</span>, <span class="title">MyImportBeanDefinitionRegistrar</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig06</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>github地址： <a href="https://github.com/line007/jucdemo2/tree/master/src/main/java/com/line/spring/ch01" target="_blank" rel="noopener" title="完整代码">查看</a> </p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>markdownlearn</title>
    <url>/2019/10/25/markdownlearn/</url>
    <content><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</li>
<li>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</li>
<li>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</li>
<li>Markdown 编写的文档后缀为 .md, .markdown。</li>
</ul>
<h3 id="哪里下载"><a href="#哪里下载" class="headerlink" title="哪里下载"></a>哪里下载</h3><p>下载地址：<a href="https://typora.io/#windows" target="_blank" rel="noopener" title="typora">typora</a>.</p>
<h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p>学习网址：<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener" title="markdown中文网">markdown中文网</a>. </p>
<h4 id="第一个hello-world"><a href="#第一个hello-world" class="headerlink" title="第一个hello world"></a>第一个hello world</h4><p>新建一个helloWord.md</p>
<blockquote>
<p># Hello World!</p>
</blockquote>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>新建一个block.md<br><img src="/images/001.png" alt="Alt text"></p>
<h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><p>新建一个inline.md<br><img src="/images/002.png" alt="Alt text"></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>新建一个other.md<br><img src="/images/003.png" alt="Alt text"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
</search>
